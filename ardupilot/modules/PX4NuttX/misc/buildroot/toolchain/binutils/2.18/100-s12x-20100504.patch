diff -u -r -N binutils-2.18/bfd/archures.c binutils-2.18-s12x/bfd/archures.c
--- binutils-2.18/bfd/archures.c	2007-08-06 20:59:14.000000000 +0100
+++ binutils-2.18-s12x/bfd/archures.c	2008-03-21 13:28:47.000000000 +0000
@@ -236,6 +236,8 @@
 .#define bfd_mach_m6812_default 0
 .#define bfd_mach_m6812         1
 .#define bfd_mach_m6812s        2
+.  bfd_arch_m9s12x,   {* Freescale S12X *}
+.  bfd_arch_m9s12xg,  {* Freescale XGATE *}
 .  bfd_arch_z8k,       {* Zilog Z8000 *}
 .#define bfd_mach_z8001		1
 .#define bfd_mach_z8002		2
@@ -462,6 +464,8 @@
 extern const bfd_arch_info_type bfd_m32r_arch;
 extern const bfd_arch_info_type bfd_m68hc11_arch;
 extern const bfd_arch_info_type bfd_m68hc12_arch;
+extern const bfd_arch_info_type bfd_m9s12x_arch;
+extern const bfd_arch_info_type bfd_m9s12xg_arch;
 extern const bfd_arch_info_type bfd_m68k_arch;
 extern const bfd_arch_info_type bfd_m88k_arch;
 extern const bfd_arch_info_type bfd_maxq_arch;
@@ -533,6 +537,8 @@
     &bfd_m32r_arch,
     &bfd_m68hc11_arch,
     &bfd_m68hc12_arch,
+    &bfd_m9s12x_arch,
+    &bfd_m9s12xg_arch,
     &bfd_m68k_arch,
     &bfd_m88k_arch,
     &bfd_maxq_arch,
diff -u -r -N binutils-2.18/bfd/bfd-in2.h binutils-2.18-s12x/bfd/bfd-in2.h
--- binutils-2.18/bfd/bfd-in2.h	2007-08-06 20:59:15.000000000 +0100
+++ binutils-2.18-s12x/bfd/bfd-in2.h	2009-10-08 18:02:09.000000000 +0100
@@ -1907,6 +1907,8 @@
 #define bfd_mach_m6812_default 0
 #define bfd_mach_m6812         1
 #define bfd_mach_m6812s        2
+  bfd_arch_m9s12x,   /* Freescale 9S12X */
+  bfd_arch_m9s12xg, /* Freescale XGATE */
   bfd_arch_z8k,       /* Zilog Z8000 */
 #define bfd_mach_z8001         1
 #define bfd_mach_z8002         2
@@ -2361,6 +2363,8 @@
   BFD_RELOC_24_PCREL,
   BFD_RELOC_16_PCREL,
   BFD_RELOC_12_PCREL,
+  BFD_RELOC_10_PCREL,
+  BFD_RELOC_9_PCREL,
   BFD_RELOC_8_PCREL,
 
 /* Section relative relocations.  Some targets need this for DWARF2.  */
@@ -4025,6 +4029,10 @@
   BFD_RELOC_IA64_LTOFF_DTPREL22,
 
 /* Motorola 68HC11 reloc.
+This is the 8 bit high part of a linktime address  */
+  BFD_RELOC_M68HC11_HI8_16,
+
+/* Motorola 68HC11 reloc.
 This is the 8 bit high part of an absolute address.  */
   BFD_RELOC_M68HC11_HI8,
 
diff -u -r -N binutils-2.18/bfd/config.bfd binutils-2.18-s12x/bfd/config.bfd
--- binutils-2.18/bfd/config.bfd	2007-08-28 18:19:33.000000000 +0100
+++ binutils-2.18-s12x/bfd/config.bfd	2008-03-24 22:32:33.000000000 +0000
@@ -86,6 +86,7 @@
 i370)		 targ_archs=bfd_i370_arch ;;
 m6811*|m68hc11*) targ_archs="bfd_m68hc11_arch bfd_m68hc12_arch" ;;
 m6812*|m68hc12*) targ_archs="bfd_m68hc12_arch bfd_m68hc11_arch" ;;
+m9s12x*) targ_archs="bfd_m9s12x_arch bfd_m9s12xg_arch bfd_m68hc12_arch bfd_m68hc11_arch" ;;
 m68*)		 targ_archs=bfd_m68k_arch ;;
 m88*)		 targ_archs=bfd_m88k_arch ;;
 maxq*)		 targ_archs=bfd_maxq_arch ;;
@@ -732,6 +733,11 @@
     targ_selvecs="bfd_elf32_m68hc11_vec bfd_elf32_m68hc12_vec"
     ;;
 
+  m9s12x-*-* | m9s12xg-*-*)
+    targ_defvec=bfd_elf32_m68hc12_vec
+    targ_selvecs="bfd_elf32_m9s12xg_vec bfd_elf32_m68hc11_vec bfd_elf32_m68hc12_vec"
+    ;;
+
   m68*-motorola-sysv*)
     targ_defvec=m68ksysvcoff_vec
     ;;
diff -u -r -N binutils-2.18/bfd/configure binutils-2.18-s12x/bfd/configure
--- binutils-2.18/bfd/configure	2007-08-28 21:19:51.000000000 +0100
+++ binutils-2.18-s12x/bfd/configure	2008-03-20 19:58:27.000000000 +0000
@@ -19097,6 +19097,7 @@
     bfd_elf32_m32rlelin_vec)    tb="$tb elf32-m32r.lo elf32.lo $elf" ;;
     bfd_elf32_m68hc11_vec)	tb="$tb elf32-m68hc11.lo elf32-m68hc1x.lo elf32.lo $elf" ;;
     bfd_elf32_m68hc12_vec)	tb="$tb elf32-m68hc12.lo elf32-m68hc1x.lo elf32.lo $elf" ;;
+    bfd_elf32_m9s12xg_vec)	tb="$tb elf32-m9s12xg.lo elf32-m9s12xg.lo elf32.lo $elf" ;;
     bfd_elf32_m68k_vec)		tb="$tb elf32-m68k.lo elf32.lo $elf" ;;
     bfd_elf32_m88k_vec)		tb="$tb elf32-m88k.lo elf32.lo $elf" ;;
     bfd_elf32_mcore_big_vec)	tb="$tb elf32-mcore.lo elf32.lo $elf" ;;
diff -u -r -N binutils-2.18/bfd/configure.in binutils-2.18-s12x/bfd/configure.in
--- binutils-2.18/bfd/configure.in	2007-08-28 21:19:56.000000000 +0100
+++ binutils-2.18-s12x/bfd/configure.in	2008-03-20 19:56:40.000000000 +0000
@@ -675,6 +675,8 @@
     bfd_elf32_m32rlelin_vec)    tb="$tb elf32-m32r.lo elf32.lo $elf" ;;
     bfd_elf32_m68hc11_vec)	tb="$tb elf32-m68hc11.lo elf32-m68hc1x.lo elf32.lo $elf" ;;
     bfd_elf32_m68hc12_vec)	tb="$tb elf32-m68hc12.lo elf32-m68hc1x.lo elf32.lo $elf" ;;
+    bfd_elf32_m9s12x_vec)	tb="$tb elf32-m68hc12.lo elf32-m68hc1x.lo elf32.lo $elf" ;;
+    bfd_elf32_m9s12xg_vec)	tb="$tb elf32-m9s12xg.lo elf32-m9s12xg.lo elf32.lo $elf" ;;
     bfd_elf32_m68k_vec)		tb="$tb elf32-m68k.lo elf32.lo $elf" ;;
     bfd_elf32_m88k_vec)		tb="$tb elf32-m88k.lo elf32.lo $elf" ;;
     bfd_elf32_mcore_big_vec)	tb="$tb elf32-mcore.lo elf32.lo $elf" ;;
diff -u -r -N binutils-2.18/bfd/cpu-m9s12x.c binutils-2.18-s12x/bfd/cpu-m9s12x.c
--- binutils-2.18/bfd/cpu-m9s12x.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.18-s12x/bfd/cpu-m9s12x.c	2008-03-21 13:54:17.000000000 +0000
@@ -0,0 +1,40 @@
+/* BFD support for the Motorola 9S12X processor
+   Copyright 1999, 2000, 2002, 2003, 2007 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+const bfd_arch_info_type bfd_m9s12x_arch =
+{
+    16,	/* 16 bits in a word */
+    32,	/* 16 bits in an address */
+    8,	/* 8 bits in a byte */
+    bfd_arch_m9s12x,
+    0,
+    "m9s12x",
+    "m9s12x",
+    4, /* section alignment power */
+    TRUE,
+    bfd_default_compatible,
+    bfd_default_scan,
+    0,
+};
+
diff -u -r -N binutils-2.18/bfd/cpu-m9s12xg.c binutils-2.18-s12x/bfd/cpu-m9s12xg.c
--- binutils-2.18/bfd/cpu-m9s12xg.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.18-s12x/bfd/cpu-m9s12xg.c	2008-03-24 22:44:17.000000000 +0000
@@ -0,0 +1,40 @@
+/* BFD support for the Motorola 9S12-XGATE processor
+   Copyright 1999, 2000, 2002, 2003, 2007 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+const bfd_arch_info_type bfd_m9s12xg_arch =
+{
+    16,	/* 16 bits in a word */
+    32,	/* 16 bits in an address */
+    8,	/* 8 bits in a byte */
+    bfd_arch_m9s12xg,
+    0,
+    "m9s12xg",
+    "m9s12xg",
+    4, /* section alignment power */
+    TRUE,
+    bfd_default_compatible,
+    bfd_default_scan,
+    0,
+};
+
diff -u -r -N binutils-2.18/bfd/elf32-m68hc11.c binutils-2.18-s12x/bfd/elf32-m68hc11.c
--- binutils-2.18/bfd/elf32-m68hc11.c	2007-08-06 20:59:27.000000000 +0100
+++ binutils-2.18-s12x/bfd/elf32-m68hc11.c	2009-10-08 18:06:37.000000000 +0100
@@ -274,7 +274,22 @@
 	 0x00ff,		/* dst_mask */
 	 FALSE),		/* pcrel_offset */
 
-  EMPTY_HOWTO (14),
+
+  /* A 8 bit absolute relocation (upper address) */
+  HOWTO (R_M68HC11_HI8_16,		/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */ // was 0
+	 16,			/* bitsize */ // was 8
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */ // was 0
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_M68HC11_HI8_16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
   EMPTY_HOWTO (15),
   EMPTY_HOWTO (16),
   EMPTY_HOWTO (17),
@@ -340,6 +355,7 @@
 
   {BFD_RELOC_M68HC11_RL_JUMP, R_M68HC11_RL_JUMP},
   {BFD_RELOC_M68HC11_RL_GROUP, R_M68HC11_RL_GROUP},
+  {BFD_RELOC_M68HC11_HI8_16, R_M68HC11_HI8_16},
 };
 
 static reloc_howto_type *
diff -u -r -N binutils-2.18/bfd/elf32-m68hc12.c binutils-2.18-s12x/bfd/elf32-m68hc12.c
--- binutils-2.18/bfd/elf32-m68hc12.c	2007-08-06 20:59:27.000000000 +0100
+++ binutils-2.18-s12x/bfd/elf32-m68hc12.c	2009-10-08 18:06:45.000000000 +0100
@@ -151,7 +151,7 @@
 	 0,			/* bitpos */
 	 complain_overflow_bitfield,	/* complain_on_overflow */
 	 bfd_elf_generic_reloc,	/* special_function */
-	 "R_M68HC12_HI8",	/* name */
+	 "R_M68HC11_HI8",	/* name */
 	 FALSE,			/* partial_inplace */
 	 0x00ff,		/* src_mask */
 	 0x00ff,		/* dst_mask */
@@ -323,7 +323,21 @@
 	 0x00ff,		/* dst_mask */
 	 FALSE),		/* pcrel_offset */
 
-  EMPTY_HOWTO (14),
+  /* A 8 bit absolute relocation (upper address) */
+  HOWTO (R_M68HC11_HI8_16,		/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */ // was 0
+	 16,			/* bitsize */ // was 8
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */ // was 0
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_M68HC11_HI8_16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
   EMPTY_HOWTO (15),
   EMPTY_HOWTO (16),
   EMPTY_HOWTO (17),
@@ -389,6 +403,7 @@
 
   {BFD_RELOC_M68HC11_RL_JUMP, R_M68HC11_RL_JUMP},
   {BFD_RELOC_M68HC11_RL_GROUP, R_M68HC11_RL_GROUP},
+  {BFD_RELOC_M68HC11_HI8_16, R_M68HC11_HI8_16},
 };
 
 static reloc_howto_type *
diff -u -r -N binutils-2.18/bfd/elf32-m68hc1x.c binutils-2.18-s12x/bfd/elf32-m68hc1x.c
--- binutils-2.18/bfd/elf32-m68hc1x.c	2007-08-06 20:59:27.000000000 +0100
+++ binutils-2.18-s12x/bfd/elf32-m68hc1x.c	2009-10-09 14:15:13.000000000 +0100
@@ -1010,6 +1010,18 @@
       phys_page = m68hc11_phys_page (pinfo, relocation + rel->r_addend);
       switch (r_type)
         {
+        case R_M68HC11_HI8_16:
+          relocation = phys_addr;
+          break;
+        case R_M68HC11_HI8:
+          relocation = phys_addr;
+          break;
+        case R_M68HC11_LO8:
+          /* Reloc generated by %hi(expr) %lo(expr) assembler
+             or XGATE instructions like ld  */
+          relocation = phys_addr;
+          break;
+
         case R_M68HC11_24:
           /* Reloc used by 68HC12 call instruction.  */
           bfd_put_16 (input_bfd, phys_addr,
@@ -1104,11 +1116,16 @@
             relocation = phys_addr;
           break;
         }
-      if (r_type != R_M68HC11_NONE)
+      if (r_type != R_M68HC11_NONE) {
         r = _bfd_final_link_relocate (howto, input_bfd, input_section,
                                       contents, rel->r_offset,
                                       relocation, rel->r_addend);
-
+      }
+      if (r_type == R_M68HC11_HI8_16) {
+        /* now drop a NOP to obscure our 16 bit data */
+        *(unsigned char*)(contents + rel->r_offset +1) = 1; // } NOP
+        *(unsigned char*)(contents + rel->r_offset +2) = 0; // }
+      }
       if (r != bfd_reloc_ok)
 	{
 	  const char * msg = (const char *) 0;
diff -u -r -N binutils-2.18/bfd/elf32-m9s12xg.c binutils-2.18-s12x/bfd/elf32-m9s12xg.c
--- binutils-2.18/bfd/elf32-m9s12xg.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.18-s12x/bfd/elf32-m9s12xg.c	2009-10-08 18:18:50.000000000 +0100
@@ -0,0 +1,2597 @@
+/* Motorola 68HCS12XGATE-specific support for 32-bit ELF
+   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
+   Free Software Foundation, Inc.
+
+James Murray 2008.
+Status: search and replace hc11 -> hcs12xgate
+
+
+   Contributed by Stephane Carrez (stcarrez@nerim.fr)
+   (Heavily copied from the D10V port by Martin Hunt (hunt@cygnus.com))
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "bfdlink.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf32-m9s12xg.h"
+#include "elf/m9s12xg.h"
+#include "opcode/m9s12xg.h"
+#include "elf/reloc-macros.h"
+
+// this seems bogus
+#define m9s12xg_stub_hash_lookup(table, string, create, copy) \
+  ((struct elf32_m9s12xg_stub_hash_entry *) \
+   bfd_hash_lookup ((table), (string), (create), (copy)))
+
+static struct bfd_hash_entry *stub_hash_newfunc
+  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
+
+struct m9s12xg_scan_param
+{
+   struct m9s12xg_page_info* pinfo;
+   bfd_boolean use_memory_banks;
+};
+
+static struct elf32_m9s12xg_stub_hash_entry* m9s12xg_add_stub
+  (const char *stub_name,
+   asection *section,
+   struct m9s12xg_elf_link_hash_table *htab);
+
+static bfd_boolean m9s12xg_elf_export_one_stub
+  (struct bfd_hash_entry *gen_entry, void *in_arg);
+
+static void scan_sections_for_abi (bfd*, asection*, PTR);
+
+static void m9s12xg_elf_set_symbol (bfd* abfd, struct bfd_link_info *info,
+                                    const char* name, bfd_vma value,
+                                    asection* sec);
+
+/* Relocation functions.  */
+static reloc_howto_type *bfd_elf32_bfd_reloc_type_lookup
+  (bfd *, bfd_reloc_code_real_type);
+static void m9s12xg_info_to_howto_rel
+  (bfd *, arelent *, Elf_Internal_Rela *);
+
+/* Trampoline generation.  */
+static bfd_boolean m9s12xg_elf_size_one_stub
+  (struct bfd_hash_entry *gen_entry, void *in_arg);
+static bfd_boolean m9s12xg_elf_build_one_stub
+  (struct bfd_hash_entry *gen_entry, void *in_arg);
+static struct bfd_link_hash_table* m9s12xg_elf_bfd_link_hash_table_create
+  (bfd* abfd);
+
+/* Linker relaxation.  */
+static bfd_boolean m9s12xg_elf_relax_section
+  (bfd *, asection *, struct bfd_link_info *, bfd_boolean *);
+static void m9s12xg_elf_relax_delete_bytes
+  (bfd *, asection *, bfd_vma, int);
+static void m9s12xg_relax_group
+  (bfd *, asection *, bfd_byte *, unsigned, unsigned long, unsigned long);
+static int compare_reloc (const void *, const void *);
+
+/* Use REL instead of RELA to save space */
+#define USE_REL	1
+
+/* The xgate core addresses 64Kb and does not use banking.
+   Lots of old code remains in this file from hc12 that ought to
+   be deleted.
+   We must handle 8 and 16-bit relocations.  The 32-bit relocation
+   are used for debugging sections (DWARF2) to represent a virtual
+   address.
+   The 3-bit and 16-bit PC rel relocation is only used by 68HC12.  */
+static reloc_howto_type elf_m9s12xg_howto_table[] = {
+  /* This reloc does nothing.  */
+  HOWTO (R_M68HC11_NONE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_M68HC11_NONE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 8 bit absolute relocation */
+  HOWTO (R_M68HC11_8,		/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_M68HC11_8",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0x00ff,		/* src_mask */
+	 0x00ff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 8 bit absolute relocation (upper address) */
+  HOWTO (R_M68HC11_HI8,		/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_M68HC11_HI8",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 8 bit absolute relocation (lower address) */
+  HOWTO (R_M68HC11_LO8,		/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_M68HC11_LO8",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x00ff,		/* src_mask */
+	 0x00ff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 8 bit PC-rel relocation */
+  HOWTO (R_M68HC11_PCREL_8,	/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_M68HC11_PCREL_8",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x00ff,		/* src_mask */
+	 0x00ff,		/* dst_mask */
+	 TRUE),                 /* pcrel_offset */
+
+  /* A 16 bit absolute relocation */
+  HOWTO (R_M68HC11_16,		/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont /*bitfield */ ,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_M68HC11_16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 32 bit absolute relocation.  This one is never used for the
+     code relocation.  It's used by gas for -gstabs generation.  */
+  HOWTO (R_M68HC11_32,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_M68HC11_32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 3 bit absolute relocation */
+  HOWTO (R_M68HC11_3B,		/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 3,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_M68HC11_4B",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x007,			/* src_mask */
+	 0x007,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 16 bit PC-rel relocation */
+  HOWTO (R_M68HC11_PCREL_16,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_M68HC11_PCREL_16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 TRUE),                 /* pcrel_offset */
+
+  /* GNU extension to record C++ vtable hierarchy */
+  HOWTO (R_M68HC11_GNU_VTINHERIT,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 NULL,			/* special_function */
+	 "R_M68HC11_GNU_VTINHERIT",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* GNU extension to record C++ vtable member usage */
+  HOWTO (R_M68HC11_GNU_VTENTRY,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 _bfd_elf_rel_vtable_reloc_fn,	/* special_function */
+	 "R_M68HC11_GNU_VTENTRY",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 24 bit relocation */
+  HOWTO (R_M68HC11_24,	        /* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 24,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_M68HC11_24",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffff,		/* src_mask */
+	 0xffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 16-bit low relocation */
+  HOWTO (R_M68HC11_LO16,        /* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_M68HC11_LO16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A page relocation */
+  HOWTO (R_M68HC11_PAGE,        /* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_M68HC11_PAGE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x00ff,		/* src_mask */
+	 0x00ff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 8 bit absolute relocation (upper address) */
+  HOWTO (R_M68HC11_HI8_16,		/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_M68HC11_HI8_16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  EMPTY_HOWTO (15),
+  EMPTY_HOWTO (16),
+  EMPTY_HOWTO (17),
+  EMPTY_HOWTO (18),
+  EMPTY_HOWTO (19),
+
+  /* Mark beginning of a jump instruction (any form).  */
+  HOWTO (R_M68HC11_RL_JUMP,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 m9s12xg_elf_ignore_reloc,	/* special_function */
+	 "R_M68HC11_RL_JUMP",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 TRUE),                 /* pcrel_offset */
+
+  /* Mark beginning of Gcc relaxation group instruction.  */
+  HOWTO (R_M68HC11_RL_GROUP,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 m9s12xg_elf_ignore_reloc,	/* special_function */
+	 "R_M68HC11_RL_GROUP",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 TRUE),                 /* pcrel_offset */
+};
+
+/* Map BFD reloc types to m9s12xg ELF reloc types.  */
+
+
+struct m9s12xg_reloc_map
+{
+  bfd_reloc_code_real_type bfd_reloc_val;
+  unsigned char elf_reloc_val;
+};
+
+static const struct m9s12xg_reloc_map m9s12xg_reloc_map[] = {
+  {BFD_RELOC_NONE, R_M68HC11_NONE,},
+  {BFD_RELOC_8, R_M68HC11_8},
+  {BFD_RELOC_M68HC11_HI8, R_M68HC11_HI8},
+  {BFD_RELOC_M68HC11_LO8, R_M68HC11_LO8},
+  {BFD_RELOC_8_PCREL, R_M68HC11_PCREL_8},
+  {BFD_RELOC_16_PCREL, R_M68HC11_PCREL_16},
+  {BFD_RELOC_16, R_M68HC11_16},
+  {BFD_RELOC_32, R_M68HC11_32},
+  {BFD_RELOC_M68HC11_3B, R_M68HC11_3B},
+
+  {BFD_RELOC_VTABLE_INHERIT, R_M68HC11_GNU_VTINHERIT},
+  {BFD_RELOC_VTABLE_ENTRY, R_M68HC11_GNU_VTENTRY},
+
+  {BFD_RELOC_M68HC11_LO16, R_M68HC11_LO16},
+  {BFD_RELOC_M68HC11_PAGE, R_M68HC11_PAGE},
+  {BFD_RELOC_M68HC11_24, R_M68HC11_24},
+
+  {BFD_RELOC_M68HC11_RL_JUMP, R_M68HC11_RL_JUMP},
+  {BFD_RELOC_M68HC11_RL_GROUP, R_M68HC11_RL_GROUP},
+  {BFD_RELOC_M68HC11_HI8_16, R_M68HC11_HI8_16}
+};
+
+static reloc_howto_type *
+bfd_elf32_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+                                 bfd_reloc_code_real_type code)
+{
+  unsigned int i;
+
+  for (i = 0;
+       i < sizeof (m9s12xg_reloc_map) / sizeof (struct m9s12xg_reloc_map);
+       i++)
+    {
+      if (m9s12xg_reloc_map[i].bfd_reloc_val == code)
+	return &elf_m9s12xg_howto_table[m9s12xg_reloc_map[i].elf_reloc_val];
+    }
+
+  return NULL;
+}
+
+static reloc_howto_type *
+bfd_elf32_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+				 const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0;
+       i < (sizeof (elf_m9s12xg_howto_table)
+	    / sizeof (elf_m9s12xg_howto_table[0]));
+       i++)
+    if (elf_m9s12xg_howto_table[i].name != NULL
+	&& strcasecmp (elf_m9s12xg_howto_table[i].name, r_name) == 0)
+      return &elf_m9s12xg_howto_table[i];
+
+  return NULL;
+}
+
+/* Set the howto pointer for an m9s12xg ELF reloc.  */
+
+static void
+m9s12xg_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
+                           arelent *cache_ptr, Elf_Internal_Rela *dst)
+{
+  unsigned int r_type;
+
+  r_type = ELF32_R_TYPE (dst->r_info);
+  BFD_ASSERT (r_type < (unsigned int) R_M68HC11_max);
+  cache_ptr->howto = &elf_m9s12xg_howto_table[r_type];
+}
+
+
+/* Far trampoline generation.  */
+
+/* Build a 68HCS12XGATE trampoline stub.  */
+static bfd_boolean
+m9s12xg_elf_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
+{
+  struct elf32_m9s12xg_stub_hash_entry *stub_entry;
+  struct bfd_link_info *info;
+  struct m9s12xg_elf_link_hash_table *htab;
+  asection *stub_sec;
+  bfd *stub_bfd;
+  bfd_byte *loc;
+  bfd_vma sym_value, phys_page, phys_addr;
+
+  /* Massage our args to the form they really have.  */
+  stub_entry = (struct elf32_m9s12xg_stub_hash_entry *) gen_entry;
+  info = (struct bfd_link_info *) in_arg;
+
+  htab = m9s12xg_elf_hash_table (info);
+
+  stub_sec = stub_entry->stub_sec;
+
+  /* Make a note of the offset within the stubs for this entry.  */
+  stub_entry->stub_offset = stub_sec->size;
+  stub_sec->size += 10;
+  loc = stub_sec->contents + stub_entry->stub_offset;
+
+  stub_bfd = stub_sec->owner;
+
+  /* Create the trampoline call stub:
+
+     pshb
+     ldab #%page(symbol)
+     ldy #%addr(symbol)
+     jmp __trampoline
+
+  */
+  sym_value = (stub_entry->target_value
+               + stub_entry->target_section->output_offset
+               + stub_entry->target_section->output_section->vma);
+  phys_addr = m9s12xg_phys_addr (&htab->pinfo, sym_value);
+  phys_page = m9s12xg_phys_page (&htab->pinfo, sym_value);
+
+  /* pshb; ldab #%page(sym) */
+  bfd_put_8 (stub_bfd, 0x37, loc);
+  bfd_put_8 (stub_bfd, 0xC6, loc + 1);
+  bfd_put_8 (stub_bfd, phys_page, loc + 2);
+  loc += 3;
+
+  /* ldy #%addr(sym)  */
+  bfd_put_8 (stub_bfd, 0x18, loc);
+  bfd_put_8 (stub_bfd, 0xCE, loc + 1);
+  bfd_put_16 (stub_bfd, phys_addr, loc + 2);
+  loc += 4;
+
+  /* jmp __trampoline  */
+  bfd_put_8 (stub_bfd, 0x7E, loc);
+  bfd_put_16 (stub_bfd, htab->pinfo.trampoline_addr, loc + 1);
+
+  return TRUE;
+}
+
+/* As above, but don't actually build the stub.  Just bump offset so
+   we know stub section sizes.  */
+
+static bfd_boolean
+m9s12xg_elf_size_one_stub (struct bfd_hash_entry *gen_entry,
+                           void *in_arg ATTRIBUTE_UNUSED)
+{
+  struct elf32_m9s12xg_stub_hash_entry *stub_entry;
+
+  /* Massage our args to the form they really have.  */
+  stub_entry = (struct elf32_m9s12xg_stub_hash_entry *) gen_entry;
+
+  stub_entry->stub_sec->size += 10;
+  return TRUE;
+}
+
+/* Create a 68HCS12XGATE ELF linker hash table.  */
+
+static struct bfd_link_hash_table *
+m9s12xg_elf_bfd_link_hash_table_create (bfd *abfd)
+{
+  struct m9s12xg_elf_link_hash_table *ret;
+
+  ret = m9s12xg_elf_hash_table_create (abfd);
+  if (ret == (struct m9s12xg_elf_link_hash_table *) NULL)
+    return NULL;
+
+  ret->size_one_stub = m9s12xg_elf_size_one_stub;
+  ret->build_one_stub = m9s12xg_elf_build_one_stub;
+
+  return &ret->root.root;
+}
+
+
+/* 68HCS12XGATE Linker Relaxation.  */
+/* this probably doesn't make any sense at all with XGATE, but don't even know what it means ! */
+struct m9s12xg_direct_relax
+{
+  const char *name;
+  unsigned char code;
+  unsigned char direct_code;
+} m9s12xg_direct_relax_table[] = {
+  { "adca", 0xB9, 0x99 },
+  { "adcb", 0xF9, 0xD9 },
+  { "adda", 0xBB, 0x9B },
+  { "addb", 0xFB, 0xDB },
+  { "addd", 0xF3, 0xD3 },
+  { "anda", 0xB4, 0x94 },
+  { "andb", 0xF4, 0xD4 },
+  { "cmpa", 0xB1, 0x91 },
+  { "cmpb", 0xF1, 0xD1 },
+  { "cpd",  0xB3, 0x93 },
+  { "cpxy", 0xBC, 0x9C },
+/* { "cpy",  0xBC, 0x9C }, */
+  { "eora", 0xB8, 0x98 },
+  { "eorb", 0xF8, 0xD8 },
+  { "jsr",  0xBD, 0x9D },
+  { "ldaa", 0xB6, 0x96 },
+  { "ldab", 0xF6, 0xD6 },
+  { "ldd",  0xFC, 0xDC },
+  { "lds",  0xBE, 0x9E },
+  { "ldxy", 0xFE, 0xDE },
+  /*  { "ldy",  0xFE, 0xDE },*/
+  { "oraa", 0xBA, 0x9A },
+  { "orab", 0xFA, 0xDA },
+  { "sbca", 0xB2, 0x92 },
+  { "sbcb", 0xF2, 0xD2 },
+  { "staa", 0xB7, 0x97 },
+  { "stab", 0xF7, 0xD7 },
+  { "std",  0xFD, 0xDD },
+  { "sts",  0xBF, 0x9F },
+  { "stxy", 0xFF, 0xDF },
+  /*  { "sty",  0xFF, 0xDF },*/
+  { "suba", 0xB0, 0x90 },
+  { "subb", 0xF0, 0xD0 },
+  { "subd", 0xB3, 0x93 },
+  { 0, 0, 0 }
+};
+
+static struct m9s12xg_direct_relax *
+find_relaxable_insn (unsigned char code)
+{
+  int i;
+
+  for (i = 0; m9s12xg_direct_relax_table[i].name; i++)
+    if (m9s12xg_direct_relax_table[i].code == code)
+      return &m9s12xg_direct_relax_table[i];
+
+  return 0;
+}
+
+static int
+compare_reloc (const void *e1, const void *e2)
+{
+  const Elf_Internal_Rela *i1 = (const Elf_Internal_Rela *) e1;
+  const Elf_Internal_Rela *i2 = (const Elf_Internal_Rela *) e2;
+
+  if (i1->r_offset == i2->r_offset)
+    return 0;
+  else
+    return i1->r_offset < i2->r_offset ? -1 : 1;
+}
+
+#define M6811_OP_LDX_IMMEDIATE (0xCE)
+
+static void
+m9s12xg_relax_group (bfd *abfd, asection *sec, bfd_byte *contents,
+                     unsigned value, unsigned long offset,
+                     unsigned long end_group)
+{
+  unsigned char code;
+  unsigned long start_offset;
+  unsigned long ldx_offset = offset;
+  unsigned long ldx_size;
+  int can_delete_ldx;
+  int relax_ldy = 0;
+
+  /* First instruction of the relax group must be a
+     LDX #value or LDY #value.  If this is not the case,
+     ignore the relax group.  */
+  code = bfd_get_8 (abfd, contents + offset);
+  if (code == 0x18)
+    {
+      relax_ldy++;
+      offset++;
+      code = bfd_get_8 (abfd, contents + offset);
+    }
+  ldx_size = offset - ldx_offset + 3;
+  offset += 3;
+  if (code != M6811_OP_LDX_IMMEDIATE || offset >= end_group)
+    return;
+
+
+  /* We can remove the LDX/LDY only when all bset/brclr instructions
+     of the relax group have been converted to use direct addressing
+     mode.  */
+  can_delete_ldx = 1;
+  while (offset < end_group)
+    {
+      unsigned isize;
+      unsigned new_value;
+      int bset_use_y;
+
+      bset_use_y = 0;
+      start_offset = offset;
+      code = bfd_get_8 (abfd, contents + offset);
+      if (code == 0x18)
+        {
+          bset_use_y++;
+          offset++;
+          code = bfd_get_8 (abfd, contents + offset);
+        }
+
+      /* Check the instruction and translate to use direct addressing mode.  */
+      switch (code)
+        {
+          /* bset */
+        case 0x1C:
+          code = 0x14;
+          isize = 3;
+          break;
+
+          /* brclr */
+        case 0x1F:
+          code = 0x13;
+          isize = 4;
+          break;
+
+          /* brset */
+        case 0x1E:
+          code = 0x12;
+          isize = 4;
+          break;
+
+          /* bclr */
+        case 0x1D:
+          code = 0x15;
+          isize = 3;
+          break;
+
+          /* This instruction is not recognized and we are not
+             at end of the relax group.  Ignore and don't remove
+             the first LDX (we don't know what it is used for...).  */
+        default:
+          return;
+        }
+      new_value = (unsigned) bfd_get_8 (abfd, contents + offset + 1);
+      new_value += value;
+      if ((new_value & 0xff00) == 0 && bset_use_y == relax_ldy)
+        {
+          bfd_put_8 (abfd, code, contents + offset);
+          bfd_put_8 (abfd, new_value, contents + offset + 1);
+          if (start_offset != offset)
+            {
+              m9s12xg_elf_relax_delete_bytes (abfd, sec, start_offset,
+                                              offset - start_offset);
+              end_group--;
+            }
+        }
+      else
+        {
+          can_delete_ldx = 0;
+        }
+      offset = start_offset + isize;
+    }
+  if (can_delete_ldx)
+    {
+      /* Remove the move instruction (3 or 4 bytes win).  */
+      m9s12xg_elf_relax_delete_bytes (abfd, sec, ldx_offset, ldx_size);
+    }
+}
+
+/* This function handles relaxing for the 68HCS12XGATE.
+   Not reviewed for XGATE at all, may need removing totally
+
+	and somewhat more difficult to support.  */
+
+static bfd_boolean
+m9s12xg_elf_relax_section (bfd *abfd, asection *sec,
+                           struct bfd_link_info *link_info, bfd_boolean *again)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf_Internal_Shdr *shndx_hdr;
+  Elf_Internal_Rela *internal_relocs;
+  Elf_Internal_Rela *free_relocs = NULL;
+  Elf_Internal_Rela *irel, *irelend;
+  bfd_byte *contents = NULL;
+  bfd_byte *free_contents = NULL;
+  Elf32_External_Sym *free_extsyms = NULL;
+  Elf_Internal_Rela *prev_insn_branch = NULL;
+  Elf_Internal_Rela *prev_insn_group = NULL;
+  unsigned insn_group_value = 0;
+  Elf_Internal_Sym *isymbuf = NULL;
+
+  /* Assume nothing changes.  */
+  *again = FALSE;
+
+  /* We don't have to do anything for a relocatable link, if
+     this section does not have relocs, or if this is not a
+     code section.  */
+  if (link_info->relocatable
+      || (sec->flags & SEC_RELOC) == 0
+      || sec->reloc_count == 0
+      || (sec->flags & SEC_CODE) == 0)
+    return TRUE;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
+
+  /* Get a copy of the native relocations.  */
+  internal_relocs = (_bfd_elf_link_read_relocs
+		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
+		      link_info->keep_memory));
+  if (internal_relocs == NULL)
+    goto error_return;
+  if (! link_info->keep_memory)
+    free_relocs = internal_relocs;
+
+  /* Checking for branch relaxation relies on the relocations to
+     be sorted on 'r_offset'.  This is not guaranteed so we must sort.  */
+  qsort (internal_relocs, sec->reloc_count, sizeof (Elf_Internal_Rela),
+         compare_reloc);
+
+  /* Walk through them looking for relaxing opportunities.  */
+  irelend = internal_relocs + sec->reloc_count;
+  for (irel = internal_relocs; irel < irelend; irel++)
+    {
+      bfd_vma symval;
+      bfd_vma value;
+      Elf_Internal_Sym *isym;
+      asection *sym_sec;
+      int is_far = 0;
+
+      /* If this isn't something that can be relaxed, then ignore
+	 this reloc.  */
+      if (ELF32_R_TYPE (irel->r_info) != (int) R_M68HC11_16
+          && ELF32_R_TYPE (irel->r_info) != (int) R_M68HC11_RL_JUMP
+          && ELF32_R_TYPE (irel->r_info) != (int) R_M68HC11_RL_GROUP)
+        {
+          prev_insn_branch = 0;
+          prev_insn_group = 0;
+          continue;
+        }
+
+      /* Get the section contents if we haven't done so already.  */
+      if (contents == NULL)
+	{
+	  /* Get cached copy if it exists.  */
+	  if (elf_section_data (sec)->this_hdr.contents != NULL)
+	    contents = elf_section_data (sec)->this_hdr.contents;
+	  else
+	    {
+	      /* Go get them off disk.  */
+	      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
+		goto error_return;
+	    }
+	}
+
+      /* Try to eliminate an unconditional 8 bit pc-relative branch
+	 which immediately follows a conditional 8 bit pc-relative
+	 branch around the unconditional branch.
+
+	    original:		new:
+	    bCC lab1		bCC' lab2
+	    bra lab2
+	   lab1:	       lab1:
+
+	 This happens when the bCC can't reach lab2 at assembly time,
+	 but due to other relaxations it can reach at link time.  */
+      if (ELF32_R_TYPE (irel->r_info) == (int) R_M68HC11_RL_JUMP)
+	{
+	  Elf_Internal_Rela *nrel;
+	  unsigned char code;
+          unsigned char roffset;
+
+          prev_insn_branch = 0;
+          prev_insn_group = 0;
+
+	  /* Do nothing if this reloc is the last byte in the section.  */
+	  if (irel->r_offset + 2 >= sec->size)
+	    continue;
+
+	  /* See if the next instruction is an unconditional pc-relative
+	     branch, more often than not this test will fail, so we
+	     test it first to speed things up.  */
+	  code = bfd_get_8 (abfd, contents + irel->r_offset + 2);
+	  if (code != 0x7e)
+	    continue;
+
+	  /* Also make sure the next relocation applies to the next
+	     instruction and that it's a pc-relative 8 bit branch.  */
+	  nrel = irel + 1;
+	  if (nrel == irelend
+	      || irel->r_offset + 3 != nrel->r_offset
+	      || ELF32_R_TYPE (nrel->r_info) != (int) R_M68HC11_16)
+	    continue;
+
+	  /* Make sure our destination immediately follows the
+	     unconditional branch.  */
+          roffset = bfd_get_8 (abfd, contents + irel->r_offset + 1);
+          if (roffset != 3)
+            continue;
+
+          prev_insn_branch = irel;
+          prev_insn_group = 0;
+          continue;
+        }
+
+      /* Read this BFD's symbols if we haven't done so already.  */
+      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
+	{
+	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
+	  if (isymbuf == NULL)
+	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
+					    symtab_hdr->sh_info, 0,
+					    NULL, NULL, NULL);
+	  if (isymbuf == NULL)
+	    goto error_return;
+	}
+
+      /* Get the value of the symbol referred to by the reloc.  */
+      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
+	{
+	  /* A local symbol.  */
+	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
+          is_far = isym->st_other & STO_M68HC12_FAR;
+          sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
+	  symval = (isym->st_value
+		    + sym_sec->output_section->vma
+		    + sym_sec->output_offset);
+	}
+      else
+	{
+	  unsigned long indx;
+	  struct elf_link_hash_entry *h;
+
+	  /* An external symbol.  */
+	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
+	  h = elf_sym_hashes (abfd)[indx];
+	  BFD_ASSERT (h != NULL);
+	  if (h->root.type != bfd_link_hash_defined
+	      && h->root.type != bfd_link_hash_defweak)
+	    {
+	      /* This appears to be a reference to an undefined
+                 symbol.  Just ignore it--it will be caught by the
+                 regular reloc processing.  */
+              prev_insn_branch = 0;
+              prev_insn_group = 0;
+	      continue;
+	    }
+
+          is_far = h->other & STO_M68HC12_FAR;
+          isym = 0;
+          sym_sec = h->root.u.def.section;
+	  symval = (h->root.u.def.value
+		    + sym_sec->output_section->vma
+		    + sym_sec->output_offset);
+	}
+
+      if (ELF32_R_TYPE (irel->r_info) == (int) R_M68HC11_RL_GROUP)
+	{
+          prev_insn_branch = 0;
+          prev_insn_group = 0;
+
+	  /* Do nothing if this reloc is the last byte in the section.  */
+	  if (irel->r_offset == sec->size)
+	    continue;
+
+          prev_insn_group = irel;
+          insn_group_value = isym->st_value;
+          continue;
+        }
+
+      /* When we relax some bytes, the size of our section changes.
+         This affects the layout of next input sections that go in our
+         output section.  When the symbol is part of another section that
+         will go in the same output section as the current one, it's
+         final address may now be incorrect (too far).  We must let the
+         linker re-compute all section offsets before processing this
+         reloc.  Code example:
+
+                                Initial             Final
+         .sect .text            section size = 6    section size = 4
+         jmp foo
+         jmp bar
+         .sect .text.foo_bar    output_offset = 6   output_offset = 4
+         foo: rts
+         bar: rts
+
+         If we process the reloc now, the jmp bar is replaced by a
+         relative branch to the initial bar address (output_offset 6).  */
+      if (*again && sym_sec != sec
+          && sym_sec->output_section == sec->output_section)
+        {
+          prev_insn_group = 0;
+          prev_insn_branch = 0;
+          continue;
+        }
+
+      value = symval;
+      /* Try to turn a far branch to a near branch.  */
+      if (ELF32_R_TYPE (irel->r_info) == (int) R_M68HC11_16
+          && prev_insn_branch)
+        {
+          bfd_vma offset;
+          unsigned char code;
+
+          offset = value - (prev_insn_branch->r_offset
+                            + sec->output_section->vma
+                            + sec->output_offset + 2);
+
+          /* If the offset is still out of -128..+127 range,
+             leave that far branch unchanged.  */
+          if ((offset & 0xff80) != 0 && (offset & 0xff80) != 0xff80)
+            {
+              prev_insn_branch = 0;
+              continue;
+            }
+
+          /* Shrink the branch.  */
+          code = bfd_get_8 (abfd, contents + prev_insn_branch->r_offset);
+          if (code == 0x7e)
+            {
+              code = 0x20;
+              bfd_put_8 (abfd, code, contents + prev_insn_branch->r_offset);
+              bfd_put_8 (abfd, 0xff,
+                         contents + prev_insn_branch->r_offset + 1);
+              irel->r_offset = prev_insn_branch->r_offset + 1;
+              irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
+                                           R_M68XG_PCREL_9);
+              m9s12xg_elf_relax_delete_bytes (abfd, sec,
+                                              irel->r_offset + 1, 1);
+            }
+          else
+            {
+              code ^= 0x1;
+              bfd_put_8 (abfd, code, contents + prev_insn_branch->r_offset);
+              bfd_put_8 (abfd, 0xff,
+                         contents + prev_insn_branch->r_offset + 1);
+              irel->r_offset = prev_insn_branch->r_offset + 1;
+              irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
+                                           R_M68XG_PCREL_9);
+              m9s12xg_elf_relax_delete_bytes (abfd, sec,
+                                              irel->r_offset + 1, 3);
+            }
+          prev_insn_branch = 0;
+          *again = TRUE;
+        }
+
+      /* Try to turn a 16 bit address into a 8 bit page0 address.  */
+      else if (ELF32_R_TYPE (irel->r_info) == (int) R_M68HC11_16
+               && (value & 0xff00) == 0)
+	{
+          unsigned char code;
+          unsigned short offset;
+          struct m9s12xg_direct_relax *rinfo;
+
+          prev_insn_branch = 0;
+          offset = bfd_get_16 (abfd, contents + irel->r_offset);
+          offset += value;
+          if ((offset & 0xff00) != 0)
+            {
+              prev_insn_group = 0;
+              continue;
+            }
+
+          if (prev_insn_group)
+            {
+              unsigned long old_sec_size = sec->size;
+
+              /* Note that we've changed the relocation contents, etc.  */
+              elf_section_data (sec)->relocs = internal_relocs;
+              free_relocs = NULL;
+
+              elf_section_data (sec)->this_hdr.contents = contents;
+              free_contents = NULL;
+
+              symtab_hdr->contents = (bfd_byte *) isymbuf;
+              free_extsyms = NULL;
+
+              m9s12xg_relax_group (abfd, sec, contents, offset,
+                                   prev_insn_group->r_offset,
+                                   insn_group_value);
+              irel = prev_insn_group;
+              prev_insn_group = 0;
+              irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
+                                           R_M68HC11_NONE);
+              if (sec->size != old_sec_size)
+                *again = TRUE;
+              continue;
+            }
+
+          /* Get the opcode.  */
+          code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
+          rinfo = find_relaxable_insn (code);
+          if (rinfo == 0)
+            {
+              prev_insn_group = 0;
+              continue;
+            }
+
+          /* Note that we've changed the relocation contents, etc.  */
+          elf_section_data (sec)->relocs = internal_relocs;
+          free_relocs = NULL;
+
+          elf_section_data (sec)->this_hdr.contents = contents;
+          free_contents = NULL;
+
+          symtab_hdr->contents = (bfd_byte *) isymbuf;
+          free_extsyms = NULL;
+
+          /* Fix the opcode.  */
+          /* printf ("A relaxable case : 0x%02x (%s)\n",
+             code, rinfo->name); */
+          bfd_put_8 (abfd, rinfo->direct_code,
+                     contents + irel->r_offset - 1);
+
+          /* Delete one byte of data (upper byte of address).  */
+          m9s12xg_elf_relax_delete_bytes (abfd, sec, irel->r_offset, 1);
+
+          /* Fix the relocation's type.  */
+          irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
+                                       R_M68HC11_8);
+
+          /* That will change things, so, we should relax again.  */
+          *again = TRUE;
+        }
+      else if (ELF32_R_TYPE (irel->r_info) == R_M68HC11_16 && !is_far)
+        {
+          unsigned char code;
+          bfd_vma offset;
+
+          prev_insn_branch = 0;
+          code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
+          if (code == 0x7e || code == 0xbd)
+            {
+              offset = value - (irel->r_offset
+                                + sec->output_section->vma
+                                + sec->output_offset + 1);
+              offset += bfd_get_16 (abfd, contents + irel->r_offset);
+
+              /* If the offset is still out of -128..+127 range,
+                 leave that far branch unchanged.  */
+              if ((offset & 0xff80) == 0 || (offset & 0xff80) == 0xff80)
+                {
+
+                  /* Note that we've changed the relocation contents, etc.  */
+                  elf_section_data (sec)->relocs = internal_relocs;
+                  free_relocs = NULL;
+
+                  elf_section_data (sec)->this_hdr.contents = contents;
+                  free_contents = NULL;
+
+                  symtab_hdr->contents = (bfd_byte *) isymbuf;
+                  free_extsyms = NULL;
+
+                  /* Shrink the branch.  */
+                  code = (code == 0x7e) ? 0x20 : 0x8d;
+                  bfd_put_8 (abfd, code,
+                             contents + irel->r_offset - 1);
+                  bfd_put_8 (abfd, 0xff,
+                             contents + irel->r_offset);
+                  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
+                                               R_M68XG_PCREL_9);
+                  m9s12xg_elf_relax_delete_bytes (abfd, sec,
+                                                  irel->r_offset + 1, 1);
+                  /* That will change things, so, we should relax again.  */
+                  *again = TRUE;
+                }
+            }
+        }
+      prev_insn_branch = 0;
+      prev_insn_group = 0;
+    }
+
+  if (free_relocs != NULL)
+    {
+      free (free_relocs);
+      free_relocs = NULL;
+    }
+
+  if (free_contents != NULL)
+    {
+      if (! link_info->keep_memory)
+	free (free_contents);
+      else
+	{
+	  /* Cache the section contents for elf_link_input_bfd.  */
+	  elf_section_data (sec)->this_hdr.contents = contents;
+	}
+      free_contents = NULL;
+    }
+
+  if (free_extsyms != NULL)
+    {
+      if (! link_info->keep_memory)
+	free (free_extsyms);
+      else
+	{
+	  /* Cache the symbols for elf_link_input_bfd.  */
+	  symtab_hdr->contents = (unsigned char *) isymbuf;
+	}
+      free_extsyms = NULL;
+    }
+
+  return TRUE;
+
+ error_return:
+  if (free_relocs != NULL)
+    free (free_relocs);
+  if (free_contents != NULL)
+    free (free_contents);
+  if (free_extsyms != NULL)
+    free (free_extsyms);
+  return FALSE;
+}
+
+/* Delete some bytes from a section while relaxing.  */
+
+static void
+m9s12xg_elf_relax_delete_bytes (bfd *abfd, asection *sec,
+                                bfd_vma addr, int count)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  unsigned int sec_shndx;
+  bfd_byte *contents;
+  Elf_Internal_Rela *irel, *irelend;
+  bfd_vma toaddr;
+  Elf_Internal_Sym *isymbuf, *isym, *isymend;
+  struct elf_link_hash_entry **sym_hashes;
+  struct elf_link_hash_entry **end_hashes;
+  unsigned int symcount;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
+
+  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);
+
+  contents = elf_section_data (sec)->this_hdr.contents;
+
+  toaddr = sec->size;
+
+  irel = elf_section_data (sec)->relocs;
+  irelend = irel + sec->reloc_count;
+
+  /* Actually delete the bytes.  */
+  memmove (contents + addr, contents + addr + count,
+	   (size_t) (toaddr - addr - count));
+
+  sec->size -= count;
+
+  /* Adjust all the relocs.  */
+  for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)
+    {
+      unsigned char code;
+      unsigned char offset;
+      unsigned short raddr;
+      unsigned long old_offset;
+      int branch_pos;
+
+      old_offset = irel->r_offset;
+
+      /* See if this reloc was for the bytes we have deleted, in which
+	 case we no longer care about it.  Don't delete relocs which
+	 represent addresses, though.  */
+      if (ELF32_R_TYPE (irel->r_info) != R_M68HC11_RL_JUMP
+          && irel->r_offset >= addr && irel->r_offset < addr + count)
+        irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
+                                     R_M68HC11_NONE);
+
+      if (ELF32_R_TYPE (irel->r_info) == R_M68HC11_NONE)
+        continue;
+
+      /* Get the new reloc address.  */
+      if ((irel->r_offset > addr
+	   && irel->r_offset < toaddr))
+	irel->r_offset -= count;
+
+      /* If this is a PC relative reloc, see if the range it covers
+         includes the bytes we have deleted.  */
+      switch (ELF32_R_TYPE (irel->r_info))
+	{
+	default:
+	  break;
+
+	case R_M68HC11_RL_JUMP:
+          code = bfd_get_8 (abfd, contents + irel->r_offset);
+          switch (code)
+            {
+              /* jsr and jmp instruction are also marked with RL_JUMP
+                 relocs but no adjustment must be made.  */
+            case 0x7e:
+            case 0x9d:
+            case 0xbd:
+              continue;
+
+            case 0x12:
+            case 0x13:
+              branch_pos = 3;
+              raddr = 4;
+
+              /* Special case when we translate a brclr N,y into brclr *<addr>
+                 In this case, the 0x18 page2 prefix is removed.
+                 The reloc offset is not modified but the instruction
+                 size is reduced by 1.  */
+              if (old_offset == addr)
+                raddr++;
+              break;
+
+            case 0x1e:
+            case 0x1f:
+              branch_pos = 3;
+              raddr = 4;
+              break;
+
+            case 0x18:
+              branch_pos = 4;
+              raddr = 5;
+              break;
+
+            default:
+              branch_pos = 1;
+              raddr = 2;
+              break;
+            }
+          offset = bfd_get_8 (abfd, contents + irel->r_offset + branch_pos);
+          raddr += old_offset;
+          raddr += ((unsigned short) offset | ((offset & 0x80) ? 0xff00 : 0));
+          if (irel->r_offset < addr && raddr > addr)
+            {
+              offset -= count;
+              bfd_put_8 (abfd, offset, contents + irel->r_offset + branch_pos);
+            }
+          else if (irel->r_offset >= addr && raddr <= addr)
+            {
+              offset += count;
+              bfd_put_8 (abfd, offset, contents + irel->r_offset + branch_pos);
+            }
+          else
+            {
+              /*printf ("Not adjusted 0x%04x [0x%4x 0x%4x]\n", raddr,
+                irel->r_offset, addr);*/
+            }
+
+          break;
+	}
+    }
+
+  /* Adjust the local symbols defined in this section.  */
+  isymend = isymbuf + symtab_hdr->sh_info;
+  for (isym = isymbuf; isym < isymend; isym++)
+    {
+      if (isym->st_shndx == sec_shndx
+	  && isym->st_value > addr
+	  && isym->st_value <= toaddr)
+	isym->st_value -= count;
+    }
+
+  /* Now adjust the global symbols defined in this section.  */
+  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
+	      - symtab_hdr->sh_info);
+  sym_hashes = elf_sym_hashes (abfd);
+  end_hashes = sym_hashes + symcount;
+  for (; sym_hashes < end_hashes; sym_hashes++)
+    {
+      struct elf_link_hash_entry *sym_hash = *sym_hashes;
+      if ((sym_hash->root.type == bfd_link_hash_defined
+	   || sym_hash->root.type == bfd_link_hash_defweak)
+	  && sym_hash->root.u.def.section == sec
+	  && sym_hash->root.u.def.value > addr
+	  && sym_hash->root.u.def.value <= toaddr)
+	{
+	  sym_hash->root.u.def.value -= count;
+	}
+    }
+}
+
+/* Specific sections:
+   - The .page0 is a data section that is mapped in [0x0000..0x00FF].
+     Page0 accesses are faster on the M68HC11. Soft registers used by GCC-m6811
+     are located in .page0.
+   - The .vectors is the section that represents the interrupt
+     vectors.  */
+static const struct bfd_elf_special_section elf32_m9s12xg_special_sections[] =
+{
+  { STRING_COMMA_LEN (".eeprom"),   0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
+  { STRING_COMMA_LEN (".page0"),    0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
+  { STRING_COMMA_LEN (".softregs"), 0, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
+  { STRING_COMMA_LEN (".vectors"),  0, SHT_PROGBITS, SHF_ALLOC },
+  { NULL,                       0,  0, 0,            0 }
+};
+
+/* sections of code taken from elf32-m68hc1x.c */
+/* Return the physical address seen by the processor, taking
+   into account banked memory.  */
+bfd_vma
+m9s12xg_phys_addr (struct m9s12xg_page_info *pinfo, bfd_vma addr)
+{
+  if (addr < pinfo->bank_virtual)
+    return addr;
+
+  /* Map the address to the memory bank.  */
+  addr -= pinfo->bank_virtual;
+  addr &= pinfo->bank_mask;
+  addr += pinfo->bank_physical;
+  return addr;
+}
+
+/* Return the page number corresponding to an address in banked memory.  */
+bfd_vma
+m9s12xg_phys_page (struct m9s12xg_page_info *pinfo, bfd_vma addr)
+{
+  if (addr < pinfo->bank_virtual)
+    return 0;
+
+  /* Map the address to the memory bank.  */
+  addr -= pinfo->bank_virtual;
+  addr >>= pinfo->bank_shift;
+  addr &= 0x0ff;
+  return addr;
+}
+
+/* Hook called by the linker routine which adds symbols from an object
+   file.  We use it for identify far symbols and force a loading of
+   the trampoline handler.  */
+
+bfd_boolean
+elf32_m9s12xg_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
+                               Elf_Internal_Sym *sym,
+                               const char **namep ATTRIBUTE_UNUSED,
+                               flagword *flagsp ATTRIBUTE_UNUSED,
+                               asection **secp ATTRIBUTE_UNUSED,
+                               bfd_vma *valp ATTRIBUTE_UNUSED)
+{
+  if (sym->st_other & STO_M68HC12_FAR)
+    {
+      struct elf_link_hash_entry *h;
+
+      h = (struct elf_link_hash_entry *)
+	bfd_link_hash_lookup (info->hash, "__far_trampoline",
+                              FALSE, FALSE, FALSE);
+      if (h == NULL)
+        {
+          struct bfd_link_hash_entry* entry = NULL;
+
+          _bfd_generic_link_add_one_symbol (info, abfd,
+                                            "__far_trampoline",
+                                            BSF_GLOBAL,
+                                            bfd_und_section_ptr,
+                                            (bfd_vma) 0, (const char*) NULL,
+                                            FALSE, FALSE, &entry);
+        }
+
+    }
+  return TRUE;
+}
+
+/* Look through the relocs for a section during the first phase.
+   Since we don't do .gots or .plts, we just need to consider the
+   virtual table relocs for gc.  */
+
+bfd_boolean
+elf32_m9s12xg_check_relocs (bfd *abfd, struct bfd_link_info *info,
+                            asection *sec, const Elf_Internal_Rela *relocs)
+{
+  Elf_Internal_Shdr *           symtab_hdr;
+  struct elf_link_hash_entry ** sym_hashes;
+  struct elf_link_hash_entry ** sym_hashes_end;
+  const Elf_Internal_Rela *     rel;
+  const Elf_Internal_Rela *     rel_end;
+
+  if (info->relocatable)
+    return TRUE;
+
+  symtab_hdr = & elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+  sym_hashes_end = sym_hashes + symtab_hdr->sh_size / sizeof (Elf32_External_Sym);
+  if (!elf_bad_symtab (abfd))
+    sym_hashes_end -= symtab_hdr->sh_info;
+
+  rel_end = relocs + sec->reloc_count;
+
+  for (rel = relocs; rel < rel_end; rel++)
+    {
+      struct elf_link_hash_entry * h;
+      unsigned long r_symndx;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+
+      if (r_symndx < symtab_hdr->sh_info)
+        h = NULL;
+      else
+	{
+	  h = sym_hashes [r_symndx - symtab_hdr->sh_info];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	}
+
+      switch (ELF32_R_TYPE (rel->r_info))
+        {
+        /* This relocation describes the C++ object vtable hierarchy.
+           Reconstruct it for later use during GC.  */
+        case R_M68HC11_GNU_VTINHERIT:
+          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
+            return FALSE;
+          break;
+
+        /* This relocation describes which C++ vtable entries are actually
+           used.  Record for later use during GC.  */
+        case R_M68HC11_GNU_VTENTRY:
+          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
+            return FALSE;
+          break;
+        }
+    }
+
+  return TRUE;
+}
+
+/* Relocate a 68hc11/68hc12 ELF section.  */
+/* I don't believe this function is actually used.. uses the one in elf32-m68hc1x.c instead */
+bfd_boolean
+elf32_m9s12xg_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
+                                struct bfd_link_info *info,
+                                bfd *input_bfd, asection *input_section,
+                                bfd_byte *contents, Elf_Internal_Rela *relocs,
+                                Elf_Internal_Sym *local_syms,
+                                asection **local_sections)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  Elf_Internal_Rela *rel, *relend;
+  const char *name = NULL;
+  struct m9s12xg_page_info *pinfo;
+  const struct elf_backend_data * const ebd = get_elf_backend_data (input_bfd);
+
+  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (input_bfd);
+
+  /* Get memory bank parameters.  */
+  m9s12xg_elf_get_bank_parameters (info);
+  pinfo = &m9s12xg_elf_hash_table (info)->pinfo;
+
+  rel = relocs;
+  relend = relocs + input_section->reloc_count;
+  for (; rel < relend; rel++)
+    {
+      int r_type;
+      arelent arel;
+      reloc_howto_type *howto;
+      unsigned long r_symndx;
+      Elf_Internal_Sym *sym;
+      asection *sec;
+      bfd_vma relocation = 0;
+      bfd_reloc_status_type r = bfd_reloc_undefined;
+      bfd_vma phys_page;
+      bfd_vma phys_addr;
+      bfd_vma insn_addr;
+      bfd_vma insn_page;
+      bfd_boolean is_far = FALSE;
+      struct elf_link_hash_entry *h;
+      const char* stub_name = 0;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      r_type = ELF32_R_TYPE (rel->r_info);
+
+      if (r_type == R_M68HC11_GNU_VTENTRY
+          || r_type == R_M68HC11_GNU_VTINHERIT )
+        continue;
+
+      (*ebd->elf_info_to_howto_rel) (input_bfd, &arel, rel);
+      howto = arel.howto;
+
+      h = NULL;
+      sym = NULL;
+      sec = NULL;
+      if (r_symndx < symtab_hdr->sh_info)
+	{
+	  sym = local_syms + r_symndx;
+	  sec = local_sections[r_symndx];
+	  relocation = (sec->output_section->vma
+			+ sec->output_offset
+			+ sym->st_value);
+	  is_far = (sym && (sym->st_other & STO_M68HC12_FAR));
+	  if (is_far)
+	    stub_name = (bfd_elf_string_from_elf_section
+			 (input_bfd, symtab_hdr->sh_link,
+			  sym->st_name));
+	}
+      else
+	{
+	  bfd_boolean unresolved_reloc, warned;
+
+	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
+				   r_symndx, symtab_hdr, sym_hashes,
+				   h, sec, relocation, unresolved_reloc,
+				   warned);
+
+	  is_far = (h && (h->other & STO_M68HC12_FAR));
+	  stub_name = h->root.root.string;
+	}
+
+      if (sec != NULL && elf_discarded_section (sec))
+	{
+	  /* For relocs against symbols from removed linkonce sections,
+	     or sections discarded by a linker script, we just want the
+	     section contents zeroed.  Avoid any special processing.  */
+	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
+	  rel->r_info = 0;
+	  rel->r_addend = 0;
+	  continue;
+	}
+
+      if (info->relocatable)
+	{
+	  /* This is a relocatable link.  We don't have to change
+	     anything, unless the reloc is against a section symbol,
+	     in which case we have to adjust according to where the
+	     section symbol winds up in the output section.  */
+	  if (sym != NULL && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
+	    rel->r_addend += sec->output_offset;
+	  continue;
+	}
+
+      if (h != NULL)
+	name = h->root.root.string;
+      else
+	{
+	  name = (bfd_elf_string_from_elf_section
+		  (input_bfd, symtab_hdr->sh_link, sym->st_name));
+	  if (name == NULL || *name == '\0')
+	    name = bfd_section_name (input_bfd, sec);
+	}
+
+      if (is_far && ELF32_R_TYPE (rel->r_info) == R_M68HC11_16)
+	{
+	  struct elf32_m9s12xg_stub_hash_entry* stub;
+	  struct m9s12xg_elf_link_hash_table *htab;
+
+	  htab = m9s12xg_elf_hash_table (info);
+	  stub = m9s12xg_stub_hash_lookup (htab->stub_hash_table,
+					   name, FALSE, FALSE);
+	  if (stub)
+	    {
+	      relocation = stub->stub_offset
+		+ stub->stub_sec->output_section->vma
+		+ stub->stub_sec->output_offset;
+	      is_far = FALSE;
+	    }
+	}
+
+      /* Do the memory bank mapping.  */
+      phys_addr = m9s12xg_phys_addr (pinfo, relocation + rel->r_addend);
+      phys_page = m9s12xg_phys_page (pinfo, relocation + rel->r_addend);
+      switch (r_type)
+        {
+        case R_M68HC11_24:
+          /* Reloc used by 68HC12 call instruction.  */
+          bfd_put_16 (input_bfd, phys_addr,
+                      (bfd_byte*) contents + rel->r_offset);
+          bfd_put_8 (input_bfd, phys_page,
+                     (bfd_byte*) contents + rel->r_offset + 2);
+          r = bfd_reloc_ok;
+          r_type = R_M68HC11_NONE;
+          break;
+
+        case R_M68HC11_NONE:
+          r = bfd_reloc_ok;
+          break;
+
+        case R_M68HC11_LO16:
+          /* Reloc generated by %addr(expr) gas to obtain the
+             address as mapped in the memory bank window.  */
+          relocation = phys_addr;
+          break;
+
+        case R_M68HC11_PAGE:
+          /* Reloc generated by %page(expr) gas to obtain the
+             page number associated with the address.  */
+          relocation = phys_page;
+          break;
+
+        case R_M68HC11_16:
+          /* Get virtual address of instruction having the relocation.  */
+          if (is_far)
+            {
+              const char* msg;
+              char* buf;
+              msg = _("Reference to the far symbol `%s' using a wrong "
+                      "relocation may result in incorrect execution");
+              buf = alloca (strlen (msg) + strlen (name) + 10);
+              sprintf (buf, msg, name);
+              
+              (* info->callbacks->warning)
+                (info, buf, name, input_bfd, NULL, rel->r_offset);
+            }
+
+          /* Get virtual address of instruction having the relocation.  */
+          insn_addr = input_section->output_section->vma
+            + input_section->output_offset
+            + rel->r_offset;
+
+          insn_page = m9s12xg_phys_page (pinfo, insn_addr);
+
+          if (m9s12xg_addr_is_banked (pinfo, relocation + rel->r_addend)
+              && m9s12xg_addr_is_banked (pinfo, insn_addr)
+              && phys_page != insn_page)
+            {
+              const char* msg;
+              char* buf;
+
+              msg = _("banked address [%lx:%04lx] (%lx) is not in the same bank "
+                      "as current banked address [%lx:%04lx] (%lx)");
+
+              buf = alloca (strlen (msg) + 128);
+              sprintf (buf, msg, phys_page, phys_addr,
+                       (long) (relocation + rel->r_addend),
+                       insn_page, m9s12xg_phys_addr (pinfo, insn_addr),
+                       (long) (insn_addr));
+              if (!((*info->callbacks->warning)
+                    (info, buf, name, input_bfd, input_section,
+                     rel->r_offset)))
+                return FALSE;
+              break;
+            }
+          if (phys_page != 0 && insn_page == 0)
+            {
+              const char* msg;
+              char* buf;
+
+              msg = _("reference to a banked address [%lx:%04lx] in the "
+                      "normal address space at %04lx");
+
+              buf = alloca (strlen (msg) + 128);
+              sprintf (buf, msg, phys_page, phys_addr, insn_addr);
+              if (!((*info->callbacks->warning)
+                    (info, buf, name, input_bfd, input_section,
+                     insn_addr)))
+                return FALSE;
+
+              relocation = phys_addr;
+              break;
+            }
+
+          /* If this is a banked address use the phys_addr so that
+             we stay in the banked window.  */
+          if (m9s12xg_addr_is_banked (pinfo, relocation + rel->r_addend))
+            relocation = phys_addr;
+          break;
+        }
+      if (r_type != R_M68HC11_NONE)
+        r = _bfd_final_link_relocate (howto, input_bfd, input_section,
+                                      contents, rel->r_offset,
+                                      relocation, rel->r_addend);
+
+      if (r != bfd_reloc_ok)
+	{
+	  const char * msg = (const char *) 0;
+
+	  switch (r)
+	    {
+	    case bfd_reloc_overflow:
+	      if (!((*info->callbacks->reloc_overflow)
+		    (info, NULL, name, howto->name, (bfd_vma) 0,
+		     input_bfd, input_section, rel->r_offset)))
+		return FALSE;
+	      break;
+
+	    case bfd_reloc_undefined:
+	      if (!((*info->callbacks->undefined_symbol)
+		    (info, name, input_bfd, input_section,
+		     rel->r_offset, TRUE)))
+		return FALSE;
+	      break;
+
+	    case bfd_reloc_outofrange:
+	      msg = _ ("internal error: out of range error");
+	      goto common_error;
+
+	    case bfd_reloc_notsupported:
+	      msg = _ ("internal error: unsupported relocation error");
+	      goto common_error;
+
+	    case bfd_reloc_dangerous:
+	      msg = _ ("internal error: dangerous error");
+	      goto common_error;
+
+	    default:
+	      msg = _ ("internal error: unknown error");
+	      /* fall through */
+
+	    common_error:
+	      if (!((*info->callbacks->warning)
+		    (info, msg, name, input_bfd, input_section,
+		     rel->r_offset)))
+		return FALSE;
+	      break;
+	    }
+	}
+    }
+
+  return TRUE;
+}
+
+/* Merge backend specific data from an object file to the output
+   object file when linking.  */
+
+bfd_boolean
+_bfd_m9s12xg_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
+{
+  flagword old_flags;
+  flagword new_flags;
+  bfd_boolean ok = TRUE;
+
+  /* Check if we have the same endianess */
+  if (!_bfd_generic_verify_endian_match (ibfd, obfd))
+    return FALSE;
+
+  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
+      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
+    return TRUE;
+
+  new_flags = elf_elfheader (ibfd)->e_flags;
+  elf_elfheader (obfd)->e_flags |= new_flags & EF_M9S12XG_ABI;
+  old_flags = elf_elfheader (obfd)->e_flags;
+
+  if (! elf_flags_init (obfd))
+    {
+      elf_flags_init (obfd) = TRUE;
+      elf_elfheader (obfd)->e_flags = new_flags;
+      elf_elfheader (obfd)->e_ident[EI_CLASS]
+	= elf_elfheader (ibfd)->e_ident[EI_CLASS];
+
+      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
+	  && bfd_get_arch_info (obfd)->the_default)
+	{
+	  if (! bfd_set_arch_mach (obfd, bfd_get_arch (ibfd),
+				   bfd_get_mach (ibfd)))
+	    return FALSE;
+	}
+
+      return TRUE;
+    }
+
+  /* Check ABI compatibility.  */
+  if ((new_flags & E_M9S12XG_I32) != (old_flags & E_M9S12XG_I32))
+    {
+      (*_bfd_error_handler)
+	(_("%B: linking files compiled for 16-bit integers (-mshort) "
+           "and others for 32-bit integers"), ibfd);
+      ok = FALSE;
+    }
+  if ((new_flags & E_M9S12XG_F64) != (old_flags & E_M9S12XG_F64))
+    {
+      (*_bfd_error_handler)
+	(_("%B: linking files compiled for 32-bit double (-fshort-double) "
+           "and others for 64-bit double"), ibfd);
+      ok = FALSE;
+    }
+
+  /* Processor compatibility.  */
+  if (!EF_M9S12XG_CAN_MERGE_MACH (new_flags, old_flags))
+    {
+      (*_bfd_error_handler)
+	(_("%B: linking files compiled for HCS12 with "
+           "others compiled for HC12"), ibfd);
+      ok = FALSE;
+    }
+  new_flags = ((new_flags & ~EF_M9S12XG_MACH_MASK)
+               | (EF_M9S12XG_MERGE_MACH (new_flags, old_flags)));
+
+  elf_elfheader (obfd)->e_flags = new_flags;
+
+  new_flags &= ~(EF_M9S12XG_ABI | EF_M9S12XG_MACH_MASK);
+  old_flags &= ~(EF_M9S12XG_ABI | EF_M9S12XG_MACH_MASK);
+
+  /* Warn about any other mismatches */
+  if (new_flags != old_flags)
+    {
+      (*_bfd_error_handler)
+	(_("%B: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"),
+	 ibfd, (unsigned long) new_flags, (unsigned long) old_flags);
+      ok = FALSE;
+    }
+
+  if (! ok)
+    {
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+bfd_boolean
+_bfd_m9s12xg_elf_print_private_bfd_data (bfd *abfd, void *ptr)
+{
+  FILE *file = (FILE *) ptr;
+
+  BFD_ASSERT (abfd != NULL && ptr != NULL);
+
+  /* Print normal ELF private data.  */
+  _bfd_elf_print_private_bfd_data (abfd, ptr);
+
+  /* xgettext:c-format */
+  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);
+
+  if (elf_elfheader (abfd)->e_flags & E_M9S12XG_I32)
+    fprintf (file, _("[abi=32-bit int, "));
+  else
+    fprintf (file, _("[abi=16-bit int, "));
+
+  if (elf_elfheader (abfd)->e_flags & E_M9S12XG_F64)
+    fprintf (file, _("64-bit double, "));
+  else
+    fprintf (file, _("32-bit double, "));
+
+  if (strcmp (bfd_get_target (abfd), "elf32-m68hc11") == 0)
+    fprintf (file, _("cpu=HC11]"));
+  else if (strcmp (bfd_get_target (abfd), "elf32-m9s12xg") == 0)
+    fprintf (file, _("cpu=M9S12XG]"));
+  else if (elf_elfheader (abfd)->e_flags & EF_M68HCS12_MACH)
+    fprintf (file, _("cpu=HCS12]"));
+  else
+    fprintf (file, _("cpu=HC12]"));    
+
+  if (elf_elfheader (abfd)->e_flags & E_M68HC12_BANKS)
+    fprintf (file, _(" [memory=bank-model]"));
+  else
+    fprintf (file, _(" [memory=flat]"));
+
+  fputc ('\n', file);
+
+  return TRUE;
+}
+
+/* Set and control ELF flags in ELF header.  */
+
+bfd_boolean
+_bfd_m9s12xg_elf_set_private_flags (bfd *abfd, flagword flags)
+{
+  BFD_ASSERT (!elf_flags_init (abfd)
+	      || elf_elfheader (abfd)->e_flags == flags);
+
+  elf_elfheader (abfd)->e_flags = flags;
+  elf_flags_init (abfd) = TRUE;
+  return TRUE;
+}
+
+/* This function is used for relocs which are only used for relaxing,
+   which the linker should otherwise ignore.  */
+
+bfd_reloc_status_type
+m9s12xg_elf_ignore_reloc (bfd *abfd ATTRIBUTE_UNUSED,
+                          arelent *reloc_entry,
+                          asymbol *symbol ATTRIBUTE_UNUSED,
+                          void *data ATTRIBUTE_UNUSED,
+                          asection *input_section,
+                          bfd *output_bfd,
+                          char **error_message ATTRIBUTE_UNUSED)
+{
+  if (output_bfd != NULL)
+    reloc_entry->address += input_section->output_offset;
+  return bfd_reloc_ok;
+}
+
+/* Return 1 if the address is in banked memory.
+   This can be applied to a virtual address and to a physical address.  */
+int
+m9s12xg_addr_is_banked (struct m9s12xg_page_info *pinfo, bfd_vma addr)
+{
+  if (addr >= pinfo->bank_virtual)
+    return 1;
+
+  if (addr >= pinfo->bank_physical && addr <= pinfo->bank_physical_end)
+    return 1;
+
+  return 0;
+}
+
+void
+m9s12xg_elf_get_bank_parameters (struct bfd_link_info *info)
+{
+  unsigned i;
+  struct m9s12xg_page_info *pinfo;
+  struct bfd_link_hash_entry *h;
+
+  pinfo = &m9s12xg_elf_hash_table (info)->pinfo;
+  if (pinfo->bank_param_initialized)
+    return;
+
+  pinfo->bank_virtual = M68HC12_BANK_VIRT;
+  pinfo->bank_mask = M68HC12_BANK_MASK;
+  pinfo->bank_physical = M68HC12_BANK_BASE;
+  pinfo->bank_shift = M68HC12_BANK_SHIFT;
+  pinfo->bank_size = 1 << M68HC12_BANK_SHIFT;
+
+  h = bfd_link_hash_lookup (info->hash, BFD_M9S12XG_BANK_START_NAME,
+                            FALSE, FALSE, TRUE);
+  if (h != (struct bfd_link_hash_entry*) NULL
+      && h->type == bfd_link_hash_defined)
+    pinfo->bank_physical = (h->u.def.value
+                            + h->u.def.section->output_section->vma
+                            + h->u.def.section->output_offset);
+
+  h = bfd_link_hash_lookup (info->hash, BFD_M9S12XG_BANK_VIRTUAL_NAME,
+                            FALSE, FALSE, TRUE);
+  if (h != (struct bfd_link_hash_entry*) NULL
+      && h->type == bfd_link_hash_defined)
+    pinfo->bank_virtual = (h->u.def.value
+                           + h->u.def.section->output_section->vma
+                           + h->u.def.section->output_offset);
+
+  h = bfd_link_hash_lookup (info->hash, BFD_M9S12XG_BANK_SIZE_NAME,
+                            FALSE, FALSE, TRUE);
+  if (h != (struct bfd_link_hash_entry*) NULL
+      && h->type == bfd_link_hash_defined)
+    pinfo->bank_size = (h->u.def.value
+                        + h->u.def.section->output_section->vma
+                        + h->u.def.section->output_offset);
+
+  pinfo->bank_shift = 0;
+  for (i = pinfo->bank_size; i != 0; i >>= 1)
+    pinfo->bank_shift++;
+  pinfo->bank_shift--;
+  pinfo->bank_mask = (1 << pinfo->bank_shift) - 1;
+  pinfo->bank_physical_end = pinfo->bank_physical + pinfo->bank_size;
+  pinfo->bank_param_initialized = 1;
+
+  h = bfd_link_hash_lookup (info->hash, "__far_trampoline", FALSE,
+                            FALSE, TRUE);
+  if (h != (struct bfd_link_hash_entry*) NULL
+      && h->type == bfd_link_hash_defined)
+    pinfo->trampoline_addr = (h->u.def.value
+                              + h->u.def.section->output_section->vma
+                              + h->u.def.section->output_offset);
+}
+
+/* Free the derived linker hash table.  */
+
+void
+m9s12xg_elf_bfd_link_hash_table_free (struct bfd_link_hash_table *hash)
+{
+  struct m9s12xg_elf_link_hash_table *ret
+    = (struct m9s12xg_elf_link_hash_table *) hash;
+
+  bfd_hash_table_free (ret->stub_hash_table);
+  free (ret->stub_hash_table);
+  _bfd_generic_link_hash_table_free (hash);
+}
+
+/* Create a 68HC11/68HC12 ELF linker hash table.  */
+
+struct m9s12xg_elf_link_hash_table*
+m9s12xg_elf_hash_table_create (bfd *abfd)
+{
+  struct m9s12xg_elf_link_hash_table *ret;
+  bfd_size_type amt = sizeof (struct m9s12xg_elf_link_hash_table);
+
+  ret = (struct m9s12xg_elf_link_hash_table *) bfd_malloc (amt);
+  if (ret == (struct m9s12xg_elf_link_hash_table *) NULL)
+    return NULL;
+
+  memset (ret, 0, amt);
+  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
+				      _bfd_elf_link_hash_newfunc,
+				      sizeof (struct elf_link_hash_entry)))
+    {
+      free (ret);
+      return NULL;
+    }
+
+  /* Init the stub hash table too.  */
+  amt = sizeof (struct bfd_hash_table);
+  ret->stub_hash_table = (struct bfd_hash_table*) bfd_malloc (amt);
+  if (ret->stub_hash_table == NULL)
+    {
+      free (ret);
+      return NULL;
+    }
+  if (!bfd_hash_table_init (ret->stub_hash_table, stub_hash_newfunc,
+			    sizeof (struct elf32_m9s12xg_stub_hash_entry)))
+    return NULL;
+
+  ret->stub_bfd = NULL;
+  ret->stub_section = 0;
+  ret->add_stub_section = NULL;
+  ret->sym_sec.abfd = NULL;
+
+  return ret;
+}
+
+/* Assorted hash table functions.  */
+
+/* Initialize an entry in the stub hash table.  */
+
+static struct bfd_hash_entry *
+stub_hash_newfunc (struct bfd_hash_entry *entry, struct bfd_hash_table *table,
+                   const char *string)
+{
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (entry == NULL)
+    {
+      entry = bfd_hash_allocate (table,
+				 sizeof (struct elf32_m9s12xg_stub_hash_entry));
+      if (entry == NULL)
+	return entry;
+    }
+
+  /* Call the allocation method of the superclass.  */
+  entry = bfd_hash_newfunc (entry, table, string);
+  if (entry != NULL)
+    {
+      struct elf32_m9s12xg_stub_hash_entry *eh;
+
+      /* Initialize the local fields.  */
+      eh = (struct elf32_m9s12xg_stub_hash_entry *) entry;
+      eh->stub_sec = NULL;
+      eh->stub_offset = 0;
+      eh->target_value = 0;
+      eh->target_section = NULL;
+    }
+
+  return entry;
+}
+
+/* Determine and set the size of the stub section for a final link.
+
+   The basic idea here is to examine all the relocations looking for
+   PC-relative calls to a target that is unreachable with a "bl"
+   instruction.  */
+
+bfd_boolean
+elf32_m9s12xg_size_stubs (bfd *output_bfd, bfd *stub_bfd,
+                          struct bfd_link_info *info,
+                          asection * (*add_stub_section) (const char*, asection*))
+{
+  bfd *input_bfd;
+  asection *section;
+  Elf_Internal_Sym *local_syms, **all_local_syms;
+  unsigned int bfd_indx, bfd_count;
+  bfd_size_type amt;
+  asection *stub_sec;
+
+  struct m9s12xg_elf_link_hash_table *htab = m9s12xg_elf_hash_table (info);
+
+  /* Stash our params away.  */
+  htab->stub_bfd = stub_bfd;
+  htab->add_stub_section = add_stub_section;
+
+  /* Count the number of input BFDs and find the top input section id.  */
+  for (input_bfd = info->input_bfds, bfd_count = 0;
+       input_bfd != NULL;
+       input_bfd = input_bfd->link_next)
+    {
+      bfd_count += 1;
+    }
+
+  /* We want to read in symbol extension records only once.  To do this
+     we need to read in the local symbols in parallel and save them for
+     later use; so hold pointers to the local symbols in an array.  */
+  amt = sizeof (Elf_Internal_Sym *) * bfd_count;
+  all_local_syms = (Elf_Internal_Sym **) bfd_zmalloc (amt);
+  if (all_local_syms == NULL)
+    return FALSE;
+
+  /* Walk over all the input BFDs, swapping in local symbols.  */
+  for (input_bfd = info->input_bfds, bfd_indx = 0;
+       input_bfd != NULL;
+       input_bfd = input_bfd->link_next, bfd_indx++)
+    {
+      Elf_Internal_Shdr *symtab_hdr;
+
+      /* We'll need the symbol table in a second.  */
+      symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+      if (symtab_hdr->sh_info == 0)
+	continue;
+
+      /* We need an array of the local symbols attached to the input bfd.  */
+      local_syms = (Elf_Internal_Sym *) symtab_hdr->contents;
+      if (local_syms == NULL)
+	{
+	  local_syms = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
+					     symtab_hdr->sh_info, 0,
+					     NULL, NULL, NULL);
+	  /* Cache them for elf_link_input_bfd.  */
+	  symtab_hdr->contents = (unsigned char *) local_syms;
+	}
+      if (local_syms == NULL)
+        {
+          free (all_local_syms);
+	  return FALSE;
+        }
+
+      all_local_syms[bfd_indx] = local_syms;
+    }
+
+  for (input_bfd = info->input_bfds, bfd_indx = 0;
+       input_bfd != NULL;
+       input_bfd = input_bfd->link_next, bfd_indx++)
+    {
+      Elf_Internal_Shdr *symtab_hdr;
+      Elf_Internal_Sym *local_syms;
+      struct elf_link_hash_entry ** sym_hashes;
+
+      sym_hashes = elf_sym_hashes (input_bfd);
+
+      /* We'll need the symbol table in a second.  */
+      symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+      if (symtab_hdr->sh_info == 0)
+        continue;
+
+      local_syms = all_local_syms[bfd_indx];
+
+      /* Walk over each section attached to the input bfd.  */
+      for (section = input_bfd->sections;
+           section != NULL;
+           section = section->next)
+        {
+          Elf_Internal_Rela *internal_relocs, *irelaend, *irela;
+
+          /* If there aren't any relocs, then there's nothing more
+             to do.  */
+          if ((section->flags & SEC_RELOC) == 0
+              || section->reloc_count == 0)
+            continue;
+
+          /* If this section is a link-once section that will be
+             discarded, then don't create any stubs.  */
+          if (section->output_section == NULL
+              || section->output_section->owner != output_bfd)
+            continue;
+
+          /* Get the relocs.  */
+          internal_relocs
+            = _bfd_elf_link_read_relocs (input_bfd, section, NULL,
+					 (Elf_Internal_Rela *) NULL,
+					 info->keep_memory);
+          if (internal_relocs == NULL)
+            goto error_ret_free_local;
+
+          /* Now examine each relocation.  */
+          irela = internal_relocs;
+          irelaend = irela + section->reloc_count;
+          for (; irela < irelaend; irela++)
+            {
+              unsigned int r_type, r_indx;
+              struct elf32_m9s12xg_stub_hash_entry *stub_entry;
+              asection *sym_sec;
+              bfd_vma sym_value;
+              struct elf_link_hash_entry *hash;
+              const char *stub_name;
+              Elf_Internal_Sym *sym;
+
+              r_type = ELF32_R_TYPE (irela->r_info);
+
+//              /* Only look at 16-bit relocs.  */
+//              if (r_type != (unsigned int) R_M68HC11_16)
+//                continue;
+
+              /* Now determine the call target, its name, value,
+                 section.  */
+              r_indx = ELF32_R_SYM (irela->r_info);
+              if (r_indx < symtab_hdr->sh_info)
+                {
+                  /* It's a local symbol.  */
+                  Elf_Internal_Shdr *hdr;
+                  bfd_boolean is_far;
+
+                  sym = local_syms + r_indx;
+                  is_far = (sym && (sym->st_other & STO_M68HC12_FAR));
+                  if (!is_far)
+                    continue;
+
+                  hdr = elf_elfsections (input_bfd)[sym->st_shndx];
+                  sym_sec = hdr->bfd_section;
+                  stub_name = (bfd_elf_string_from_elf_section
+                               (input_bfd, symtab_hdr->sh_link,
+                                sym->st_name));
+                  sym_value = sym->st_value;
+                  hash = NULL;
+                }
+              else
+                {
+                  /* It's an external symbol.  */
+                  int e_indx;
+
+                  e_indx = r_indx - symtab_hdr->sh_info;
+                  hash = (struct elf_link_hash_entry *)
+                    (sym_hashes[e_indx]);
+
+                  while (hash->root.type == bfd_link_hash_indirect
+                         || hash->root.type == bfd_link_hash_warning)
+                    hash = ((struct elf_link_hash_entry *)
+                            hash->root.u.i.link);
+
+                  if (hash->root.type == bfd_link_hash_defined
+                      || hash->root.type == bfd_link_hash_defweak
+                      || hash->root.type == bfd_link_hash_new)
+                    {
+                      if (!(hash->other & STO_M68HC12_FAR))
+                        continue;
+                    }
+                  else if (hash->root.type == bfd_link_hash_undefweak)
+                    {
+                      continue;
+                    }
+                  else if (hash->root.type == bfd_link_hash_undefined)
+                    {
+                      continue;
+                    }
+                  else
+                    {
+                      bfd_set_error (bfd_error_bad_value);
+                      goto error_ret_free_internal;
+                    }
+                  sym_sec = hash->root.u.def.section;
+                  sym_value = hash->root.u.def.value;
+                  stub_name = hash->root.root.string;
+                }
+
+              if (!stub_name)
+                goto error_ret_free_internal;
+
+              stub_entry = m9s12xg_stub_hash_lookup
+                (htab->stub_hash_table,
+                 stub_name,
+                 FALSE, FALSE);
+              if (stub_entry == NULL)
+                {
+                  if (add_stub_section == 0)
+                    continue;
+
+                  stub_entry = m9s12xg_add_stub (stub_name, section, htab);
+                  if (stub_entry == NULL)
+                    {
+                    error_ret_free_internal:
+                      if (elf_section_data (section)->relocs == NULL)
+                        free (internal_relocs);
+                      goto error_ret_free_local;
+                    }
+                }
+
+              stub_entry->target_value = sym_value;
+              stub_entry->target_section = sym_sec;
+            }
+
+          /* We're done with the internal relocs, free them.  */
+          if (elf_section_data (section)->relocs == NULL)
+            free (internal_relocs);
+        }
+    }
+
+  if (add_stub_section)
+    {
+      /* OK, we've added some stubs.  Find out the new size of the
+         stub sections.  */
+      for (stub_sec = htab->stub_bfd->sections;
+           stub_sec != NULL;
+           stub_sec = stub_sec->next)
+        {
+          stub_sec->size = 0;
+        }
+
+      bfd_hash_traverse (htab->stub_hash_table, htab->size_one_stub, htab);
+    }
+  free (all_local_syms);
+  return TRUE;
+
+ error_ret_free_local:
+  free (all_local_syms);
+  return FALSE;
+}
+
+/* Build all the stubs associated with the current output file.  The
+   stubs are kept in a hash table attached to the main linker hash
+   table.  This function is called via m68hc12elf_finish in the
+   linker.  */
+
+bfd_boolean
+elf32_m9s12xg_build_stubs (bfd *abfd, struct bfd_link_info *info)
+{
+  asection *stub_sec;
+  struct bfd_hash_table *table;
+  struct m9s12xg_elf_link_hash_table *htab;
+  struct m9s12xg_scan_param param;
+
+  m9s12xg_elf_get_bank_parameters (info);
+  htab = m9s12xg_elf_hash_table (info);
+
+  for (stub_sec = htab->stub_bfd->sections;
+       stub_sec != NULL;
+       stub_sec = stub_sec->next)
+    {
+      bfd_size_type size;
+
+      /* Allocate memory to hold the linker stubs.  */
+      size = stub_sec->size;
+      stub_sec->contents = (unsigned char *) bfd_zalloc (htab->stub_bfd, size);
+      if (stub_sec->contents == NULL && size != 0)
+	return FALSE;
+      stub_sec->size = 0;
+    }
+
+  /* Build the stubs as directed by the stub hash table.  */
+  table = htab->stub_hash_table;
+  bfd_hash_traverse (table, m9s12xg_elf_export_one_stub, info);
+  
+  /* Scan the output sections to see if we use the memory banks.
+     If so, export the symbols that define how the memory banks
+     are mapped.  This is used by gdb and the simulator to obtain
+     the information.  It can be used by programs to burn the eprom
+     at the good addresses.  */
+  param.use_memory_banks = FALSE;
+  param.pinfo = &htab->pinfo;
+  bfd_map_over_sections (abfd, scan_sections_for_abi, &param);
+  if (param.use_memory_banks)
+    {
+      m9s12xg_elf_set_symbol (abfd, info, BFD_M9S12XG_BANK_START_NAME,
+                              htab->pinfo.bank_physical,
+                              bfd_abs_section_ptr);
+      m9s12xg_elf_set_symbol (abfd, info, BFD_M9S12XG_BANK_VIRTUAL_NAME,
+                              htab->pinfo.bank_virtual,
+                              bfd_abs_section_ptr);
+      m9s12xg_elf_set_symbol (abfd, info, BFD_M9S12XG_BANK_SIZE_NAME,
+                              htab->pinfo.bank_size,
+                              bfd_abs_section_ptr);
+    }
+
+  return TRUE;
+}
+
+/* External entry points for sizing and building linker stubs.  */
+
+/* Set up various things so that we can make a list of input sections
+   for each output section included in the link.  Returns -1 on error,
+   0 when no stubs will be needed, and 1 on success.  */
+
+int
+elf32_m9s12xg_setup_section_lists (bfd *output_bfd, struct bfd_link_info *info)
+{
+  bfd *input_bfd;
+  unsigned int bfd_count;
+  int top_id, top_index;
+  asection *section;
+  asection **input_list, **list;
+  bfd_size_type amt;
+  asection *text_section;
+  struct m9s12xg_elf_link_hash_table *htab;
+
+  htab = m9s12xg_elf_hash_table (info);
+
+  if (htab->root.root.creator->flavour != bfd_target_elf_flavour)
+    return 0;
+
+  /* Count the number of input BFDs and find the top input section id.
+     Also search for an existing ".tramp" section so that we know
+     where generated trampolines must go.  Default to ".text" if we
+     can't find it.  */
+  htab->tramp_section = 0;
+  text_section = 0;
+  for (input_bfd = info->input_bfds, bfd_count = 0, top_id = 0;
+       input_bfd != NULL;
+       input_bfd = input_bfd->link_next)
+    {
+      bfd_count += 1;
+      for (section = input_bfd->sections;
+	   section != NULL;
+	   section = section->next)
+	{
+          const char* name = bfd_get_section_name (input_bfd, section);
+
+          if (!strcmp (name, ".tramp"))
+            htab->tramp_section = section;
+
+          if (!strcmp (name, ".text"))
+            text_section = section;
+
+	  if (top_id < section->id)
+	    top_id = section->id;
+	}
+    }
+  htab->bfd_count = bfd_count;
+  if (htab->tramp_section == 0)
+    htab->tramp_section = text_section;
+
+  /* We can't use output_bfd->section_count here to find the top output
+     section index as some sections may have been removed, and
+     strip_excluded_output_sections doesn't renumber the indices.  */
+  for (section = output_bfd->sections, top_index = 0;
+       section != NULL;
+       section = section->next)
+    {
+      if (top_index < section->index)
+	top_index = section->index;
+    }
+
+  htab->top_index = top_index;
+  amt = sizeof (asection *) * (top_index + 1);
+  input_list = (asection **) bfd_malloc (amt);
+  htab->input_list = input_list;
+  if (input_list == NULL)
+    return -1;
+
+  /* For sections we aren't interested in, mark their entries with a
+     value we can check later.  */
+  list = input_list + top_index;
+  do
+    *list = bfd_abs_section_ptr;
+  while (list-- != input_list);
+
+  for (section = output_bfd->sections;
+       section != NULL;
+       section = section->next)
+    {
+      if ((section->flags & SEC_CODE) != 0)
+	input_list[section->index] = NULL;
+    }
+
+  return 1;
+}
+
+/* Export the trampoline addresses in the symbol table.  */
+static bfd_boolean
+m9s12xg_elf_export_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
+{
+  struct bfd_link_info *info;
+  struct m9s12xg_elf_link_hash_table *htab;
+  struct elf32_m9s12xg_stub_hash_entry *stub_entry;
+  char* name;
+  bfd_boolean result;
+
+  info = (struct bfd_link_info *) in_arg;
+  htab = m9s12xg_elf_hash_table (info);
+
+  /* Massage our args to the form they really have.  */
+  stub_entry = (struct elf32_m9s12xg_stub_hash_entry *) gen_entry;
+
+  /* Generate the trampoline according to HC11 or HC12.  */
+  result = (* htab->build_one_stub) (gen_entry, in_arg);
+
+  /* Make a printable name that does not conflict with the real function.  */
+  name = alloca (strlen (stub_entry->root.string) + 16);
+  sprintf (name, "tramp.%s", stub_entry->root.string);
+
+  /* Export the symbol for debugging/disassembling.  */
+  m9s12xg_elf_set_symbol (htab->stub_bfd, info, name,
+                          stub_entry->stub_offset,
+                          stub_entry->stub_sec);
+  return result;
+}
+
+static void scan_sections_for_abi (bfd *abfd ATTRIBUTE_UNUSED,
+                                   asection *asect, void *arg)
+{
+  struct m9s12xg_scan_param* p = (struct m9s12xg_scan_param*) arg;
+
+  if (asect->vma >= p->pinfo->bank_virtual)
+    p->use_memory_banks = TRUE;
+}
+
+/* Export a symbol or set its value and section.  */
+static void
+m9s12xg_elf_set_symbol (bfd *abfd, struct bfd_link_info *info,
+                        const char *name, bfd_vma value, asection *sec)
+{
+  struct elf_link_hash_entry *h;
+
+  h = (struct elf_link_hash_entry *)
+    bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, FALSE);
+  if (h == NULL)
+    {
+      _bfd_generic_link_add_one_symbol (info, abfd,
+                                        name,
+                                        BSF_GLOBAL,
+                                        sec,
+                                        value,
+                                        (const char*) NULL,
+                                        TRUE, FALSE, NULL);
+    }
+  else
+    {
+      h->root.type = bfd_link_hash_defined;
+      h->root.u.def.value = value;
+      h->root.u.def.section = sec;
+    }
+}
+
+/* Add a new stub entry to the stub hash.  Not all fields of the new
+   stub entry are initialised.  */
+
+static struct elf32_m9s12xg_stub_hash_entry *
+m9s12xg_add_stub (const char *stub_name, asection *section,
+                  struct m9s12xg_elf_link_hash_table *htab)
+{
+  struct elf32_m9s12xg_stub_hash_entry *stub_entry;
+
+  /* Enter this entry into the linker stub hash table.  */
+  stub_entry = m9s12xg_stub_hash_lookup (htab->stub_hash_table, stub_name,
+                                         TRUE, FALSE);
+  if (stub_entry == NULL)
+    {
+      (*_bfd_error_handler) (_("%B: cannot create stub entry %s"),
+			     section->owner, stub_name);
+      return NULL;
+    }
+
+  if (htab->stub_section == 0)
+    {
+      htab->stub_section = (*htab->add_stub_section) (".tramp",
+                                                      htab->tramp_section);
+    }
+
+  stub_entry->stub_sec = htab->stub_section;
+  stub_entry->stub_offset = 0;
+  return stub_entry;
+}
+
+
+/* end sections of code taken from elf32-m68hc1x.c */
+
+#define ELF_ARCH		bfd_arch_m9s12xg
+#define ELF_MACHINE_CODE	EM_M9S12XG
+#define ELF_MAXPAGESIZE		0x1000
+
+#define TARGET_BIG_SYM          bfd_elf32_m9s12xg_vec
+#define TARGET_BIG_NAME		"elf32-m9s12xg"
+
+#define elf_info_to_howto	0
+#define elf_info_to_howto_rel	m9s12xg_info_to_howto_rel
+#define bfd_elf32_bfd_relax_section  m9s12xg_elf_relax_section
+#define elf_backend_check_relocs     elf32_m9s12xg_check_relocs
+#define elf_backend_relocate_section elf32_m9s12xg_relocate_section
+#define elf_backend_add_symbol_hook  elf32_m9s12xg_add_symbol_hook
+#define elf_backend_object_p	0
+#define elf_backend_final_write_processing	0
+#define elf_backend_can_gc_sections		1
+#define elf_backend_special_sections  elf32_m9s12xg_special_sections
+
+#define bfd_elf32_bfd_link_hash_table_create \
+                                m9s12xg_elf_bfd_link_hash_table_create
+#define bfd_elf32_bfd_link_hash_table_free \
+				m9s12xg_elf_bfd_link_hash_table_free
+#define bfd_elf32_bfd_merge_private_bfd_data \
+					_bfd_m9s12xg_elf_merge_private_bfd_data
+#define bfd_elf32_bfd_set_private_flags	_bfd_m9s12xg_elf_set_private_flags
+#define bfd_elf32_bfd_print_private_bfd_data \
+					_bfd_m9s12xg_elf_print_private_bfd_data
+
+#include "elf32-target.h"
diff -u -r -N binutils-2.18/bfd/elf32-m9s12xg.h binutils-2.18-s12x/bfd/elf32-m9s12xg.h
--- binutils-2.18/bfd/elf32-m9s12xg.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.18-s12x/bfd/elf32-m9s12xg.h	2008-03-20 19:57:49.000000000 +0000
@@ -0,0 +1,188 @@
+/* Motorola 68HCS12XGATE/68HC12-specific support for 32-bit ELF
+   Copyright 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
+   Contributed by Stephane Carrez (stcarrez@nerim.fr)
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#ifndef _ELF32_M9S12XG_H
+#define _ELF32_M9S12XG_H
+
+#include "elf-bfd.h"
+#include "bfdlink.h"
+#include "elf/m9s12xg.h"
+
+/* Name of symbols exported by HCS12XGATE/HC12 linker when there is a memory
+   bank window.  */
+#define BFD_M9S12XG_BANK_START_NAME   "__bank_start"
+#define BFD_M9S12XG_BANK_SIZE_NAME    "__bank_size"
+#define BFD_M9S12XG_BANK_VIRTUAL_NAME "__bank_virtual"
+
+/* Set and control ELF flags in ELF header.  */
+extern bfd_boolean _bfd_m9s12xg_elf_merge_private_bfd_data (bfd*,bfd*);
+extern bfd_boolean _bfd_m9s12xg_elf_set_private_flags (bfd*,flagword);
+extern bfd_boolean _bfd_m9s12xg_elf_print_private_bfd_data (bfd*, void*);
+
+/* This hash entry is used to record a trampoline that must be generated
+   to call a far function using a normal calling convention ('jsr').
+   The trampoline is used when a pointer to a far function is used.
+   It takes care of installing the proper memory bank as well as creating
+   the 'call/rtc' calling convention.  */
+struct elf32_m9s12xg_stub_hash_entry {
+
+  /* Base hash table entry structure.  */
+  struct bfd_hash_entry root;
+
+  /* The stub section.  */
+  asection *stub_sec;
+
+  /* Offset within stub_sec of the beginning of this stub.  */
+  bfd_vma stub_offset;
+
+  /* Given the symbol's value and its section we can determine its final
+     value when building the stubs (so the stub knows where to jump.  */
+  bfd_vma target_value;
+  asection *target_section;
+};
+
+/* Placeholder for the parameters to compute memory page and physical address.
+   The following formulas are used:
+
+   sym > bank_virtual =>
+     %addr(sym) = (((sym - bank_virtual) & bank_mask) + bank_physical
+     %page(sym) = (((sym - bank_virtual) >> bank_shift) % 256
+
+   sym < bank_virtual =>
+     %addr(sym) = sym
+     %page(sym) = 0
+
+
+   These parameters are obtained from the symbol table by looking
+   at the following:
+
+   __bank_start         Symbol marking the start of memory bank window
+                        (bank_physical)
+   __bank_virtual       Logical address of symbols for which the transformation
+                        must be computed
+   __bank_page_size     Size in bytes of page size (this is *NOT* the memory
+                        bank window size and the window size is always
+                        less or equal to the page size)
+
+   For 68HCS12, the window is at 0x8000 and the page size is 16K (full window).
+
+*/
+struct m9s12xg_page_info
+{
+  bfd_vma bank_virtual;
+  bfd_vma bank_physical;
+  bfd_vma bank_physical_end;
+  bfd_vma bank_mask;
+  bfd_vma bank_size;
+  int bank_shift;
+  int bank_param_initialized;
+  bfd_vma trampoline_addr;
+};
+
+struct m9s12xg_elf_link_hash_table
+{
+  struct elf_link_hash_table root;
+  struct m9s12xg_page_info pinfo;
+
+  /* The stub hash table.  */
+  struct bfd_hash_table* stub_hash_table;
+
+  /* Linker stub bfd.  */
+  bfd *stub_bfd;
+
+  asection* stub_section;
+  asection* tramp_section;
+
+  /* Linker call-backs.  */
+  asection * (*add_stub_section) PARAMS ((const char *, asection *));
+
+  /* Assorted information used by elf32_hppa_size_stubs.  */
+  unsigned int bfd_count;
+  int top_index;
+  asection **input_list;
+
+  /* Small local sym to section mapping cache.  */
+  struct sym_sec_cache sym_sec;
+
+  bfd_boolean (* size_one_stub) PARAMS((struct bfd_hash_entry*, void*));
+  bfd_boolean (* build_one_stub) PARAMS((struct bfd_hash_entry*, void*));
+};
+
+/* Get the Sparc64 ELF linker hash table from a link_info structure.  */
+
+#define m9s12xg_elf_hash_table(p) \
+  ((struct m9s12xg_elf_link_hash_table *) ((p)->hash))
+
+/* Create a 68HCS12XGATE ELF linker hash table.  */
+
+extern struct m9s12xg_elf_link_hash_table* m9s12xg_elf_hash_table_create
+  (bfd*);
+extern void m9s12xg_elf_bfd_link_hash_table_free (struct bfd_link_hash_table*);
+
+extern void m9s12xg_elf_get_bank_parameters (struct bfd_link_info*);
+
+/* Return 1 if the address is in banked memory.
+   This can be applied to a virtual address and to a physical address.  */
+extern int m9s12xg_addr_is_banked (struct m9s12xg_page_info*, bfd_vma);
+
+/* Return the physical address seen by the processor, taking
+   into account banked memory.  */
+extern bfd_vma m9s12xg_phys_addr (struct m9s12xg_page_info*, bfd_vma);
+
+/* Return the page number corresponding to an address in banked memory.  */
+extern bfd_vma m9s12xg_phys_page (struct m9s12xg_page_info*, bfd_vma);
+
+bfd_reloc_status_type m9s12xg_elf_ignore_reloc
+  (bfd *abfd, arelent *reloc_entry,
+   asymbol *symbol, void *data, asection *input_section,
+   bfd *output_bfd, char **error_message);
+bfd_reloc_status_type m9s12xg_elf_special_reloc
+  (bfd *abfd, arelent *reloc_entry,
+    asymbol *symbol, void *data, asection *input_section,
+    bfd *output_bfd, char **error_message);
+
+bfd_boolean elf32_m9s12xg_check_relocs
+  (bfd * abfd, struct bfd_link_info * info,
+   asection * sec, const Elf_Internal_Rela * relocs);
+bfd_boolean elf32_m9s12xg_relocate_section
+  (bfd *output_bfd, struct bfd_link_info *info,
+   bfd *input_bfd, asection *input_section,
+   bfd_byte *contents, Elf_Internal_Rela *relocs,
+   Elf_Internal_Sym *local_syms, asection **local_sections);
+
+bfd_boolean elf32_m9s12xg_add_symbol_hook
+  (bfd *abfd, struct bfd_link_info *info,
+   Elf_Internal_Sym *sym, const char **namep,
+   flagword *flagsp, asection **secp,
+   bfd_vma *valp);
+
+/* Tweak the OSABI field of the elf header.  */
+
+extern void elf32_m9s12xg_post_process_headers (bfd*, struct bfd_link_info*);
+
+int elf32_m9s12xg_setup_section_lists (bfd *, struct bfd_link_info *);
+
+bfd_boolean elf32_m9s12xg_size_stubs
+  (bfd *, bfd *, struct bfd_link_info *,
+   asection * (*) (const char *, asection *));
+
+bfd_boolean elf32_m9s12xg_build_stubs (bfd* abfd, struct bfd_link_info *);
+#endif
diff -u -r -N binutils-2.18/bfd/libbfd.h binutils-2.18-s12x/bfd/libbfd.h
--- binutils-2.18/bfd/libbfd.h	2007-08-06 20:59:37.000000000 +0100
+++ binutils-2.18-s12x/bfd/libbfd.h	2008-02-26 22:14:32.000000000 +0000
@@ -800,6 +800,8 @@
   "BFD_RELOC_24_PCREL",
   "BFD_RELOC_16_PCREL",
   "BFD_RELOC_12_PCREL",
+  "BFD_RELOC_10_PCREL",
+  "BFD_RELOC_9_PCREL",
   "BFD_RELOC_8_PCREL",
   "BFD_RELOC_32_SECREL",
   "BFD_RELOC_32_GOT_PCREL",
diff -u -r -N binutils-2.18/bfd/Makefile.in binutils-2.18-s12x/bfd/Makefile.in
--- binutils-2.18/bfd/Makefile.in	2007-08-28 21:20:12.000000000 +0100
+++ binutils-2.18-s12x/bfd/Makefile.in	2008-03-20 19:55:49.000000000 +0000
@@ -336,6 +336,8 @@
 	cpu-m32r.lo \
 	cpu-m68hc11.lo \
 	cpu-m68hc12.lo \
+	cpu-m9s12x.lo \
+	cpu-m9s12xg.lo \
 	cpu-m68k.lo \
 	cpu-m88k.lo \
 	cpu-m10200.lo \
@@ -402,6 +404,8 @@
 	cpu-m32r.c \
 	cpu-m68hc11.c \
 	cpu-m68hc12.c \
+	cpu-m9s12x.c \
+	cpu-m9s12xg.c \
 	cpu-m68k.c \
 	cpu-m88k.c \
 	cpu-m10200.c \
@@ -517,6 +521,7 @@
 	elf32-m68hc11.lo \
 	elf32-m68hc12.lo \
 	elf32-m68hc1x.lo \
+	elf32-m9s12xg.lo \
 	elf32-m68k.lo \
 	elf32-m88k.lo \
 	elf-m10200.lo \
@@ -697,6 +702,7 @@
 	elf32-m68hc11.c \
 	elf32-m68hc12.c \
 	elf32-m68hc1x.c \
+	elf32-m9s12xg.c \
 	elf32-m88k.c \
 	elf-m10200.c \
 	elf-m10300.c \
@@ -1666,6 +1672,10 @@
   $(INCDIR)/hashtab.h
 cpu-m68hc12.lo: cpu-m68hc12.c $(INCDIR)/filenames.h \
   $(INCDIR)/hashtab.h
+cpu-m9s12x.lo: cpu-m9s12x.c $(INCDIR)/filenames.h \
+  $(INCDIR)/hashtab.h
+cpu-m9s12xg.lo: cpu-m9s12xg.c $(INCDIR)/filenames.h \
+  $(INCDIR)/hashtab.h
 cpu-m68k.lo: cpu-m68k.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   $(INCDIR)/opcode/m68k.h
 cpu-m88k.lo: cpu-m88k.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
@@ -2007,6 +2017,11 @@
   $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h elf32-m68hc1x.h \
   $(INCDIR)/elf/m68hc11.h $(INCDIR)/elf/reloc-macros.h \
   $(INCDIR)/opcode/m68hc11.h
+elf32-m9s12xg.lo: elf32-m9s12xg.c $(INCDIR)/filenames.h \
+  $(INCDIR)/bfdlink.h $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
+  $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h elf32-m9s12xg.h \
+  $(INCDIR)/elf/m9s12xg.h $(INCDIR)/elf/reloc-macros.h \
+  $(INCDIR)/opcode/m9s12xg.h elf32-target.h
 elf32-m88k.lo: elf32-m88k.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h elf32-target.h
diff -u -r -N binutils-2.18/bfd/targets.c binutils-2.18-s12x/bfd/targets.c
--- binutils-2.18/bfd/targets.c	2007-08-06 20:59:42.000000000 +0100
+++ binutils-2.18-s12x/bfd/targets.c	2008-03-20 19:58:10.000000000 +0000
@@ -612,6 +612,7 @@
 extern const bfd_target bfd_elf32_m32rlelin_vec;
 extern const bfd_target bfd_elf32_m68hc11_vec;
 extern const bfd_target bfd_elf32_m68hc12_vec;
+extern const bfd_target bfd_elf32_m9s12xg_vec;
 extern const bfd_target bfd_elf32_m68k_vec;
 extern const bfd_target bfd_elf32_m88k_vec;
 extern const bfd_target bfd_elf32_mcore_big_vec;
@@ -941,6 +942,7 @@
         &bfd_elf32_m32rlelin_vec,
 	&bfd_elf32_m68hc11_vec,
 	&bfd_elf32_m68hc12_vec,
+	&bfd_elf32_m9s12xg_vec,
 	&bfd_elf32_m68k_vec,
 	&bfd_elf32_m88k_vec,
 	&bfd_elf32_mcore_big_vec,
diff -u -r -N binutils-2.18/bfd/version.h binutils-2.18-s12x/bfd/version.h
--- binutils-2.18/bfd/version.h	2007-08-28 18:19:33.000000000 +0100
+++ binutils-2.18-s12x/bfd/version.h	2010-05-04 11:52:37.000000000 +0100
@@ -1,4 +1,4 @@
-#define BFD_VERSION_DATE 20070828
+#define BFD_VERSION_DATE 20100504
 #define BFD_VERSION @bfd_version@
 #define BFD_VERSION_STRING  @bfd_version_package@ @bfd_version_string@
 #define REPORT_BUGS_TO @report_bugs_to@
diff -u -r -N binutils-2.18/binutils/readelf.c binutils-2.18-s12x/binutils/readelf.c
--- binutils-2.18/binutils/readelf.c	2007-08-28 18:19:34.000000000 +0100
+++ binutils-2.18-s12x/binutils/readelf.c	2008-03-21 13:58:35.000000000 +0000
@@ -665,6 +665,7 @@
     case EM_68HC05:
     case EM_68HC08:
     case EM_68HC11:
+    case EM_M9S12XG:
     case EM_68HC16:
     case EM_FX66:
     case EM_ME16:
@@ -990,6 +991,7 @@
 
 	case EM_68HC11:
 	case EM_68HC12:
+	case EM_M9S12XG:
 	  rtype = elf_m68hc11_reloc_type (type);
 	  break;
 
@@ -1724,7 +1726,7 @@
     case EM_IA_64:		return "Intel IA-64";
     case EM_MIPS_X:		return "Stanford MIPS-X";
     case EM_COLDFIRE:		return "Motorola Coldfire";
-    case EM_68HC12:		return "Motorola M68HC12";
+
     case EM_ALPHA:		return "Alpha";
     case EM_CYGNUS_D10V:
     case EM_D10V:		return "d10v";
@@ -1755,6 +1757,8 @@
     case EM_ST9PLUS:		return "STMicroelectronics ST9+ 8/16 bit microcontroller";
     case EM_ST7:		return "STMicroelectronics ST7 8-bit microcontroller";
     case EM_68HC16:		return "Motorola MC68HC16 Microcontroller";
+    case EM_M9S12XG:		return "Freescale 9S12X-XGATE";
+    case EM_68HC12:		return "Motorola M68HC12";
     case EM_68HC11:		return "Motorola MC68HC11 Microcontroller";
     case EM_68HC08:		return "Motorola MC68HC08 Microcontroller";
     case EM_68HC05:		return "Motorola MC68HC05 Microcontroller";
diff -u -r -N binutils-2.18/binutils/version.c binutils-2.18-s12x/binutils/version.c
--- binutils-2.18/binutils/version.c	2007-08-06 20:56:15.000000000 +0100
+++ binutils-2.18-s12x/binutils/version.c	2010-05-04 11:53:24.000000000 +0100
@@ -37,5 +37,6 @@
 This program is free software; you may redistribute it under the terms of\n\
 the GNU General Public License version 3 or (at your option) any later version.\n\
 This program has absolutely no warranty.\n"));
+  printf (_("9S12X patch 20100504\n"));
   exit (0);
 }
diff -u -r -N binutils-2.18/config.sub binutils-2.18-s12x/config.sub
--- binutils-2.18/config.sub	2007-08-06 21:00:30.000000000 +0100
+++ binutils-2.18-s12x/config.sub	2008-03-21 14:08:52.000000000 +0000
@@ -250,6 +250,7 @@
	| i370 | i860 | i960 | ia64 \
	| ip2k | iq2000 \
	| m32r | m32rle | m68000 | m68k | m88k | maxq | mb | microblaze | mcore \
+	| m9s12x \
	| mips | mipsbe | mipseb | mipsel | mipsle \
	| mips16 \
	| mips64 | mips64el \
diff -u -r -N binutils-2.18/configure binutils-2.18-s12x/configure
--- binutils-2.18/configure	2007-08-06 21:29:40.000000000 +0100
+++ binutils-2.18-s12x/configure	2008-03-21 14:08:08.000000000 +0000
@@ -2418,7 +2418,7 @@
   m32r-*-*)
     noconfigdirs="$noconfigdirs ${libgcj}"
     ;;
-  m68hc11-*-*|m6811-*-*|m68hc12-*-*|m6812-*-*)
+  m68hc11-*-*|m6811-*-*|m68hc12-*-*|m6812-*-*|m9s12x-*-*)
     noconfigdirs="$noconfigdirs target-libiberty target-libstdc++-v3 ${libgcj}"
     ;;
   m68k-*-elf*)
@@ -6128,7 +6128,7 @@
     # For an installed makeinfo, we require it to be from texinfo 4.4 or
     # higher, else we use the "missing" dummy.
     if ${MAKEINFO} --version \
-       | egrep 'texinfo[^0-9]*([1-3][0-9]|4\.[4-9]|[5-9])' >/dev/null 2>&1; then
+       | egrep 'texinfo[^0-9]*(4\.([6-9]|[1-9][0-9])|[5-9]|[1-9][0-9])' >/dev/null 2>&1; then
       :
     else
       MAKEINFO="$MISSING makeinfo"
diff -u -r -N binutils-2.18/configure.ac binutils-2.18-s12x/configure.ac
--- binutils-2.18/configure.ac	2007-08-28 21:24:26.000000000 +0100
+++ binutils-2.18-s12x/configure.ac	2008-03-08 13:44:14.000000000 +0000
@@ -2403,7 +2403,7 @@
     # For an installed makeinfo, we require it to be from texinfo 4.4 or
     # higher, else we use the "missing" dummy.
     if ${MAKEINFO} --version \
-       | egrep 'texinfo[^0-9]*([1-3][0-9]|4\.[4-9]|[5-9])' >/dev/null 2>&1; then
+       | egrep 'texinfo[^0-9]*(4\.([6-9]|[1-9][0-9])|[5-9]|[1-9][0-9])' >/dev/null 2>&1; then
       :
     else
       MAKEINFO="$MISSING makeinfo"
diff -u -r -N binutils-2.18/gas/config/tc-m68hc11.c binutils-2.18-s12x/gas/config/tc-m68hc11.c
--- binutils-2.18/gas/config/tc-m68hc11.c	2007-08-06 20:59:59.000000000 +0100
+++ binutils-2.18-s12x/gas/config/tc-m68hc11.c	2010-05-04 11:51:42.000000000 +0100
@@ -2,6 +2,7 @@
    Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
    Free Software Foundation, Inc.
    Written by Stephane Carrez (stcarrez@nerim.fr)
+   XGATE and S12X added by James Murray (jsm@jsm-net.demon.co.uk)
 
    This file is part of GAS, the GNU Assembler.
 
@@ -125,7 +126,18 @@
   REG_X = 5,
   REG_Y = 6,
   REG_SP = 7,
-  REG_PC = 8
+  REG_PC = 8,
+  REG_R0 = 0,
+  REG_R1 = 1,
+  REG_R2 = 2,
+  REG_R3 = 3,
+  REG_R4 = 4,
+  REG_R5 = 5,
+  REG_R6 = 6,
+  REG_R7 = 7,
+  REG_SP_XG = 8,
+  REG_PC_XG = 9,
+  REG_CCR_XG = 10
 } register_id;
 
 typedef struct operand {
@@ -159,6 +171,15 @@
   {0, 0}
 };
 
+struct m9s12xg_opcode_def {
+  long format;
+  int min_operands;
+  int max_operands;
+  int nb_modes;
+  int used;
+  struct m9s12xg_opcode *opcode;
+};
+
 /* Local functions.  */
 static register_id reg_name_search (char *);
 static register_id register_name (void);
@@ -173,6 +194,8 @@
 static void fixup8 (expressionS *, int, int);
 static void fixup16 (expressionS *, int, int);
 static void fixup24 (expressionS *, int, int);
+static void fixup8_xg (expressionS *, int, int);
+static void fixup16_xg (expressionS *, int, int);
 static unsigned char convert_branch (unsigned char);
 static char *m68hc11_new_insn (int);
 static void build_dbranch_insn (struct m68hc11_opcode *,
@@ -263,6 +286,7 @@
   /* The following pseudo-ops are supported for MRI compatibility.  */
   {"fcb", cons, 1},
   {"fdb", cons, 2},
+  {"fqb", cons, 4},
   {"fcc", stringer, 1},
   {"rmb", s_space, 0},
 
@@ -334,6 +358,8 @@
   get_default_target ();
   if (current_architecture & cpu6811)
     return "elf32-m68hc11";
+  else if (current_architecture & cpuxgate)
+    return "elf32-m9s12xg";
   else
     return "elf32-m68hc12";
 }
@@ -344,6 +370,8 @@
   get_default_target ();
   if (current_architecture & cpu6811)
     return bfd_arch_m68hc11;
+  else if (current_architecture & cpuxgate)
+    return bfd_arch_m9s12xg;
   else
     return bfd_arch_m68hc12;
 }
@@ -360,6 +388,10 @@
 {
   if (current_architecture & cpu6811)
     return "M68HC11 GAS ";
+  else if (current_architecture & cpuxgate)
+    return "XGATE GAS ";
+  else if (current_architecture & cpu9s12x)
+    return "S12X GAS ";
   else
     return "M68HC12 GAS ";
 }
@@ -371,7 +403,8 @@
   fprintf (stream, _("\
 Motorola 68HC11/68HC12/68HCS12 options:\n\
   -m68hc11 | -m68hc12 |\n\
-  -m68hcs12               specify the processor [default %s]\n\
+  -m68hcs12 | -m9s12x |\n\
+  -mxgate specify the processor [default %s]\n\
   -mshort                 use 16-bit int ABI (default)\n\
   -mlong                  use 32-bit int ABI\n\
   -mshort-double          use 32-bit double ABI\n\
@@ -412,6 +445,11 @@
 	  current_architecture = cpu6811;
 	  default_cpu = "m68hc11";
 	}
+      else if (strcmp (target->name, "elf32-m9s12xg") == 0)
+	{
+	  current_architecture = cpuxgate;
+	  default_cpu = "mxgate";
+	}
       else
 	{
 	  as_bad (_("Default target `%s' is not supported."), target->name);
@@ -491,14 +529,19 @@
       break;
 
     case 'm':
-      if (strcasecmp (arg, "68hc11") == 0)
+      if (strcasecmp (arg, "68hc11") == 0) {
 	current_architecture = cpu6811;
-      else if (strcasecmp (arg, "68hc12") == 0)
+      } else if (strcasecmp (arg, "68hc12") == 0) {
 	current_architecture = cpu6812;
-      else if (strcasecmp (arg, "68hcs12") == 0)
+     } else if (strcasecmp (arg, "68hcs12") == 0) {
 	current_architecture = cpu6812 | cpu6812s;
-      else
+     } else if (strcasecmp (arg, "m9s12x") == 0) {
+	current_architecture = cpu6812 | cpu6812s | cpu9s12x;
+     } else if (strcasecmp (arg, "xgate") == 0) {
+	current_architecture = cpuxgate;
+     } else {
 	as_bad (_("Option `%s' is not recognized."), arg);
+     }
       break;
 
     default:
@@ -666,6 +709,15 @@
 
       /* See how many operands this opcode needs.  */
       expect = 0;
+      if (opcodes->arch == cpuxgate) {
+        if (opcodes->format & (M68XG_OP_IMM3 | M68XG_OP_R | M68XG_OP_REL9 | M68XG_OP_REL10 )) {
+	        expect = 1;
+        } else if (opcodes->format & (M68XG_OP_R_R | M68XG_OP_R_IMM4 | M68XG_OP_R_IMM8 | M68XG_OP_R_IMM8)) {
+	        expect = 2;
+        } else if (opcodes->format & (M68XG_OP_R_R_R | M68XG_OP_R_R_OFFS5 | M68XG_OP_RD_RB_RI | M68XG_OP_RD_RB_RIp | M68XG_OP_RD_RB_mRI)) {
+	        expect = 3;
+        }
+      } else {
       if (opcodes->format & M6811_OP_MASK)
 	expect++;
       if (opcodes->format & M6811_OP_BITMASK)
@@ -678,6 +730,7 @@
       if ((opcodes->format & M6812_OP_PAGE)
           && !(opcodes->format & M6811_OP_IND16))
         expect++;
+      }
 
       if (expect < opc->min_operands)
 	opc->min_operands = expect;
@@ -715,6 +768,90 @@
 
   p = buf;
   buf[0] = 0;
+
+  if (current_architecture == cpuxgate) {
+  if (format & M68XG_OP_IMM3) {
+      if (example)
+	sprintf (p, "#%d", rand () & 0x007);
+      else
+	strcpy (p, _("imm3"));
+      p = &p[strlen (p)];
+  } else if (format & M68XG_OP_R) {
+      if (example)
+	sprintf (p, "R%d", rand () & 0x07);
+      else
+	strcpy (p, _("Rx"));
+      p = &p[strlen (p)];
+  } else if (format & M68XG_OP_R_R) {
+      if (example)
+	sprintf (p, "R%d,R%d", rand () & 0x07, rand () & 0x07);
+      else
+	strcpy (p, _("Rx,Ry"));
+      p = &p[strlen (p)];
+  } else if (format & M68XG_OP_R_IMM4) {
+      if (example)
+	sprintf (p, "R%d,#%d", rand () & 0x07, rand () & 0x0f);
+      else
+	strcpy (p, _("Rx, #imm4"));
+      p = &p[strlen (p)];
+  } else if (format & M68XG_OP_R_R_R) {
+      if (example)
+	sprintf (p, "R%d,R%d,R%d", rand () & 0x07, rand () & 0x07, rand () & 0x07);
+      else
+	strcpy (p, "Rx,Ry,Rz");
+      p = &p[strlen (p)];
+  } else if (format & M68XG_OP_REL9) {
+      if (example)
+	sprintf (p, "%d", rand () & 0x1FF);
+      else
+	strcpy (p, "<rel9>");
+      p = &p[strlen (p)];
+  } else if (format & M68XG_OP_REL10) {
+      if (example)
+	sprintf (p, "%d", rand () & 0x3FF);
+      else
+	strcpy (p, "<rel10>");
+      p = &p[strlen (p)];
+  } else if (format & M68XG_OP_R_R_OFFS5) {
+      if (example)
+	sprintf (p, "R%d, (R%d, #0x%x)", rand () & 0x07, rand () & 0x07, rand () & 0x1f);
+      else
+	strcpy (p, _("Rx, (Ry,#offs5)"));
+      p = &p[strlen (p)];
+  } else if (format & M68XG_OP_RD_RB_RI) {
+      if (example)
+	sprintf (p, "R%d, (R%d, R%d)", rand () & 0x07, rand () & 0x07, rand () & 0x07);
+      else
+	strcpy (p, "RD, (RB, RI)");
+      p = &p[strlen (p)];
+  } else if (format & M68XG_OP_RD_RB_RIp) {
+      if (example)
+	sprintf (p, "R%d, (R%d, R%d+)", rand () & 0x07, rand () & 0x07, rand () & 0x07);
+      else
+	strcpy (p, "RD, (RB, RI+)");
+      p = &p[strlen (p)];
+  } else if (format & M68XG_OP_RD_RB_mRI) {
+      if (example)
+	sprintf (p, "R%d, (R%d, -R%d)", rand () & 0x07, rand () & 0x07, rand () & 0x07);
+      else
+	strcpy (p, "RD, (RB, -RI)");
+      p = &p[strlen (p)];
+  } else if (format & M68XG_OP_R_IMM8) {
+      if (example)
+	sprintf (p, "R%d, #0x%x", rand () & 0x07, rand () & 0xff);
+      else
+	strcpy (p, "RD, #imm8");
+      p = &p[strlen (p)];
+  } else if (format & M68XG_OP_R_IMM16) {
+      if (example)
+	sprintf (p, "R%d, #0x%x", rand () & 0x07, rand () & 0xffff);
+      else
+	strcpy (p, "RD, #imm16");
+      p = &p[strlen (p)];
+  }
+
+ } else {
+
   if (format & M6811_OP_IMM8)
     {
       if (example)
@@ -819,7 +956,7 @@
       else
 	strcpy (p, _("<label>"));
     }
-
+  }
   return buf;
 }
 
@@ -834,7 +971,7 @@
 
   if (example)
     printf (_("# Example of `%s' instructions\n\t.sect .text\n_start:\n"),
-	    default_cpu);
+	    default_cpu); /* reports incorrect name, need to use current_architecture instead */
 
   opcodes = m68hc11_sorted_opcodes;
 
@@ -922,7 +1059,29 @@
     return REG_PC;
   if (strcasecmp (name, "ccr") == 0)
     return REG_CCR;
-
+/* XGATE */
+  if (strcasecmp (name, "r0") == 0)
+    return REG_R0;
+  if (strcasecmp (name, "r1") == 0)
+    return REG_R1;
+  if (strcasecmp (name, "r2") == 0)
+    return REG_R2;
+  if (strcasecmp (name, "r3") == 0)
+    return REG_R3;
+  if (strcasecmp (name, "r4") == 0)
+    return REG_R4;
+  if (strcasecmp (name, "r5") == 0)
+    return REG_R5;
+  if (strcasecmp (name, "r6") == 0)
+    return REG_R6;
+  if (strcasecmp (name, "r7") == 0)
+    return REG_R7;
+  if (strcasecmp (name, "sp") == 0)
+    return REG_SP_XG;
+  if (strcasecmp (name, "pc") == 0)
+    return REG_PC_XG;
+  if (strcasecmp (name, "ccr") == 0)
+    return REG_CCR_XG;
   return REG_NONE;
 }
 
@@ -1323,6 +1482,35 @@
 static int
 check_range (long num, int mode)
 {
+  if (current_architecture == cpuxgate) {
+
+  switch (mode)
+    {
+    case M68XG_OP_IMM3:
+      return (num >= 0 && num <= 7) ? 1 : 0;
+
+    case M68XG_OP_R_IMM4:
+      return (num >= 0 && num <= 31) ? 1 : 0;
+
+    case M68XG_OP_R_R_OFFS5:
+      return (num >= 0 && num <= 63) ? 1 : 0;
+
+    case M68XG_OP_R_IMM8:
+      return (num >= 0 && num <= 255) ? 1 : 0;
+
+    case M68XG_OP_R_IMM16:
+      return (num >= 0 && num <= 65535) ? 1 : 0;
+
+    case M68XG_OP_B_MARKER:
+      return (num >= -512 && num <= 511) ? 1 : 0;
+
+    case M68XG_OP_BRA_MARKER:
+      return (num >= -1024 && num <= 1023) ? 1 : 0;
+
+    default:
+      return 0;
+    }
+  } else {
   /* Auto increment and decrement are ok for [-8..8] without 0.  */
   if (mode & M6812_AUTO_INC_DEC)
     return (num != 0 && num <= 8 && num >= -8);
@@ -1369,6 +1557,7 @@
     default:
       return 0;
     }
+    }
 }
 
 /* Gas fixup generation.  */
@@ -1527,6 +1716,137 @@
       as_fatal (_("Operand `%x' not recognized in fixup16."), oper->X_op);
     }
 }
+
+/* XGATE Put a 1 byte expression described by 'oper'.  If this expression contains
+   unresolved symbols, generate an 8-bit fixup.  */
+static void
+fixup8_xg (expressionS *oper, int mode, int opmode)
+{
+  char *f;
+
+  f = frag_more (1);
+
+        if (oper->X_op == O_constant) {
+            fixS *fixp;
+            int reloc;
+            if ((opmode & M6811_OP_HIGH_ADDR) || (opmode & M6811_OP_LOW_ADDR)) {
+                if (opmode & M6811_OP_HIGH_ADDR) {
+                    reloc = BFD_RELOC_M68HC11_HI8;
+                } else {
+                    reloc = BFD_RELOC_M68HC11_LO8;
+                }
+
+	            fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 1,
+                              oper, FALSE, reloc);
+                fixp->fx_no_overflow = 1;
+                number_to_chars_bigendian (f, 0, 1);
+            } else {
+    	        if (!(check_range (oper->X_add_number, mode))) {
+    	            as_bad (_("Operand out of 8-bit range: `%ld'."), oper->X_add_number);
+    	        }
+                number_to_chars_bigendian (f, oper->X_add_number & 0x0FF, 1);
+            }
+
+        } else if (oper->X_op != O_register) {
+            if (mode == M68XG_OP_REL9) {
+	            fixS *fixp;
+
+	            fixp = fix_new_exp (frag_now, f - frag_now->fr_literal -1, 2,
+			      oper, TRUE, BFD_RELOC_9_PCREL);
+	            fixp->fx_pcrel_adjust = 1;
+            } else if (mode == M68XG_OP_REL10) {
+	            fixS *fixp;
+
+	            fixp = fix_new_exp (frag_now, f - frag_now->fr_literal -1, 2,
+			      oper, TRUE, BFD_RELOC_10_PCREL);
+	            fixp->fx_pcrel_adjust = 1;
+	        } else {
+	            fixS *fixp;
+                int reloc;
+	            /* Now create an 8-bit fixup.  If there was some %hi, %lo
+	               or %page modifier, generate the reloc accordingly.  */
+                if (opmode & M6811_OP_HIGH_ADDR) {
+                    reloc = BFD_RELOC_M68HC11_HI8;
+                } else if (opmode & M6811_OP_LOW_ADDR) {
+                    reloc = BFD_RELOC_M68HC11_LO8;
+                } else if (opmode & M6811_OP_PAGE_ADDR) {
+                    reloc = BFD_RELOC_M68HC11_PAGE;
+                } else {
+                    reloc = BFD_RELOC_8;
+                }
+
+	            fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 1,
+                              oper, FALSE, reloc);
+                if (reloc != BFD_RELOC_8) {
+                    fixp->fx_no_overflow = 1;
+                }
+	        }
+            number_to_chars_bigendian (f, 0, 1);
+        } else {
+            as_fatal (_("Operand `%x' not recognized in fixup8."), oper->X_op);
+        }
+}
+
+/* XGATE Put a 2 byte expression described by 'oper'.  If this expression contains
+   unresolved symbols, generate an 16-bit fixup.  */
+static void
+fixup16_xg (expressionS *oper, int mode, int opmode)
+{
+  char *f;
+
+  f = frag_more (3); // preserve alignment
+
+        if (oper->X_op == O_constant) {
+            fixS *fixp;
+            int reloc;
+            if (opmode & M6811_OP_HIGH_ADDR) {
+                reloc = BFD_RELOC_M68HC11_HI8;
+
+	            fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 2,
+                              oper, FALSE, reloc);
+                fixp->fx_no_overflow = 1;
+                number_to_chars_bigendian (f, 0, 2);
+            } else {
+    	        if (!(check_range (oper->X_add_number, mode))) {
+    	            as_bad (_("Operand out of 16-bit range: `%ld'."), oper->X_add_number);
+    	        }
+                number_to_chars_bigendian (f, oper->X_add_number, 2);
+            }
+
+        } else if (oper->X_op != O_register) {
+            if (mode == M68XG_OP_REL9) {
+	            fixS *fixp;
+
+	            fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 2,
+			      oper, TRUE, BFD_RELOC_9_PCREL);
+	            fixp->fx_pcrel_adjust = 1;
+            } else if (mode == M68XG_OP_REL10) {
+	            fixS *fixp;
+
+	            fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 2,
+			      oper, TRUE, BFD_RELOC_10_PCREL);
+	            fixp->fx_pcrel_adjust = 1;
+	        } else {
+	            fixS *fixp;
+                int reloc;
+	            /* Now create an 16-bit fixup.  If there was some %hi, %lo
+	               or %page modifier, generate the reloc accordingly.  */
+                if (opmode & M6811_OP_HIGH_ADDR) {
+                    reloc = BFD_RELOC_M68HC11_HI8_16;
+                } else {
+                    reloc = BFD_RELOC_16;
+                }
+	            fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 2,
+                              oper, FALSE, reloc);
+                if (reloc != BFD_RELOC_16) {
+                    fixp->fx_no_overflow = 1; // not sure what this is doing
+                }
+	        }
+            number_to_chars_bigendian (f, 0, 3);
+        } else {
+            as_fatal (_("Operand `%x' not recognized in fixup8."), oper->X_op);
+        }
+}
 
 /* 68HC11 and 68HC12 code generation.  */
 
@@ -2052,7 +2372,9 @@
       return 1;
     }
 
+
   as_fatal (_("Addressing mode not implemented yet."));
+  fprintf(stderr, "mode = 0x%x\nop->reg1 = 0x%x\nop->reg2 = 0x%x\n", mode, op->reg1, op->reg2);
   return 0;
 }
 
@@ -2101,6 +2423,45 @@
   /* Put the page code instruction if there is one.  */
   format = opcode->format;
 
+  if (current_architecture == cpuxgate) {
+    operands[0].mode = 0;
+    if (format & M68XG_OP_R_IMM8) {
+        // these opcodes are byte followed by imm8
+        f = m68hc11_new_insn (1);
+        number_to_chars_bigendian (f, opcode->opcode >> 8, 1);
+        fixup8_xg (&operands[0].exp, format, operands[0].mode);
+    } else if (format & M68XG_OP_R_IMM16) {
+        // these opcodes expand into two imm8 instructions
+        f = m68hc11_new_insn (1);
+        number_to_chars_bigendian (f, opcode->opcode >> 8, 1);
+        operands[0].mode = M6811_OP_LOW_ADDR;
+        fixup8_xg (&operands[0].exp, format, operands[0].mode);  /* low byte */
+
+        f = m68hc11_new_insn (1);
+        number_to_chars_bigendian (f, (opcode->opcode >> 8) | 0x08, 1);
+    /* just writing the high byte doesn't work due to low byte overflow,
+       so write high and low and figure it out in reloc code */
+        operands[0].mode = M6811_OP_HIGH_ADDR;
+        if (operands[0].exp.X_op == O_constant) {
+            fixup8_xg (&operands[0].exp, format, operands[0].mode);  /* a constant so high only is ok */
+        } else {
+            fixup16_xg (&operands[0].exp, format, operands[0].mode);  /* high and low bytes */
+        }
+    } else if (format & M68XG_OP_REL9) {
+        f = m68hc11_new_insn (1);
+        number_to_chars_bigendian (f, opcode->opcode >> 8, 1); /* high byte */
+        fixup8_xg (&operands[0].exp, format, M68XG_OP_REL9);
+    } else if (format & M68XG_OP_REL10) {
+        f = m68hc11_new_insn (1);
+        number_to_chars_bigendian (f, opcode->opcode >> 8, 1); /* high byte */
+        fixup8_xg (&operands[0].exp, format, M68XG_OP_REL10);
+    } else {
+        f = m68hc11_new_insn (2);
+        number_to_chars_bigendian (f, opcode->opcode, 2);
+    }
+    return;
+  }
+
   if (format & M6811_OP_BRANCH)
     fix_new (frag_now, frag_now_fix (), 0,
              &abs_symbol, 0, 1, BFD_RELOC_M68HC11_RL_JUMP);
@@ -2223,9 +2584,26 @@
   op_indirect = 0;
   opcode = opc->opcode;
 
+
+  if (current_architecture & cpuxgate) {
+
+    /* Now search the opcode table table for one with operands
+       that matches what we've got.
+       XGATE simple enough that we should get an exact match  */
+    for (pos = match = 0; match == 0 && pos < opc->nb_modes; pos++, opcode++) {
+        if (opcode->format == operands[nb_operands-1].mode ) {
+            return opcode;
+        }
+    }
+
+    return 0;
+
+  } else { /* non XGATE */
+
   /* Now search the opcode table table for one with operands
      that matches what we've got.  We're only done if the operands matched so
      far AND there are no more to check.  */
+
   for (pos = match = 0; match == 0 && pos < opc->nb_modes; pos++, opcode++)
     {
       int poss_indirect = 0;
@@ -2233,6 +2611,7 @@
       int expect;
 
       expect = 0;
+
       if (opcode->format & M6811_OP_MASK)
 	expect++;
       if (opcode->format & M6811_OP_BITMASK)
@@ -2244,7 +2623,7 @@
       if ((opcode->format & M6812_OP_PAGE)
           && (!IS_CALL_SYMBOL (opcode->format) || nb_operands == 2))
         expect++;
-
+      
       for (i = 0; expect == nb_operands && i < nb_operands; i++)
 	{
 	  int mode = operands[i].mode;
@@ -2370,7 +2749,7 @@
     {
       return (0);
     }
-
+}
   return opcode;
 }
 
@@ -2452,6 +2831,7 @@
   struct m68hc11_opcode_def *opc;
   struct m68hc11_opcode *opcode;
 
+  struct m68hc11_opcode opcode_local;
   unsigned char *op_start, *op_end;
   char *save;
   char name[20];
@@ -2482,6 +2862,450 @@
       return;
     }
 
+
+  if (current_architecture == cpuxgate) { /* XGATE */
+
+    /* Find the opcode definition given its name.  */
+    opc = (struct m68hc11_opcode_def *) hash_find (m68hc11_hash, name);
+    if (opc == NULL) {
+        as_bad (_("Opcode `%s' is not recognized."), name);
+        return;
+    }
+
+    /* grab to local copy */
+    opcode_local.name = opc->opcode->name;
+    /* these will be incorrect where multiple variants exist */
+    opcode_local.opcode = opc->opcode->opcode;
+    opcode_local.format = opc->opcode->format;
+
+    save = input_line_pointer;
+    input_line_pointer = (char *) op_end;
+
+    if (opc->format == M68XG_OP_NONE) {
+        opcode_local.format = M68XG_OP_NONE; // no special handling required
+        build_insn (opc->opcode, operands, 0);
+        return;
+    }
+
+    // special handling of TFR
+    if (strncmp(opc->opcode->name, "tfr",3) == 0) {
+        // There must be two operands with a comma
+        input_line_pointer = skip_whites (input_line_pointer);
+        operands[0].reg1 = register_name ();
+        if (operands[0].reg1 == REG_NONE) {
+            as_bad("Invalid register\n");
+            return;
+        }
+        input_line_pointer = skip_whites (input_line_pointer);
+        if (*input_line_pointer != ',') {
+            as_bad ("Missing comma.\n"); // FIXME translate
+            return;
+        }
+        input_line_pointer++;
+        input_line_pointer = skip_whites (input_line_pointer);
+        operands[1].reg1 = register_name ();
+        if (operands[1].reg1 == REG_NONE) {
+            as_bad("Invalid register\n");
+            return;
+        }
+        input_line_pointer = skip_whites (input_line_pointer);
+        if (*input_line_pointer != '\n' && *input_line_pointer) {
+	        as_bad (_("Garbage at end of instruction: `%s'."), input_line_pointer);
+            return;
+        }
+        if (operands[1].reg1 == REG_CCR) { // ,CCR
+            opc->opcode->opcode = 0x00f8 | ( operands[0].reg1 << 8);
+        } else if (operands[0].reg1 == REG_CCR) { // CCR,
+            opc->opcode->opcode = 0x00f9 | ( operands[1].reg1 << 8);
+        } else if (operands[1].reg1 == REG_PC) { // ,PC
+            opc->opcode->opcode = 0x00fa | ( operands[0].reg1 << 8);
+        } else {
+            as_bad("Invalid operand to TFR\n");
+            return;
+        }
+        opcode_local.format = M68XG_OP_NONE; // no special handling required
+        build_insn (&opcode_local, operands, 0);
+        return;
+    }
+
+//CSEM, SSEM
+    if (opc->format & M68XG_OP_IMM3) {
+        // either imm3 or R
+        input_line_pointer = skip_whites (input_line_pointer);
+        if ((*input_line_pointer == 'R') || (*input_line_pointer == 'r')) {
+            operands[0].reg1 = register_name ();
+            if (operands[0].reg1 == REG_NONE) {
+                as_bad("Invalid register\n");
+                return;
+            }
+            operands[0].mode = M68XG_OP_R;
+            // same opcodes have multiple modes, so find right one
+            opcode = find (opc, operands, 1);
+            if (opcode) {
+                opcode_local.opcode = opcode->opcode  | (operands[0].reg1 << 8);
+                opcode_local.format = M68XG_OP_NONE;
+                build_insn (&opcode_local, operands, 1);
+            } else {
+                as_bad("No opcode found\n");
+            }
+            return;
+        } else {
+            if (*input_line_pointer == '#') {
+                input_line_pointer++;
+            }
+            expression (&operands[0].exp);
+            if (operands[0].exp.X_op == O_illegal) {
+                as_bad (_("Illegal operand."));
+                return;
+            } else if (operands[0].exp.X_op == O_absent) {
+                as_bad (_("Missing operand."));
+                return;
+            }
+
+            if (check_range(operands[0].exp.X_add_number,M68XG_OP_IMM3)) {
+                opcode_local.opcode |= (operands[0].exp.X_add_number);
+                operands[0].mode = M68XG_OP_IMM3;
+                // same opcodes have multiple modes, so find right one
+                opcode = find (opc, operands, 1);
+                if (opcode) {
+                    opcode_local.opcode = opcode->opcode;
+                    opcode_local.opcode |= (operands[0].exp.X_add_number) << 8;
+                    opcode_local.format = M68XG_OP_NONE;
+                    build_insn (&opcode_local, operands, 1);
+                } else {
+                    as_bad("No opcode found\n");
+                }
+                return;
+            } else {
+                as_bad("Number out of range for IMM3\n");
+                return;
+            }
+        }
+    }
+
+    // special handling of SIF
+    if (strncmp(opc->opcode->name, "sif",3) == 0) {
+        // Either OP_NONE or OP_RS
+        if (*input_line_pointer != '\n') {
+            input_line_pointer = skip_whites (input_line_pointer);
+        }
+        if ((*input_line_pointer == '\n') || (*input_line_pointer == '\r') || (*input_line_pointer == '\0')) {
+            opc->opcode->opcode = 0x0300;
+        } else {
+            operands[0].reg1 = register_name ();
+            if (operands[0].reg1 == REG_NONE) {
+                as_bad("Invalid register\n");
+                return;
+            }
+            opcode_local.opcode = 0x00f7 | (operands[0].reg1 << 8);
+        }
+        opcode_local.format = M68XG_OP_NONE; // no special handling required
+        build_insn (&opcode_local, operands, 0);
+        return;
+    }
+
+    // SEX, PAR, JAL only
+    if (opc->format & M68XG_OP_R) {
+        input_line_pointer = skip_whites (input_line_pointer);
+        operands[0].reg1 = register_name ();
+        if (operands[0].reg1 == REG_NONE) {
+            as_bad("Invalid register\n");
+            return;
+        }
+         opcode_local.opcode |= (operands[0].reg1 << 8);
+        build_insn (&opcode_local, operands, 0);
+        return;
+    }
+
+    if (opc->format & (M68XG_OP_REL9 | M68XG_OP_REL10)) {
+        opcode_local.format = opc->format; 
+        input_line_pointer = skip_whites (input_line_pointer);
+        expression (&operands[0].exp);
+        if (operands[0].exp.X_op == O_illegal) {
+            as_bad (_("Illegal operand."));
+            return;
+        } else if (operands[0].exp.X_op == O_absent) {
+            as_bad (_("Missing operand."));
+            return;
+        }
+        opcode_local.opcode = opc->opcode->opcode;
+        build_insn (&opcode_local, operands, 1);
+        return;
+    }
+
+
+    /* For other command formats, parse input line and determine the mode we are using as we go */
+    /* the above special cases work, but may not be necessary */
+
+    input_line_pointer = skip_whites (input_line_pointer);
+    if ((*input_line_pointer == '\n') || (*input_line_pointer == '\r') || (*input_line_pointer == '\0')) {
+	    return; // nothing left
+    }
+    
+    if (*input_line_pointer == '#') {
+        as_bad("No register specified before hash\n");
+        return;
+    } 
+
+    /* first operand is expected to be a register */
+    if ((*input_line_pointer == 'R') || (*input_line_pointer == 'r')) {
+        operands[0].reg1 = register_name ();
+        if (operands[0].reg1 == REG_NONE) {
+            as_bad("Invalid register\n");
+            return;
+        }
+    }
+
+    input_line_pointer = skip_whites (input_line_pointer);
+    if (*input_line_pointer != ',') {
+        as_bad ("1Missing operand\n"); // FIXME translate
+        return;
+    }
+    input_line_pointer++;
+    input_line_pointer = skip_whites (input_line_pointer);
+
+    if (*input_line_pointer == '#') {
+        // some kind of immediate mode. Check if this is possible
+        if (!(opc->format & (M68XG_OP_R_IMM8 | M68XG_OP_R_IMM16 | M68XG_OP_R_IMM4))) {
+            as_bad("Invalid immediate mode\n");
+            return;
+        }
+        input_line_pointer++;
+        input_line_pointer = skip_whites (input_line_pointer);
+        if (strncmp (input_line_pointer, "%hi", 3) == 0) {
+            input_line_pointer += 3;
+            operands[0].mode = M6811_OP_HIGH_ADDR;
+        } else if (strncmp (input_line_pointer, "%lo", 3) == 0) {
+	        input_line_pointer += 3;
+	        operands[0].mode = M6811_OP_LOW_ADDR;
+	    }
+        expression (&operands[0].exp);
+        if (operands[0].exp.X_op == O_illegal) {
+            as_bad (_("Illegal operand."));
+            return;
+        } else if (operands[0].exp.X_op == O_absent) {
+            as_bad (_("Missing operand."));
+            return;
+        }
+        /* ok so far, can only be one mode */
+        opcode_local.format = opc->format & (M68XG_OP_R_IMM8 | M68XG_OP_R_IMM16 | M68XG_OP_R_IMM4);
+        if (opcode_local.format & M68XG_OP_R_IMM4) {
+            operands[0].mode = M68XG_OP_R_IMM4;
+            // same opcodes have multiple modes, so find right one
+            opcode = find (opc, operands, 1);
+            if (opcode) {
+                opcode_local.opcode = opcode->opcode | (operands[0].reg1 << 8);
+            }
+            if (operands[0].exp.X_op != O_constant) {
+                as_bad("Only constants supported at for IMM4 mode\n");
+            } else {
+                if (check_range(operands[0].exp.X_add_number,M68XG_OP_R_IMM4)) {
+                    opcode_local.opcode |= (operands[0].exp.X_add_number << 4);
+                } else {
+                    as_bad("Number out of range for IMM4\n");
+                }
+            }
+            opcode_local.format = M68XG_OP_NONE;
+        } else if (opcode_local.format & M68XG_OP_R_IMM16) {
+            operands[0].mode = M68XG_OP_R_IMM16;
+            // same opcodes have multiple modes, so find right one
+            opcode = find (opc, operands, 1);
+            if (opcode) {
+                opcode_local.opcode = opcode->opcode | (operands[0].reg1 << 8);
+            }
+        } else {
+            opcode_local.opcode = opc->opcode->opcode | (operands[0].reg1 << 8);
+        }
+        build_insn (&opcode_local, operands, 1);
+    } else if ((*input_line_pointer == 'R') || (*input_line_pointer == 'r')) {
+        /* we've got as far as OP R, R */
+        operands[1].reg1 = register_name ();
+        if (operands[1].reg1 == REG_NONE) {
+            as_bad("Invalid register\n");
+            return;
+        }
+        if ((*input_line_pointer == '\n') || (*input_line_pointer == '\r') || (*input_line_pointer == '\0')) {
+            /* looks like OP_R_R */
+            if (opc->format & M68XG_OP_R_R) {        
+                operands[0].mode = M68XG_OP_R_R;
+                // same opcodes have multiple modes, so find right one
+                opcode = find (opc, operands, 1);
+                if (opcode) {
+                    if (opcode->opcode == 0x1800) {
+                        //special case for cmp RS1, RS2 alias for sub R0, RS1, RS2
+                        opcode_local.opcode = opcode->opcode | (operands[0].reg1 << 5) | (operands[1].reg1 << 2);
+                    } else {
+                        opcode_local.opcode = opcode->opcode | (operands[0].reg1 << 8) | (operands[1].reg1 << 5);
+                    }
+                    opcode_local.format = M68XG_OP_NONE;
+                    build_insn (&opcode_local, operands, 1);
+                }
+            } else {
+                as_bad("No valid mode found\n");
+            }
+        } else {
+            /* more data */
+            if (*input_line_pointer != ',') {
+            as_bad (_("Missing operand."));
+                return;
+            }
+            input_line_pointer++;
+            input_line_pointer = skip_whites (input_line_pointer);
+            if ((*input_line_pointer == 'R') || (*input_line_pointer == 'r')) {
+                operands[2].reg1 = register_name ();
+                if (operands[2].reg1 == REG_NONE) {
+                    as_bad("Invalid register\n");
+                    return;
+                }
+                if (opc->format & M68XG_OP_R_R_R) {        
+                    operands[0].mode = M68XG_OP_R_R_R;
+                    // same opcodes have multiple modes, so find right one
+                    opcode = find (opc, operands, 1);
+                    if (opcode) {
+                        opcode_local.opcode = opcode->opcode | (operands[0].reg1 << 8) | (operands[1].reg1 << 5) | (operands[2].reg1 << 2);
+                        opcode_local.format = M68XG_OP_NONE;
+                        build_insn (&opcode_local, operands, 1);
+                    }
+                } else {
+                    as_bad("No valid mode found\n");
+                }
+            }
+        }
+    } else if (*input_line_pointer == '(') { /* indexed modes */
+        input_line_pointer++;
+        input_line_pointer = skip_whites (input_line_pointer);
+        if ((*input_line_pointer == 'R') || (*input_line_pointer == 'r')) {
+            /* we've got as far as OP R, (R */
+            operands[1].reg1 = register_name ();
+            if (operands[1].reg1 == REG_NONE) {
+                as_bad("Invalid register\n");
+                return;
+            }
+//?            input_line_pointer = skip_whites (input_line_pointer);
+            if ((*input_line_pointer == '\n') || (*input_line_pointer == '\r') || (*input_line_pointer == '\0')) {
+                /* looks like OP_R_R */
+                as_bad (_("Missing operand."));
+                return;
+            }
+
+            input_line_pointer = skip_whites (input_line_pointer);
+            
+            if (*input_line_pointer != ',') {
+                as_bad (_("Missing operand."));
+                return;
+            }
+            input_line_pointer++;
+            input_line_pointer = skip_whites (input_line_pointer);
+
+            if (*input_line_pointer == '#') {
+                
+                input_line_pointer++;
+                input_line_pointer = skip_whites (input_line_pointer);
+                expression (&operands[0].exp);
+                if (operands[0].exp.X_op == O_illegal) {
+                    as_bad (_("Illegal operand."));
+                    return;
+                } else if (operands[0].exp.X_op == O_absent) {
+                    as_bad (_("Missing operand."));
+                    return;
+                }
+
+                input_line_pointer = skip_whites (input_line_pointer);
+                if (*input_line_pointer != ')') {
+    		        as_bad ("Missing `)' to close register indirect operand.");
+                    return;
+                } else {
+                    input_line_pointer++;
+                }
+                    
+                /* ok so far, can only be one mode */
+                opcode_local.format = M68XG_OP_R_R_OFFS5;
+                operands[0].mode = M68XG_OP_R_R_OFFS5;
+                // same opcodes have multiple modes, so find right one
+                opcode = find (opc, operands, 1);
+                if (opcode) {
+                    opcode_local.opcode = opcode->opcode | (operands[0].reg1 << 8) | (operands[1].reg1 << 5);
+                    if (operands[0].exp.X_op != O_constant) {
+                        as_bad("Only constants supported at for indexed OFFS5 mode\n");
+                    } else {
+                        if (check_range(operands[0].exp.X_add_number,M68XG_OP_R_R_OFFS5)) {
+                            opcode_local.opcode |= (operands[0].exp.X_add_number);
+                            opcode_local.format = M68XG_OP_NONE;
+                            build_insn (&opcode_local, operands, 1);
+                        } else {
+                            as_bad("Number out of range for OFFS5\n");
+                        }
+                    }  
+                }
+            } else {
+                operands[0].mode = M68XG_OP_RD_RB_RI;
+
+                if (*input_line_pointer == '-') {
+                    operands[0].mode = M68XG_OP_RD_RB_mRI;
+                    input_line_pointer++;
+                }
+                operands[2].reg1 = register_name ();
+                if (operands[2].reg1 == REG_NONE) {
+                    as_bad("Invalid register\n");
+                    return;
+                }
+
+                if (*input_line_pointer == '+') {
+                    if (opcode_local.format == M68XG_OP_RD_RB_mRI) {
+                        as_bad (_("Illegal operand."));
+                        return;
+                    }
+                    operands[0].mode = M68XG_OP_RD_RB_RIp;
+                    input_line_pointer++;
+                }
+
+                input_line_pointer = skip_whites (input_line_pointer);
+                if (*input_line_pointer != ')') {
+    		        as_bad ("Missing `)' to close register indirect operand.");
+                    return;
+                } else {
+                    input_line_pointer++;
+                }
+
+                opcode = find (opc, operands, 1);
+                if (opcode) {
+                    opcode_local.opcode = opcode->opcode | (operands[0].reg1 << 8) | (operands[1].reg1 << 5) | (operands[2].reg1 << 2);
+                    opcode_local.format = M68XG_OP_NONE;
+                    build_insn (&opcode_local, operands, 1);
+                } else {
+                    as_bad("Failed to find opcode for %s %s\n", opc->opcode->name, (char *)op_end);
+                }
+            }
+        }
+    }
+
+// needed?
+  if (opc->opcode && !flag_mri)
+    {
+      char *p = input_line_pointer;
+
+      while (*p == ' ' || *p == '\t' || *p == '\n' || *p == '\r')
+	p++;
+
+      if (*p != '\n' && *p)
+	as_bad (_("Garbage at end of instruction: `%s'."), p);
+    }
+
+  input_line_pointer = save;
+
+  /* Opcode is known but does not have valid operands.  Print out the
+     syntax for this opcode.  */
+  if (opc->opcode == 0)
+    {
+      if (flag_print_insn_syntax)
+	print_insn_format (name);
+
+      as_bad (_("Invalid operand for `%s'"), name);
+      return;
+    }
+
+  } else { /* *********** non XGATE *********** */
+
   /* Find the opcode definition given its name.  */
   opc = (struct m68hc11_opcode_def *) hash_find (m68hc11_hash, name);
 
@@ -2500,7 +3324,7 @@
 	branch_optimize = 1;
     }
 
-  /* The following test should probably be removed.  This is not conform
+  /* The following test should probably be removed.  This does not conform
      to Motorola assembler specs.  */
   if (opc == NULL && flag_mri)
     {
@@ -2554,8 +3378,9 @@
       opc->used++;
       opcode = find_opcode (opc, operands, &nb_operands);
     }
-  else
+  else {
     opcode = 0;
+  }
 
   if ((opcode || alias_id >= 0) && !flag_mri)
     {
@@ -2594,19 +3419,22 @@
 
   /* Treat dbeq/ibeq/tbeq instructions in a special way.  The branch is
      relative and must be in the range -256..255 (9-bits).  */
-  if ((opcode->format & M6812_XBCC_MARKER)
-      && (opcode->format & M6811_OP_JUMP_REL))
+
+  if ((opcode->format & M6812_XBCC_MARKER) 
+      && (opcode->format & M6811_OP_JUMP_REL)) {
     build_dbranch_insn (opcode, operands, nb_operands, branch_optimize);
 
   /* Relative jumps instructions are taken care of separately.  We have to make
      sure that the relative branch is within the range -128..127.  If it's out
      of range, the instructions are changed into absolute instructions.
      This is not supported for the brset and brclr instructions.  */
-  else if ((opcode->format & (M6811_OP_JUMP_REL | M6812_OP_JUMP_REL16))
-	   && !(opcode->format & M6811_OP_BITMASK))
+  } else if ((opcode->format & (M6811_OP_JUMP_REL | M6812_OP_JUMP_REL16))
+	   && !(opcode->format & M6811_OP_BITMASK)) {
     build_jump_insn (opcode, operands, nb_operands, branch_optimize);
-  else
+  } else {
     build_insn (opcode, operands, nb_operands);
+  }
+}
 }
 
 
@@ -2997,6 +3825,7 @@
 int
 md_estimate_size_before_relax (fragS *fragP, asection *segment)
 {
+
   if (RELAX_LENGTH (fragP->fr_subtype) == STATE_UNDF)
     {
       if (S_GET_SEGMENT (fragP->fr_symbol) != segment
@@ -3268,6 +4097,7 @@
       ((bfd_byte*) where)[2] = ((value >> 16) & 0x0ff);
       break;
 
+    case BFD_RELOC_M68HC11_HI8_16:
     case BFD_RELOC_16:
     case BFD_RELOC_16_PCREL:
     case BFD_RELOC_M68HC11_LO16:
@@ -3278,9 +4108,7 @@
       break;
 
     case BFD_RELOC_M68HC11_HI8:
-      value = value >> 8;
-      /* Fall through.  */
-
+        value = value >>8;
     case BFD_RELOC_M68HC11_LO8:
     case BFD_RELOC_8:
     case BFD_RELOC_M68HC11_PAGE:
@@ -3296,6 +4124,25 @@
 		      value);
       break;
 
+/* these next two are dubious */
+    case BFD_RELOC_9_PCREL:
+     ((bfd_byte *) where)[0] |= (bfd_byte) ((value >>9) & 0x01);
+     ((bfd_byte *) where)[1] = (bfd_byte) ((value>>1) & 0xff);
+      if (value < -512 || value > 511)
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _("Value %ld too large for 8-bit PC-relative branch."),
+		      value);
+      break;
+
+    case BFD_RELOC_10_PCREL:
+     ((bfd_byte *) where)[0] |= (bfd_byte) ((value >>9) & 0x03);
+     ((bfd_byte *) where)[1] = (bfd_byte) ((value>>1) & 0xff);
+      if (value < -1024 || value > 1023)
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _("Value %ld too large for 8-bit PC-relative branch."),
+		      value);
+      break;
+
     case BFD_RELOC_M68HC11_3B:
       if (value <= 0 || value > 8)
 	as_bad_where (fixP->fx_file, fixP->fx_line,
diff -u -r -N binutils-2.18/gas/config/tc-m68hc11.h binutils-2.18-s12x/gas/config/tc-m68hc11.h
--- binutils-2.18/gas/config/tc-m68hc11.h	2007-08-06 20:59:59.000000000 +0100
+++ binutils-2.18-s12x/gas/config/tc-m68hc11.h	2008-03-20 19:53:33.000000000 +0000
@@ -21,6 +21,7 @@
 
 #define TC_M68HC11
 #define TC_M68HC12
+#define TC_M9S12XG
 
 struct fix;
 
@@ -32,6 +33,10 @@
 /* Motorola assembler specs does not require '.' before pseudo-ops.  */
 #define NO_PSEUDO_DOT 1
 
+#define m9s12xg_arch_format m68hc11_arch_format
+#define m9s12xg_arch m68hc11_arch
+#define m9s12xg_listing_header m68hc11_listing_header
+
 /* The target BFD architecture.  */
 #define TARGET_ARCH (m68hc11_arch ())
 extern enum bfd_architecture m68hc11_arch (void);
diff -u -r -N binutils-2.18/gas/configure.tgt binutils-2.18-s12x/gas/configure.tgt
--- binutils-2.18/gas/configure.tgt	2007-08-28 18:19:36.000000000 +0100
+++ binutils-2.18-s12x/gas/configure.tgt	2008-03-20 19:59:41.000000000 +0000
@@ -50,7 +50,7 @@
   m5200)		cpu_type=m68k ;;
   m68008)		cpu_type=m68k ;;
   m680[012346]0)	cpu_type=m68k ;;
-  m6811|m6812|m68hc12)	cpu_type=m68hc11 ;;
+  m6811|m6812|m68hc12|m9s12x|m9s12xg)	cpu_type=m68hc11 ;;
   m683??)		cpu_type=m68k ;;
   maxq)			cpu_type=maxq ;;
   mep-*-elf)		cpu_type=mep endian=big ;;
@@ -247,6 +247,8 @@
 
   m68hc11-*-* | m6811-*-*)		fmt=elf ;;
   m68hc12-*-* | m6812-*-*)		fmt=elf ;;
+  m9s12x-*-*)				fmt=elf ;;
+  m9s12xg-*-*)				fmt=elf ;;
 
   m68k-*-elf*)				fmt=elf ;;
   m68k-*-sysv4*)			fmt=elf em=svr4 ;;
diff -u -r -N binutils-2.18/gas/Makefile.am binutils-2.18-s12x/gas/Makefile.am
--- binutils-2.18/gas/Makefile.am	2007-08-28 18:19:35.000000000 +0100
+++ binutils-2.18-s12x/gas/Makefile.am	2008-02-26 21:50:41.000000000 +0000
@@ -67,7 +67,7 @@
 	m32c \
 	m32r \
 	m68hc11 \
-	m68k \
+ 	m68k \
 	maxq \
 	mcore \
 	mep \
diff -u -r -N binutils-2.18/gas/Makefile.in binutils-2.18-s12x/gas/Makefile.in
--- binutils-2.18/gas/Makefile.in	2007-08-28 18:19:35.000000000 +0100
+++ binutils-2.18-s12x/gas/Makefile.in	2008-02-25 21:20:27.000000000 +0000
@@ -312,7 +312,7 @@
 	m32c \
 	m32r \
 	m68hc11 \
-	m68k \
+  	m68k \
 	maxq \
 	mcore \
 	mep \
diff -u -r -N binutils-2.18/include/dis-asm.h binutils-2.18-s12x/include/dis-asm.h
--- binutils-2.18/include/dis-asm.h	2007-08-06 20:59:46.000000000 +0100
+++ binutils-2.18-s12x/include/dis-asm.h	2008-03-20 20:45:54.000000000 +0000
@@ -247,6 +247,8 @@
 extern int print_insn_m32r		(bfd_vma, disassemble_info *);
 extern int print_insn_m68hc11		(bfd_vma, disassemble_info *);
 extern int print_insn_m68hc12		(bfd_vma, disassemble_info *);
+extern int print_insn_m9s12x		(bfd_vma, disassemble_info *);
+extern int print_insn_m9s12xg		(bfd_vma, disassemble_info *);
 extern int print_insn_m68k		(bfd_vma, disassemble_info *);
 extern int print_insn_m88k		(bfd_vma, disassemble_info *);
 extern int print_insn_maxq_big		(bfd_vma, disassemble_info *);
diff -u -r -N binutils-2.18/include/elf/common.h binutils-2.18-s12x/include/elf/common.h
--- binutils-2.18/include/elf/common.h	2007-08-28 18:19:40.000000000 +0100
+++ binutils-2.18-s12x/include/elf/common.h	2008-03-21 13:53:22.000000000 +0000
@@ -189,6 +189,8 @@
 #define EM_CR16		115	/* National Semiconductor CompactRISC - CR16 */
 #define EM_SCORE        135     /* Sunplus Score */
 
+#define EM_M9S12XG 0xb001 /* "random" number for Freescale 9S12X-XGATE */
+
 /* If it is necessary to assign new unofficial EM_* values, please pick large
    random numbers (0x8523, 0xa7f2, etc.) to minimize the chances of collision
    with official or non-GNU unofficial values.
diff -u -r -N binutils-2.18/include/elf/m68hc11.h binutils-2.18-s12x/include/elf/m68hc11.h
--- binutils-2.18/include/elf/m68hc11.h	2005-05-10 11:21:10.000000000 +0100
+++ binutils-2.18-s12x/include/elf/m68hc11.h	2009-10-08 18:09:32.000000000 +0100
@@ -41,6 +41,7 @@
   RELOC_NUMBER (R_M68HC11_24, 11)
   RELOC_NUMBER (R_M68HC11_LO16, 12)
   RELOC_NUMBER (R_M68HC11_PAGE, 13)
+  RELOC_NUMBER (R_M68HC11_HI8_16, 14)
 
      /* GNU extension for linker relaxation.
         Mark beginning of a jump instruction (any form).  */
diff -u -r -N binutils-2.18/include/elf/m9s12xg.h binutils-2.18-s12x/include/elf/m9s12xg.h
--- binutils-2.18/include/elf/m9s12xg.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.18-s12x/include/elf/m9s12xg.h	2009-10-08 18:12:05.000000000 +0100
@@ -0,0 +1,98 @@
+/* m68hcs12xgate & m68hc12 ELF support for BFD.
+   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _ELF_M9S12XG_H
+#define _ELF_M9S12XG_H
+
+#include "elf/reloc-macros.h"
+
+/* Relocation types.  */
+START_RELOC_NUMBERS (elf_m9s12xg_reloc_type)
+  RELOC_NUMBER (R_M68HC11_NONE, 0)
+  RELOC_NUMBER (R_M68HC11_8, 1)
+  RELOC_NUMBER (R_M68HC11_HI8, 2)
+  RELOC_NUMBER (R_M68HC11_LO8, 3)
+  RELOC_NUMBER (R_M68HC11_PCREL_8, 4)
+  RELOC_NUMBER (R_M68HC11_16, 5)
+  RELOC_NUMBER (R_M68HC11_32, 6)
+  RELOC_NUMBER (R_M68HC11_3B, 7)
+  RELOC_NUMBER (R_M68HC11_PCREL_16, 8)
+
+     /* These are GNU extensions to enable C++ vtable garbage collection.  */
+  RELOC_NUMBER (R_M68HC11_GNU_VTINHERIT, 9)
+  RELOC_NUMBER (R_M68HC11_GNU_VTENTRY, 10)
+
+  RELOC_NUMBER (R_M68HC11_24, 11)
+  RELOC_NUMBER (R_M68HC11_LO16, 12)
+  RELOC_NUMBER (R_M68HC11_PAGE, 13)
+  RELOC_NUMBER (R_M68HC11_HI8_16, 14)
+  RELOC_NUMBER (R_M68XG_PCREL_9, 15)
+  RELOC_NUMBER (R_M68XG_PCREL_10, 16)
+
+     /* GNU extension for linker relaxation.
+        Mark beginning of a jump instruction (any form).  */
+  RELOC_NUMBER (R_M68HC11_RL_JUMP, 20)
+
+     /* Mark beginning of Gcc relaxation group instruction.  */
+  RELOC_NUMBER (R_M68HC11_RL_GROUP, 21)
+END_RELOC_NUMBERS (R_M68HC11_max)
+
+/* Processor specific flags for the ELF header e_flags field.  */
+
+/* ABI identification.  */
+#define EF_M9S12XG_ABI  0x00000000F
+
+/* Integers are 32-bit long.  */
+#define E_M9S12XG_I32   0x000000001
+
+/* Doubles are 64-bit long.  */
+#define E_M9S12XG_F64   0x000000002
+
+/* Uses 68HC12 memory banks.  */
+#define E_M68HC12_BANKS 0x000000004
+
+#define EF_M9S12XG_MACH_MASK 0xF0
+#define EF_M9S12XG_GENERIC   0x00 /* Generic 68HC12/backward compatibility.  */
+#define EF_M68HC12_MACH      0x10 /* 68HC12 microcontroller.  */
+#define EF_M68HCS12_MACH     0x20 /* 68HCS12 microcontroller.  */
+#define EF_M9S12XG_MACH(mach) ((mach) & EF_M9S12XG_MACH_MASK)
+
+/* True if we can merge machines.  A generic HC12 can work on any proc
+   but once we have specific code, merge is not possible.  */
+#define EF_M9S12XG_CAN_MERGE_MACH(mach1, mach2) \
+  ((EF_M9S12XG_MACH (mach1) == EF_M9S12XG_MACH (mach2)) \
+   || (EF_M9S12XG_MACH (mach1) == EF_M9S12XG_GENERIC) \
+   || (EF_M9S12XG_MACH (mach2) == EF_M9S12XG_GENERIC))
+
+#define EF_M9S12XG_MERGE_MACH(mach1, mach2) \
+  (((EF_M9S12XG_MACH (mach1) == EF_M9S12XG_MACH (mach2)) \
+    || (EF_M9S12XG_MACH (mach1) == EF_M9S12XG_GENERIC)) ? \
+      EF_M9S12XG_MACH (mach2) : EF_M9S12XG_MACH (mach1))
+
+
+/* Special values for the st_other field in the symbol table.  These
+   are used for 68HC12 to identify far functions (must be called with
+   'call' and returns with 'rtc').  */
+#define STO_M68HC12_FAR 0x80
+
+/* Identify interrupt handlers.  This is used by the debugger to
+   correctly compute the stack frame.  */
+#define STO_M68HC12_INTERRUPT 0x40
+     
+#endif
diff -u -r -N binutils-2.18/include/opcode/m68hc11.h binutils-2.18-s12x/include/opcode/m68hc11.h
--- binutils-2.18/include/opcode/m68hc11.h	2005-05-10 11:21:12.000000000 +0100
+++ binutils-2.18-s12x/include/opcode/m68hc11.h	2008-03-02 14:30:42.000000000 +0000
@@ -362,6 +362,32 @@
 #define M6812_INDEXED_IND     0x10000000 /* [n,r]  n = 16-bits		    */
 #define M6812_INDEXED         0x20000000 /* n,r    n = 5, 9 or 16-bits	    */
 #define M6812_OP_IDX_P2       0x40000000
+#define M6812_OP_IDX1_P2      0x80000000
+/* these won't work - need new method */
+#define M6812_OP_IDX1_P2      0x80000000
+#define M6812_OP_IDX2_P2      0x80000000
+#define M6812_OP_D_IDX_P2     0x80000000
+#define M6812_OP_D_IDX2_P2    0x80000000
+
+/* XGATE defines
+ * these overlap with HC11/12 as above but not used at the same time */
+#define M68XG_OP_NONE           0x0001
+#define M68XG_OP_IMM3           0x0002
+#define M68XG_OP_R              0x0004
+#define M68XG_OP_R_R            0x0008
+#define M68XG_OP_R_IMM4         0x0010
+#define M68XG_OP_R_R_R          0x0020
+#define M68XG_OP_REL9           0x0040
+#define M68XG_OP_REL10          0x0080
+#define M68XG_OP_R_R_OFFS5      0x0100
+#define M68XG_OP_RD_RB_RI       0x0200
+#define M68XG_OP_RD_RB_RIp      0x0400
+#define M68XG_OP_RD_RB_mRI      0x0800
+#define M68XG_OP_R_IMM8         0x1000
+#define M68XG_OP_R_IMM16        0x2000
+#define M68XG_OP_REG            0x4000   /* Register operand 1                 */
+#define M68XG_OP_REG_2          0x8000   /* Register operand 2                 */
+#define M68XG_MAX_OPERANDS      3     /* Max operands of triadic r1, r2, r3 */
 
 /* Markers to identify some instructions.  */
 #define M6812_OP_EXG_MARKER   0x01000000 /* exg r1,r2 */
@@ -373,6 +399,10 @@
 #define M6812_OP_IBCC_MARKER  0x02000000 /* ibeq/ibne */
 #define M6812_OP_TBCC_MARKER  0x01000000
 
+/* XGATE markers */
+#define M68XG_OP_B_MARKER     0x04000000 /* bXX rel9 */
+#define M68XG_OP_BRA_MARKER   0x02000000 /* bra rel10 */
+
 #define M6812_OP_TRAP_ID      0x80000000 /* trap #N */
 
 #define M6811_OP_HIGH_ADDR    0x01000000 /* Used internally by gas.  */
@@ -389,19 +419,22 @@
 #define cpu6811 0x01
 #define cpu6812 0x02
 #define cpu6812s 0x04
+#define cpu9s12x 0x08 /* 9S12X main cpu*/
+#define cpuxgate 0x10  /* The XGATE module itself */
 
 /* The opcode table is an array of struct m68hc11_opcode.  */
 struct m68hc11_opcode {
   const char*    name;     /* Op-code name */
   long           format;
   unsigned char  size;
-  unsigned char  opcode;
+  unsigned int  opcode;
   unsigned char  cycles_low;
   unsigned char  cycles_high;
   unsigned char  set_flags_mask;
   unsigned char  clr_flags_mask;
   unsigned char  chg_flags_mask;
   unsigned char  arch;
+  unsigned int   xg_mask; /* mask with zero in register place for xgate*/
 };
 
 /* Alias definition for 68HC12.  */
diff -u -r -N binutils-2.18/include/opcode/m9s12xg.h binutils-2.18-s12x/include/opcode/m9s12xg.h
--- binutils-2.18/include/opcode/m9s12xg.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.18-s12x/include/opcode/m9s12xg.h	2008-03-20 20:46:14.000000000 +0000
@@ -0,0 +1,121 @@
+/* m68hcs12xgate.h -- Header file for Motorola 68HCS12XGATE & 68HC12 opcode table
+   Copyright 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
+   Written by Stephane Carrez (stcarrez@nerim.fr)
+
+This file is part of GDB, GAS, and the GNU binutils.
+
+GDB, GAS, and the GNU binutils are free software; you can redistribute
+them and/or modify them under the terms of the GNU General Public
+License as published by the Free Software Foundation; either version
+1, or (at your option) any later version.
+
+GDB, GAS, and the GNU binutils are distributed in the hope that they
+will be useful, but WITHOUT ANY WARRANTY; without even the implied
+warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this file; see the file COPYING.  If not, write to the Free
+Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _OPCODE_M9S12XG_H
+#define _OPCODE_M9S12XG_H
+
+/* Flags for the definition of the 68HCS12XGATE & 68HC12 CCR.  */
+#define M6811_S_BIT     0x80	/* Stop disable */
+#define M6811_X_BIT     0x40	/* X-interrupt mask */
+#define M6811_H_BIT     0x20	/* Half carry flag */
+#define M6811_I_BIT     0x10	/* I-interrupt mask */
+#define M6811_N_BIT     0x08	/* Negative */
+#define M6811_Z_BIT     0x04	/* Zero */
+#define M6811_V_BIT     0x02	/* Overflow */
+#define M6811_C_BIT     0x01	/* Carry */
+
+/* Removed register definitions
+*/
+
+
+/* Some insns used by gas to turn relative branches into absolute ones.  */
+#define M6811_BRA	0x20
+#define M6811_JMP	0x7e
+#define M6811_BSR	0x8d
+#define M6811_JSR	0xbd
+#define M6812_JMP       0x06
+#define M6812_BSR       0x07
+#define M6812_JSR       0x16
+
+/* Instruction code pages. Code page 1 is the default.  */
+/*#define	M6811_OPCODE_PAGE1	0x00*/
+#define	M6811_OPCODE_PAGE2	0x18
+#define	M6811_OPCODE_PAGE3	0x1A
+#define	M6811_OPCODE_PAGE4	0xCD
+
+
+/* 68HCS12XGATE operands formats as stored in the m6811_opcode table.  These
+   flags do not correspond to anything in the 68HCS12XGATE or 68HC12.
+   They are only used by GAS to recognize operands.  */
+
+#define M68XG_OP_NONE           0x0001
+#define M68XG_OP_IMM3           0x0002
+#define M68XG_OP_R              0x0004
+#define M68XG_OP_R_R            0x0008
+#define M68XG_OP_R_IMM4         0x0010
+#define M68XG_OP_R_R_R          0x0020
+#define M68XG_OP_REL9           0x0040
+#define M68XG_OP_REL10          0x0080
+#define M68XG_OP_R_R_OFFS5      0x0100
+#define M68XG_OP_RD_RB_RI       0x0200
+#define M68XG_OP_RD_RB_RIp      0x0400
+#define M68XG_OP_RD_RB_mRI      0x0800
+#define M68XG_OP_R_IMM8         0x1000
+#define M68XG_OP_R_IMM16        0x2000
+#define M68XG_OP_REG            0x10000   /* Register operand 1                 */
+#define M68XG_OP_REG_2          0x20000   /* Register operand 2                 */
+#define M68XG_MAX_OPERANDS      3     /* Max operands of triadic r1, r2, r3 */
+
+
+// probably want to scrub all of these
+#define M6811_OP_BRANCH       0x00008000 /* Branch, jsr, call */
+#define M6811_OP_BITMASK      0x00010000 /* Bitmask:             #<val-8>    */
+
+/* Markers to identify some instructions.  */
+#define M6812_OP_EXG_MARKER   0x01000000 /* exg r1,r2 */
+#define M6812_OP_TFR_MARKER   0x02000000 /* tfr r1,r2 */
+#define M6812_OP_SEX_MARKER   0x04000000 /* sex r1,r2 */
+
+#define M68XG_OP_B_MARKER    0x04000000 /* bXX rel9 */
+#define M68XG_OP_BRA_MARKER  0x02000000 /* bra rel10 */
+
+#define M6812_OP_TRAP_ID      0x80000000 /* trap #N */
+
+#define M6811_OP_HIGH_ADDR    0x01000000 /* Used internally by gas.  */
+#define M6811_OP_LOW_ADDR     0x02000000
+
+#define M68HC12_BANK_VIRT 0x010000
+#define M68HC12_BANK_MASK 0x00003fff
+#define M68HC12_BANK_BASE 0x00008000
+#define M68HC12_BANK_SHIFT 14
+#define M68HC12_BANK_PAGE_MASK 0x0ff
+
+
+/* CPU identification.  */
+#define cpu6811 0x01
+#define cpu6812 0x02
+#define cpu6812s 0x04
+#define cpu9s12xe 0x08
+#define cpu9s12xgate 0x10
+
+/* The opcode table is an array of struct m68hcs12xgate_opcode.  */
+struct m68hcs12xgate_opcode {
+  const char*    name;     /* Op-code name */
+  long           format;
+  unsigned int   opcode; // base opcode with zero in register place
+  unsigned int   opcode_mask; // mask with zero in register place
+};
+
+/* The opcode table.  The table contains all the opcodes (all pages).
+   You can't rely on the order.  */
+extern const struct m68hcs12xgate_opcode m68hcs12xgate_opcodes[];
+extern const int m68hcs12xgate_num_opcodes;
+
+#endif /* _OPCODE_M9S12XG_H */
diff -u -r -N binutils-2.18/ld/configure.tgt binutils-2.18-s12x/ld/configure.tgt
--- binutils-2.18/ld/configure.tgt	2007-08-28 18:19:42.000000000 +0100
+++ binutils-2.18-s12x/ld/configure.tgt	2008-03-21 14:14:05.000000000 +0000
@@ -307,6 +307,8 @@
 			targ_extra_emuls="m68hc11elfb m68hc12elf m68hc12elfb" ;;
 m68hc12-*-*|m6812-*-*)	targ_emul=m68hc12elf 
 			targ_extra_emuls="m68hc12elfb m68hc11elf m68hc11elfb" ;;
+m9s12x-*-*)		targ_emul=m68hc12elf 
+                        targ_extra_emuls="m9s12xgelf m9s12xgelfb m68hc12elf m68hc12elfb m68hc11elf m68hc11elfb" ;; 
 m68*-sun-sunos[34]*)	targ_emul=sun3 ;;
 m68*-wrs-vxworks*)	targ_emul=sun3 ;;
 m68*-ericsson-ose)	targ_emul=sun3 ;;
diff -u -r -N binutils-2.18/ld/emulparams/m9s12xgelfb.sh binutils-2.18-s12x/ld/emulparams/m9s12xgelfb.sh
--- binutils-2.18/ld/emulparams/m9s12xgelfb.sh	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.18-s12x/ld/emulparams/m9s12xgelfb.sh	2008-03-20 20:47:12.000000000 +0000
@@ -0,0 +1,12 @@
+MACHINE=
+SCRIPT_NAME=elfm9s12xg
+OUTPUT_FORMAT="elf32-m68hc12"
+TEXT_MEMORY=text
+DATA_MEMORY=data
+EEPROM_MEMORY=eeprom
+ARCH=m9s12xg
+MAXPAGESIZE=32
+GENERIC_BOARD=yes
+TEMPLATE_NAME=elf32
+EXTRA_EM_FILE=m9s12xgelf
+
diff -u -r -N binutils-2.18/ld/emulparams/m9s12xgelf.sh binutils-2.18-s12x/ld/emulparams/m9s12xgelf.sh
--- binutils-2.18/ld/emulparams/m9s12xgelf.sh	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.18-s12x/ld/emulparams/m9s12xgelf.sh	2008-03-20 20:47:26.000000000 +0000
@@ -0,0 +1,18 @@
+MACHINE=
+SCRIPT_NAME=elfm9s12xg
+OUTPUT_FORMAT="elf32-m68hc12"
+ROM_START_ADDR=0x08000
+ROM_SIZE=0x8000
+RAM_START_ADDR=0x01100
+RAM_SIZE=0x6F00
+EEPROM_START_ADDR=0xb600
+EEPROM_SIZE=512
+TEXT_MEMORY=text
+DATA_MEMORY=data
+EEPROM_MEMORY=eeprom
+ARCH=m9s12xg
+MAXPAGESIZE=32
+EMBEDDED=yes
+GENERIC_BOARD=no
+TEMPLATE_NAME=elf32
+EXTRA_EM_FILE=m9s12xgelf
diff -u -r -N binutils-2.18/ld/emultempl/m9s12xgelf.em binutils-2.18-s12x/ld/emultempl/m9s12xgelf.em
--- binutils-2.18/ld/emultempl/m9s12xgelf.em	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.18-s12x/ld/emultempl/m9s12xgelf.em	2008-03-20 20:48:12.000000000 +0000
@@ -0,0 +1,376 @@
+# This shell script emits a C file. -*- C -*-
+#   Copyright 1991, 1993, 1994, 1997, 1999, 2000, 2001, 2002, 2003, 2007
+#   Free Software Foundation, Inc.
+#
+# This file is part of the GNU Binutils.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+# MA 02110-1301, USA.
+#
+
+# This file is sourced from elf32.em, and defines extra m68hc12-elf
+# and m68hc11-elf specific routines.  It is used to generate the
+# HC11/HC12 trampolines to call a far function by using a normal 'jsr/bsr'.
+#
+# - The HC11/HC12 relocations are checked to see if there is a
+#   R_M68HC11_16 relocation to a symbol marked with STO_M68HC12_FAR.
+#   This relocation cannot be made on the symbol but must be made on
+#   its trampoline
+#   The trampolines to generate are collected during this pass
+#   (See elf32_m68hc11_size_stubs)
+#
+# - The trampolines are generated in a ".tramp" section.  The generation
+#   takes care of HC11 and HC12 specificities.
+#   (See elf32_m68hc11_build_stubs)
+#
+# - During relocation the R_M68HC11_16 relocation to the far symbols
+#   are redirected to the trampoline that was generated.
+#
+# Copied from hppaelf and adapted for M68HC11/M68HC12 specific needs.
+#
+fragment <<EOF
+
+#include "ldctor.h"
+#include "elf32-m9s12xg.h"
+
+static asection *m9s12xgelf_add_stub_section (const char *, asection *);
+
+/* Fake input file for stubs.  */
+static lang_input_statement_type *stub_file;
+
+/* By default the HC11/HC12 trampolines to call a far function using
+   a normal 'bsr' and 'jsr' convention are generated during the link.
+   The --no-trampoline option prevents that.  */
+static int no_trampoline = 0;
+
+/* Name of memory bank window in the MEMORY description.
+   This is set by --bank-window option.  */
+static const char* bank_window_name = 0;
+
+static void
+m9s12xg_elf_${EMULATION_NAME}_before_allocation (void)
+{
+  lang_memory_region_type* region;
+  int ret;
+
+  gld${EMULATION_NAME}_before_allocation ();
+
+  /* If generating a relocatable output file, then we don't
+     have to generate the trampolines.  */
+  if (link_info.relocatable)
+    return;
+
+  ret = elf32_m9s12xg_setup_section_lists (output_bfd, &link_info);
+  if (ret != 0 && no_trampoline == 0)
+    {
+      if (ret < 0)
+	{
+	  einfo ("%X%P: can not size stub section: %E\n");
+	  return;
+	}
+
+      /* Call into the BFD backend to do the real work.  */
+      if (!elf32_m9s12xg_size_stubs (output_bfd,
+				     stub_file->the_bfd,
+				     &link_info,
+				     &m9s12xgelf_add_stub_section))
+	{
+	  einfo ("%X%P: can not size stub section: %E\n");
+	  return;
+	}
+    }
+
+  if (bank_window_name == 0)
+    return;
+
+  /* The 'bank_window_name' memory region is a special region that describes
+     the memory bank window to access to paged memory.  For 68HC12
+     this is fixed and should be:
+
+     window (rx) : ORIGIN = 0x8000, LENGTH = 16K
+
+     But for 68HC11 this is board specific.  The definition of such
+     memory region allows to control how this paged memory is accessed.  */
+  region = lang_memory_region_lookup (bank_window_name, FALSE);
+
+  /* Check the length to see if it was defined in the script.  */
+  if (region->length != 0)
+    {
+      struct m9s12xg_page_info *pinfo;
+      unsigned i;
+
+      /* Get default values  */
+      m9s12xg_elf_get_bank_parameters (&link_info);
+      pinfo = &m9s12xg_elf_hash_table (&link_info)->pinfo;
+
+      /* And override them with the region definition.  */
+      pinfo->bank_size = region->length;
+      pinfo->bank_shift = 0;
+      for (i = pinfo->bank_size; i != 0; i >>= 1)
+	pinfo->bank_shift++;
+      pinfo->bank_shift--;
+      pinfo->bank_size = 1L << pinfo->bank_shift;
+      pinfo->bank_mask = (1 << pinfo->bank_shift) - 1;
+      pinfo->bank_physical = region->origin;
+      pinfo->bank_physical_end = region->origin + pinfo->bank_size;
+
+      if (pinfo->bank_size != region->length)
+	{
+	  einfo (_("warning: the size of the 'window' memory region "
+		   "is not a power of 2\n"));
+	  einfo (_("warning: its size %d is truncated to %d\n"),
+		 region->length, pinfo->bank_size);
+	}
+    }
+}
+
+/* This is called before the input files are opened.  We create a new
+   fake input file to hold the stub sections.  */
+
+static void
+m9s12xgelf_create_output_section_statements (void)
+{
+  stub_file = lang_add_input_file ("linker stubs",
+				   lang_input_file_is_fake_enum,
+				   NULL);
+  stub_file->the_bfd = bfd_create ("linker stubs", output_bfd);
+  if (stub_file->the_bfd == NULL
+      || !bfd_set_arch_mach (stub_file->the_bfd,
+			     bfd_get_arch (output_bfd),
+			     bfd_get_mach (output_bfd)))
+    {
+      einfo ("%X%P: can not create BFD %E\n");
+      return;
+    }
+
+  ldlang_add_file (stub_file);
+}
+
+
+struct hook_stub_info
+{
+  lang_statement_list_type add;
+  asection *input_section;
+};
+
+/* Traverse the linker tree to find the spot where the stub goes.  */
+
+static bfd_boolean
+hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)
+{
+  lang_statement_union_type *l;
+  bfd_boolean ret;
+
+  for (; (l = *lp) != NULL; lp = &l->header.next)
+    {
+      switch (l->header.type)
+	{
+	case lang_constructors_statement_enum:
+	  ret = hook_in_stub (info, &constructor_list.head);
+	  if (ret)
+	    return ret;
+	  break;
+
+	case lang_output_section_statement_enum:
+	  ret = hook_in_stub (info,
+			      &l->output_section_statement.children.head);
+	  if (ret)
+	    return ret;
+	  break;
+
+	case lang_wild_statement_enum:
+	  ret = hook_in_stub (info, &l->wild_statement.children.head);
+	  if (ret)
+	    return ret;
+	  break;
+
+	case lang_group_statement_enum:
+	  ret = hook_in_stub (info, &l->group_statement.children.head);
+	  if (ret)
+	    return ret;
+	  break;
+
+	case lang_input_section_enum:
+	  if (l->input_section.section == info->input_section
+	      || strcmp (bfd_get_section_name (output_section,
+					       l->input_section.section),
+			 bfd_get_section_name (output_section,
+					       info->input_section)) == 0)
+	    {
+	      /* We've found our section.  Insert the stub immediately
+		 before its associated input section.  */
+	      *lp = info->add.head;
+	      *(info->add.tail) = l;
+	      return TRUE;
+	    }
+	  break;
+
+	case lang_data_statement_enum:
+	case lang_reloc_statement_enum:
+	case lang_object_symbols_statement_enum:
+	case lang_output_statement_enum:
+	case lang_target_statement_enum:
+	case lang_input_statement_enum:
+	case lang_assignment_statement_enum:
+	case lang_padding_statement_enum:
+	case lang_address_statement_enum:
+	case lang_fill_statement_enum:
+	  break;
+
+	default:
+	  FAIL ();
+	  break;
+	}
+    }
+  return FALSE;
+}
+
+
+/* Call-back for elf32_m68hc11_size_stubs.  */
+
+/* Create a new stub section, and arrange for it to be linked
+   immediately before INPUT_SECTION.  */
+
+static asection *
+m9s12xgelf_add_stub_section (const char *stub_sec_name,
+			     asection *tramp_section)
+{
+  asection *stub_sec;
+  flagword flags;
+  asection *output_section;
+  const char *secname;
+  lang_output_section_statement_type *os;
+  struct hook_stub_info info;
+
+  stub_sec = bfd_make_section_anyway (stub_file->the_bfd, stub_sec_name);
+  if (stub_sec == NULL)
+    goto err_ret;
+
+  flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
+	   | SEC_HAS_CONTENTS | SEC_RELOC | SEC_IN_MEMORY | SEC_KEEP);
+  if (!bfd_set_section_flags (stub_file->the_bfd, stub_sec, flags))
+    goto err_ret;
+
+  output_section = tramp_section->output_section;
+  secname = bfd_get_section_name (output_section->owner, output_section);
+  os = lang_output_section_find (secname);
+
+  /* Try to put the new section at the same place as an existing
+     .tramp section.  Such .tramp section exists in most cases and
+     contains the trampoline code.  This way we put the generated trampoline
+     at the correct place.  */
+  info.input_section = tramp_section;
+  lang_list_init (&info.add);
+  lang_add_section (&info.add, stub_sec, os);
+
+  if (info.add.head == NULL)
+    goto err_ret;
+
+  if (hook_in_stub (&info, &os->children.head))
+    return stub_sec;
+
+ err_ret:
+  einfo ("%X%P: can not make stub section: %E\n");
+  return NULL;
+}
+
+/* Final emulation specific call.  For the 68HC12 we use this opportunity
+   to build linker stubs.  */
+
+static void
+m9s12xgelf_finish (void)
+{
+  /* Now build the linker stubs.  */
+  if (stub_file->the_bfd->sections != NULL)
+    {
+      /* Call again the trampoline analyzer to initialize the trampoline
+	 stubs with the correct symbol addresses.  Since there could have
+	 been relaxation, the symbol addresses that were found during
+	 first call may no longer be correct.  */
+      if (!elf32_m9s12xg_size_stubs (output_bfd,
+				     stub_file->the_bfd,
+				     &link_info, 0))
+	{
+	  einfo ("%X%P: can not size stub section: %E\n");
+	  return;
+	}
+      if (!elf32_m9s12xg_build_stubs (output_bfd, &link_info))
+	einfo ("%X%P: can not build stubs: %E\n");
+    }
+
+  gld${EMULATION_NAME}_finish ();
+}
+
+
+/* Avoid processing the fake stub_file in vercheck, stat_needed and
+   check_needed routines.  */
+
+static void (*real_func) (lang_input_statement_type *);
+
+static void m9s12xg_for_each_input_file_wrapper (lang_input_statement_type *l)
+{
+  if (l != stub_file)
+    (*real_func) (l);
+}
+
+static void
+m9s12xg_lang_for_each_input_file (void (*func) (lang_input_statement_type *))
+{
+  real_func = func;
+  lang_for_each_input_file (&m9s12xg_for_each_input_file_wrapper);
+}
+
+#define lang_for_each_input_file m9s12xg_lang_for_each_input_file
+
+EOF
+
+# Define some shell vars to insert bits of code into the standard elf
+# parse_args and list_options functions.
+#
+PARSE_AND_LIST_PROLOGUE='
+#define OPTION_NO_TRAMPOLINE		300
+#define OPTION_BANK_WINDOW		301
+'
+
+# The options are repeated below so that no abbreviations are allowed.
+# Otherwise -s matches stub-group-size
+PARSE_AND_LIST_LONGOPTS='
+  { "no-trampoline", no_argument, NULL, OPTION_NO_TRAMPOLINE },
+  { "bank-window",   required_argument, NULL, OPTION_BANK_WINDOW },
+'
+
+PARSE_AND_LIST_OPTIONS='
+  fprintf (file, _(""
+"  --no-trampoline         Do not generate the far trampolines used to call\n"
+"                          a far function using 'jsr' or 'bsr'.\n"
+"  --bank-window NAME      Specify the name of the memory region describing\n"
+"                          the layout of the memory bank window.\n"
+		   ));
+'
+
+PARSE_AND_LIST_ARGS_CASES='
+    case OPTION_NO_TRAMPOLINE:
+      no_trampoline = 1;
+      break;
+    case OPTION_BANK_WINDOW:
+      bank_window_name = optarg;
+      break;
+'
+
+# Put these extra m9s12xgelf routines in ld_${EMULATION_NAME}_emulation
+#
+LDEMUL_BEFORE_ALLOCATION=m9s12xg_elf_${EMULATION_NAME}_before_allocation
+LDEMUL_FINISH=m9s12xgelf_finish
+LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS=m9s12xgelf_create_output_section_statements
diff -u -r -N binutils-2.18/ld/Makefile.am binutils-2.18-s12x/ld/Makefile.am
--- binutils-2.18/ld/Makefile.am	2007-08-06 21:00:17.000000000 +0100
+++ binutils-2.18-s12x/ld/Makefile.am	2008-03-20 20:47:00.000000000 +0000
@@ -259,6 +259,8 @@
 	em68hc11elfb.o \
 	em68hc12elf.o \
 	em68hc12elfb.o \
+	em9s12xgelf.o \
+	em9s12xgelfb.o \
 	em68k4knbsd.o \
 	em68kaout.o \
 	em68kaux.o \
@@ -1170,6 +1172,14 @@
   $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
   $(srcdir)/scripttempl/elfm68hc12.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} m68hc12elfb "$(tdir_m68hc12b)"
+em9s12xgelf.c: $(srcdir)/emulparams/m9s12xgelf.sh \
+  $(srcdir)/emultempl/m9s12xgateelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm9s12xg.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m9s12xgelf "$(tdir_m9s12xg)"
+em68hc12elfb.c: $(srcdir)/emulparams/m9s12xgelfb.sh \
+  $(srcdir)/emultempl/m9s12xgelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm9s12xg.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m9s12xgelfb "$(tdir_m68hcx12xgateb)"
 em68k4knbsd.c:	$(srcdir)/emulparams/m68k4knbsd.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} m68k4knbsd "$(tdir_m68k4knbsd)"
diff -u -r -N binutils-2.18/ld/Makefile.in binutils-2.18-s12x/ld/Makefile.in
--- binutils-2.18/ld/Makefile.in	2007-08-06 21:29:54.000000000 +0100
+++ binutils-2.18-s12x/ld/Makefile.in	2008-03-20 20:48:26.000000000 +0000
@@ -506,6 +506,8 @@
 	em68hc11elfb.o \
 	em68hc12elf.o \
 	em68hc12elfb.o \
+	em9s12xgelf.o \
+	em9s12xgelfb.o \
 	em68k4knbsd.o \
 	em68kaout.o \
 	em68kaux.o \
@@ -1996,6 +1998,14 @@
   $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
   $(srcdir)/scripttempl/elfm68hc12.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} m68hc12elfb "$(tdir_m68hc12b)"
+em9s12xgelf.c: $(srcdir)/emulparams/m9s12xgelf.sh \
+  $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm9s12xg.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m9s12xgelf "$(tdir_m9s12xg)"
+em9s12xgelfb.c: $(srcdir)/emulparams/m9s12xgelfb.sh \
+  $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm9s12xg.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m9s12xgelfb "$(tdir_m9s12xgb)"
 em68k4knbsd.c:	$(srcdir)/emulparams/m68k4knbsd.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} m68k4knbsd "$(tdir_m68k4knbsd)"
diff -u -r -N binutils-2.18/ld/scripttempl/elfm9s12xg.sc binutils-2.18-s12x/ld/scripttempl/elfm9s12xg.sc
--- binutils-2.18/ld/scripttempl/elfm9s12xg.sc	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.18-s12x/ld/scripttempl/elfm9s12xg.sc	2008-02-08 23:23:59.000000000 +0000
@@ -0,0 +1,460 @@
+#
+# Unusual variables checked by this code:
+#	NOP - four byte opcode for no-op (defaults to 0)
+#	DATA_ADDR - if end-of-text-plus-one-page isn't right for data start
+#	OTHER_READWRITE_SECTIONS - other than .data .bss .ctors .sdata ...
+#		(e.g., .PARISC.global)
+#	OTHER_SECTIONS - at the end
+#	EXECUTABLE_SYMBOLS - symbols that must be defined for an
+#		executable (e.g., _DYNAMIC_LINK)
+#	TEXT_START_SYMBOLS - symbols that appear at the start of the
+#		.text section.
+#	DATA_START_SYMBOLS - symbols that appear at the start of the
+#		.data section.
+#	OTHER_BSS_SYMBOLS - symbols that appear at the start of the
+#		.bss section besides __bss_start.
+#	EMBEDDED - whether this is for an embedded system. 
+#
+# When adding sections, do note that the names of some sections are used
+# when specifying the start address of the next.
+#
+test -z "$ENTRY" && ENTRY=_start
+test -z "${BIG_OUTPUT_FORMAT}" && BIG_OUTPUT_FORMAT=${OUTPUT_FORMAT}
+test -z "${LITTLE_OUTPUT_FORMAT}" && LITTLE_OUTPUT_FORMAT=${OUTPUT_FORMAT}
+if [ -z "$MACHINE" ]; then OUTPUT_ARCH=${ARCH}; else OUTPUT_ARCH=${ARCH}:${MACHINE}; fi
+test "$LD_FLAG" = "N" && DATA_ADDR=.
+
+CTOR=".ctors ${CONSTRUCTING-0} : 
+  {
+    ${CONSTRUCTING+ PROVIDE (__CTOR_LIST__ = .); }
+    ${CONSTRUCTING+${CTOR_START}}
+    KEEP (*(.ctors))
+
+    ${CONSTRUCTING+${CTOR_END}}
+    ${CONSTRUCTING+ PROVIDE(__CTOR_END__ = .); }
+  } ${RELOCATING+ > ${TEXT_MEMORY}}"
+
+DTOR="  .dtors	${CONSTRUCTING-0} :
+  {
+    ${CONSTRUCTING+ PROVIDE(__DTOR_LIST__ = .); }
+    KEEP (*(.dtors))
+    ${CONSTRUCTING+ PROVIDE(__DTOR_END__ = .); }
+  } ${RELOCATING+ > ${TEXT_MEMORY}}"
+
+
+VECTORS="
+  /* If the 'vectors_addr' symbol is defined, it indicates the start address
+     of interrupt vectors.  This depends on the 68HC11 operating mode:
+
+			Addr
+     Single chip	0xffc0
+     Extended mode	0xffc0
+     Bootstrap		0x00c0
+     Test		0xbfc0
+
+     In general, the vectors address is 0xffc0.  This can be overriden 
+     with the '-defsym vectors_addr=0xbfc0' ld option.
+
+     Note: for the bootstrap mode, the interrupt vectors are at 0xbfc0 but
+     they are redirected to 0x00c0 by the internal PROM.  Application's vectors
+     must also consist of jump instructions (see Motorola's manual).  */
+
+  PROVIDE (_vectors_addr = DEFINED (vectors_addr) ? vectors_addr : 0xffc0);
+  .vectors DEFINED (vectors_addr) ? vectors_addr : 0xffc0 :
+  {
+    KEEP (*(.vectors))
+  }"
+
+#
+# We provide two emulations: a fixed on that defines some memory banks
+# and a configurable one that includes a user provided memory definition.
+#
+case $GENERIC_BOARD in
+  yes|1|YES)
+	MEMORY_DEF="
+/* Get memory banks definition from some user configuration file.
+   This file must be located in some linker directory (search path
+   with -L<dir>). See fixed memory banks emulation script.  */
+INCLUDE memory.x;
+"
+	;;
+  *)
+MEMORY_DEF="
+/* Fixed definition of the available memory banks.
+   See generic emulation script for a user defined configuration.  */
+MEMORY
+{
+  page0 (rwx) : ORIGIN = 0x0, LENGTH = 256
+  text  (rx)  : ORIGIN = ${ROM_START_ADDR}, LENGTH = ${ROM_SIZE}
+  data        : ORIGIN = ${RAM_START_ADDR}, LENGTH = ${RAM_SIZE}
+  eeprom      : ORIGIN = ${EEPROM_START_ADDR}, LENGTH = ${EEPROM_SIZE}
+}
+
+/* Setup the stack on the top of the data memory bank.  */
+PROVIDE (_stack = ${RAM_START_ADDR} + ${RAM_SIZE} - 1);
+"
+	;;
+esac
+
+STARTUP_CODE="
+    /* Startup code.  */
+    KEEP (*(.install0))	/* Section should setup the stack pointer.  */
+    KEEP (*(.install1))	/* Place holder for applications.  */
+    KEEP (*(.install2))	/* Optional installation of data sections in RAM.  */
+    KEEP (*(.install3))	/* Place holder for applications.  */
+    KEEP (*(.install4))	/* Section that calls the main.  */
+"
+
+FINISH_CODE="
+    /* Finish code.  */
+    KEEP (*(.fini0))	/* Beginning of finish code (_exit symbol).  */
+    KEEP (*(.fini1))	/* Place holder for applications.  */
+    KEEP (*(.fini2))	/* C++ destructors.  */
+    KEEP (*(.fini3))	/* Place holder for applications.  */
+    KEEP (*(.fini4))	/* Runtime exit.  */
+"
+
+PRE_COMPUTE_DATA_SIZE="
+/* SCz: this does not work yet... This is supposed to force the loading
+   of _map_data.o (from libgcc.a) when the .data section is not empty.
+   By doing so, this should bring the code that copies the .data section
+   from ROM to RAM at init time.
+
+  ___pre_comp_data_size = SIZEOF(.data);
+  __install_data_sections = ___pre_comp_data_size > 0 ?
+		__map_data_sections : 0;
+*/
+"
+
+INSTALL_RELOC="
+  .install0 0 : { *(.install0) }
+  .install1 0 : { *(.install1) }
+  .install2 0 : { *(.install2) }
+  .install3 0 : { *(.install3) }
+  .install4 0 : { *(.install4) }
+"
+
+FINISH_RELOC="
+  .fini0 0 : { *(.fini0) }
+  .fini1 0 : { *(.fini1) }
+  .fini2 0 : { *(.fini2) }
+  .fini3 0 : { *(.fini3) }
+  .fini4 0 : { *(.fini4) }
+"
+
+BSS_DATA_RELOC="
+  .data1 0 : { *(.data1) }
+
+  /* We want the small data sections together, so single-instruction offsets
+     can access them all, and initialized data all before uninitialized, so
+     we can shorten the on-disk segment size.  */
+  .sdata   0 : { *(.sdata) }
+  .sbss    0 : { *(.sbss) }
+  .scommon 0 : { *(.scommon) }
+"
+
+SOFT_REGS_RELOC="
+  .softregs 0 : { *(.softregs) }
+"
+
+cat <<EOF
+${RELOCATING+/* Linker script for 68HCS12XGATE executable (PROM).  */}
+${RELOCATING-/* Linker script for 68HCS12XGATE object file (ld -r).  */}
+
+OUTPUT_FORMAT("${OUTPUT_FORMAT}", "${BIG_OUTPUT_FORMAT}",
+	      "${LITTLE_OUTPUT_FORMAT}")
+OUTPUT_ARCH(${OUTPUT_ARCH})
+ENTRY(${ENTRY})
+
+${RELOCATING+${LIB_SEARCH_DIRS}}
+${RELOCATING+${EXECUTABLE_SYMBOLS}}
+${RELOCATING+${MEMORY_DEF}}
+
+SECTIONS
+{
+  .hash        ${RELOCATING-0} : { *(.hash)		}
+  .dynsym      ${RELOCATING-0} : { *(.dynsym)		}
+  .dynstr      ${RELOCATING-0} : { *(.dynstr)		}
+  .gnu.version		${RELOCATING-0} : { *(.gnu.version) }
+  .gnu.version_d	${RELOCATING-0} : { *(.gnu.version_d) }
+  .gnu.version_r	${RELOCATING-0} : { *(.gnu.version_r) }
+
+  .rel.text    ${RELOCATING-0} :
+    {
+      *(.rel.text)
+      ${RELOCATING+*(.rel.text.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.t.*)}
+    }
+  .rela.text   ${RELOCATING-0} :
+    {
+      *(.rela.text)
+      ${RELOCATING+*(.rela.text.*)}
+      ${RELOCATING+*(.rela.gnu.linkonce.t.*)}
+    }
+  .rel.data    ${RELOCATING-0} :
+    {
+      *(.rel.data)
+      ${RELOCATING+*(.rel.data.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.d.*)}
+    }
+  .rela.data   ${RELOCATING-0} :
+    {
+      *(.rela.data)
+      ${RELOCATING+*(.rela.data.*)}
+      ${RELOCATING+*(.rela.gnu.linkonce.d.*)}
+    }
+  .rel.rodata  ${RELOCATING-0} :
+    {
+      *(.rel.rodata)
+      ${RELOCATING+*(.rel.rodata.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.r.*)}
+    }
+  .rela.rodata ${RELOCATING-0} :
+    {
+      *(.rela.rodata)
+      ${RELOCATING+*(.rela.rodata.*)}
+      ${RELOCATING+*(.rela.gnu.linkonce.r.*)}
+    }
+  .rel.sdata   ${RELOCATING-0} :
+    {
+      *(.rel.sdata)
+      ${RELOCATING+*(.rel.sdata.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.s.*)}
+    }
+  .rela.sdata   ${RELOCATING-0} :
+    {
+      *(.rela.sdata)
+      ${RELOCATING+*(.rela.sdata.*)}
+      ${RELOCATING+*(.rela.gnu.linkonce.s.*)}
+    }
+  .rel.sbss    ${RELOCATING-0} :
+    { 
+      *(.rel.sbss)
+      ${RELOCATING+*(.rel.sbss.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.sb.*)}
+    }
+  .rela.sbss   ${RELOCATING-0} :
+    {
+      *(.rela.sbss)
+      ${RELOCATING+*(.rela.sbss.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.sb.*)}
+    }
+  .rel.bss     ${RELOCATING-0} : 
+    { 
+      *(.rel.bss)
+      ${RELOCATING+*(.rel.bss.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.b.*)}
+    }
+  .rela.bss    ${RELOCATING-0} : 
+    { 
+      *(.rela.bss)
+      ${RELOCATING+*(.rela.bss.*)}
+      ${RELOCATING+*(.rela.gnu.linkonce.b.*)}
+    }
+  .rel.stext		${RELOCATING-0} : { *(.rel.stest) }
+  .rela.stext		${RELOCATING-0} : { *(.rela.stest) }
+  .rel.etext		${RELOCATING-0} : { *(.rel.etest) }
+  .rela.etext		${RELOCATING-0} : { *(.rela.etest) }
+  .rel.sdata		${RELOCATING-0} : { *(.rel.sdata) }
+  .rela.sdata		${RELOCATING-0} : { *(.rela.sdata) }
+  .rel.edata		${RELOCATING-0} : { *(.rel.edata) }
+  .rela.edata		${RELOCATING-0} : { *(.rela.edata) }
+  .rel.eit_v		${RELOCATING-0} : { *(.rel.eit_v) }
+  .rela.eit_v		${RELOCATING-0} : { *(.rela.eit_v) }
+  .rel.ebss		${RELOCATING-0} : { *(.rel.ebss) }
+  .rela.ebss		${RELOCATING-0} : { *(.rela.ebss) }
+  .rel.srodata		${RELOCATING-0} : { *(.rel.srodata) }
+  .rela.srodata		${RELOCATING-0} : { *(.rela.srodata) }
+  .rel.erodata		${RELOCATING-0} : { *(.rel.erodata) }
+  .rela.erodata		${RELOCATING-0} : { *(.rela.erodata) }
+  .rel.got		${RELOCATING-0} : { *(.rel.got) }
+  .rela.got		${RELOCATING-0} : { *(.rela.got) }
+  .rel.ctors		${RELOCATING-0} : { *(.rel.ctors) }
+  .rela.ctors		${RELOCATING-0} : { *(.rela.ctors) }
+  .rel.dtors		${RELOCATING-0} : { *(.rel.dtors) }
+  .rela.dtors		${RELOCATING-0} : { *(.rela.dtors) }
+  .rel.init		${RELOCATING-0} : { *(.rel.init) }
+  .rela.init		${RELOCATING-0} : { *(.rela.init) }
+  .rel.fini		${RELOCATING-0} : { *(.rel.fini) }
+  .rela.fini		${RELOCATING-0} : { *(.rela.fini) }
+  .rel.plt		${RELOCATING-0} : { *(.rel.plt) }
+  .rela.plt		${RELOCATING-0} : { *(.rela.plt) }
+
+  /* Concatenate .page0 sections.  Put them in the page0 memory bank
+     unless we are creating a relocatable file.  */
+  .page0 :
+  {
+    *(.page0)
+    ${RELOCATING+*(.softregs)}
+  } ${RELOCATING+ > page0}
+
+  /* Start of text section.  */
+  .stext ${RELOCATING-0} : 
+  {
+    *(.stext)
+  } ${RELOCATING+ > ${TEXT_MEMORY}}
+
+  .init	${RELOCATING-0} :
+  {
+    *(.init) 
+  } ${RELOCATING+=${NOP-0}}
+
+  ${RELOCATING-${INSTALL_RELOC}}
+  ${RELOCATING-${FINISH_RELOC}}
+
+  .text ${RELOCATING-0}:
+  {
+    /* Put startup code at beginning so that _start keeps same address.  */
+    ${RELOCATING+${STARTUP_CODE}}
+
+    ${RELOCATING+*(.init)}
+    *(.text)
+    ${RELOCATING+*(.text.*)}
+    /* .gnu.warning sections are handled specially by elf32.em.  */
+    *(.gnu.warning)
+    ${RELOCATING+*(.gnu.linkonce.t.*)}
+    ${RELOCATING+*(.tramp)}
+    ${RELOCATING+*(.tramp.*)}
+
+    ${RELOCATING+${FINISH_CODE}}
+
+    ${RELOCATING+_etext = .;}
+    ${RELOCATING+PROVIDE (etext = .);}
+
+  } ${RELOCATING+ > ${TEXT_MEMORY}}
+
+  .eh_frame ${RELOCATING-0} :
+  {
+    KEEP (*(.eh_frame))
+  } ${RELOCATING+ > ${TEXT_MEMORY}}
+
+  .gcc_except_table ${RELOCATING-0} :
+  {
+    *(.gcc_except_table)
+  } ${RELOCATING+ > ${TEXT_MEMORY}}
+
+  .rodata  ${RELOCATING-0} :
+  {
+    *(.rodata)
+    ${RELOCATING+*(.rodata.*)}
+    ${RELOCATING+*(.gnu.linkonce.r*)}
+  } ${RELOCATING+ > ${TEXT_MEMORY}}
+
+  .rodata1 ${RELOCATING-0} :
+  {
+    *(.rodata1)
+  } ${RELOCATING+ > ${TEXT_MEMORY}}
+
+  /* Constructor and destructor tables are in ROM.  */
+  ${RELOCATING+${CTOR}}
+  ${RELOCATING+${DTOR}}
+
+  .jcr ${RELOCATING-0} :
+  {
+    KEEP (*(.jcr))
+  } ${RELOCATING+ > ${TEXT_MEMORY}}
+
+  /* Start of the data section image in ROM.  */
+  ${RELOCATING+__data_image = .;}
+  ${RELOCATING+PROVIDE (__data_image = .);}
+
+  /* All read-only sections that normally go in PROM must be above.
+     We construct the DATA image section in PROM at end of all these
+     read-only sections.  The data image must be copied at init time.
+     Refer to GNU ld, Section 3.6.8.2 Output Section LMA.  */
+  .data  ${RELOCATING-0} : ${RELOCATING+AT (__data_image)}
+  {
+    ${RELOCATING+__data_section_start = .;}
+    ${RELOCATING+PROVIDE (__data_section_start = .);}
+
+    ${RELOCATING+${DATA_START_SYMBOLS}}
+    ${RELOCATING+*(.sdata)}
+    *(.data)
+    ${RELOCATING+*(.data.*)}
+    ${RELOCATING+*(.data1)}
+    ${RELOCATING+*(.gnu.linkonce.d.*)}
+    ${CONSTRUCTING+CONSTRUCTORS}
+
+    ${RELOCATING+_edata  =  .;}
+    ${RELOCATING+PROVIDE (edata = .);}
+  } ${RELOCATING+ > ${DATA_MEMORY}}
+
+  ${RELOCATING+__data_section_size = SIZEOF(.data);}
+  ${RELOCATING+PROVIDE (__data_section_size = SIZEOF(.data));}
+  ${RELOCATING+__data_image_end = __data_image + __data_section_size;}
+
+  ${RELOCATING+${PRE_COMPUTE_DATA_SIZE}}
+
+  /* .install ${RELOCATING-0}:
+  {
+    . = _data_image_end;
+  } ${RELOCATING+ > ${TEXT_MEMORY}} */
+
+  /* Relocation for some bss and data sections.  */
+  ${RELOCATING-${BSS_DATA_RELOC}}
+  ${RELOCATING-${SOFT_REGS_RELOC}}
+
+  .bss ${RELOCATING-0} :
+  {
+    ${RELOCATING+__bss_start = .;}
+    ${RELOCATING+*(.sbss)}
+    ${RELOCATING+*(.scommon)}
+
+    *(.dynbss)
+    *(.bss)
+    ${RELOCATING+*(.bss.*)}
+    ${RELOCATING+*(.gnu.linkonce.b.*)}
+    *(COMMON)
+    ${RELOCATING+PROVIDE (_end = .);}
+  } ${RELOCATING+ > ${DATA_MEMORY}}
+  ${RELOCATING+__bss_size = SIZEOF(.bss);}
+  ${RELOCATING+PROVIDE (__bss_size = SIZEOF(.bss));}
+
+  .eeprom ${RELOCATING-0} :
+  {
+    *(.eeprom)
+    *(.eeprom.*)
+  } ${RELOCATING+ > ${EEPROM_MEMORY}}
+
+  ${RELOCATING+${VECTORS}}
+
+  /* Stabs debugging sections.  */
+  .stab		 0 : { *(.stab) }
+  .stabstr	 0 : { *(.stabstr) }
+  .stab.excl	 0 : { *(.stab.excl) }
+  .stab.exclstr	 0 : { *(.stab.exclstr) }
+  .stab.index	 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+
+  .comment	 0 : { *(.comment) }
+
+  /* DWARF debug sections.
+     Symbols in the DWARF debugging sections are relative to the beginning
+     of the section so we begin them at 0.
+     Treatment of DWARF debug section must be at end of the linker
+     script to avoid problems when there are undefined symbols. It's necessary
+     to avoid that the DWARF section is relocated before such undefined
+     symbols are found.  */
+
+  /* DWARF 1 */
+  .debug	 0 : { *(.debug) }
+  .line		 0 : { *(.line) }
+
+  /* GNU DWARF 1 extensions */
+  .debug_srcinfo 0 : { *(.debug_srcinfo) }
+  .debug_sfnames 0 : { *(.debug_sfnames) }
+
+  /* DWARF 1.1 and DWARF 2 */
+  .debug_aranges  0 : { *(.debug_aranges) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+
+  /* DWARF 2 */
+  .debug_info     0 : { *(.debug_info) *(.gnu.linkonce.wi.*) }
+  .debug_abbrev   0 : { *(.debug_abbrev) }
+  .debug_line     0 : { *(.debug_line) }
+  .debug_frame    0 : { *(.debug_frame) }
+  .debug_str      0 : { *(.debug_str) }
+  .debug_loc      0 : { *(.debug_loc) }
+  .debug_macinfo  0 : { *(.debug_macinfo) }
+}
+EOF
diff -u -r -N binutils-2.18/opcodes/configure binutils-2.18-s12x/opcodes/configure
--- binutils-2.18/opcodes/configure	2007-08-06 21:29:45.000000000 +0100
+++ binutils-2.18-s12x/opcodes/configure	2008-03-21 13:55:45.000000000 +0000
@@ -11441,6 +11441,8 @@
 	bfd_m32r_arch)		ta="$ta m32r-asm.lo m32r-desc.lo m32r-dis.lo m32r-ibld.lo m32r-opc.lo m32r-opinst.lo" using_cgen=yes ;;
 	bfd_m68hc11_arch)	ta="$ta m68hc11-dis.lo m68hc11-opc.lo" ;;
 	bfd_m68hc12_arch)	ta="$ta m68hc11-dis.lo m68hc11-opc.lo" ;;
+	bfd_m9s12x_arch)	    ta="$ta m68hc11-dis.lo m68hc11-opc.lo" ;;
+	bfd_m9s12xg_arch)	ta="$ta m68hc11-dis.lo m68hc11-opc.lo" ;;
 	bfd_m68k_arch)		ta="$ta m68k-dis.lo m68k-opc.lo" ;;
 	bfd_m88k_arch)		ta="$ta m88k-dis.lo" ;;
 	bfd_maxq_arch)		ta="$ta maxq-dis.lo" ;;
diff -u -r -N binutils-2.18/opcodes/configure.in binutils-2.18-s12x/opcodes/configure.in
--- binutils-2.18/opcodes/configure.in	2007-08-06 20:58:39.000000000 +0100
+++ binutils-2.18-s12x/opcodes/configure.in	2008-03-20 20:48:57.000000000 +0000
@@ -181,6 +181,8 @@
 	bfd_m32r_arch)		ta="$ta m32r-asm.lo m32r-desc.lo m32r-dis.lo m32r-ibld.lo m32r-opc.lo m32r-opinst.lo" using_cgen=yes ;;
 	bfd_m68hc11_arch)	ta="$ta m68hc11-dis.lo m68hc11-opc.lo" ;;
 	bfd_m68hc12_arch)	ta="$ta m68hc11-dis.lo m68hc11-opc.lo" ;;
+	bfd_m9s12x_arch)		ta="$ta m68hc11-dis.lo m68hc11-opc.lo" ;;
+	bfd_m9s12xg_arch)	ta="$ta m68hc11-dis.lo m68hc11-opc.lo" ;;
 	bfd_m68k_arch)		ta="$ta m68k-dis.lo m68k-opc.lo" ;;
 	bfd_m88k_arch)		ta="$ta m88k-dis.lo" ;;
 	bfd_maxq_arch)		ta="$ta maxq-dis.lo" ;;
diff -u -r -N binutils-2.18/opcodes/disassemble.c binutils-2.18-s12x/opcodes/disassemble.c
--- binutils-2.18/opcodes/disassemble.c	2007-08-06 20:58:40.000000000 +0100
+++ binutils-2.18-s12x/opcodes/disassemble.c	2008-03-21 13:10:15.000000000 +0000
@@ -50,6 +50,7 @@
 #define ARCH_m32r
 #define ARCH_m68hc11
 #define ARCH_m68hc12
+#define ARCH_m9s12xg
 #define ARCH_m68k
 #define ARCH_m88k
 #define ARCH_maxq
@@ -228,13 +229,19 @@
       disassemble = print_insn_m32r;
       break;
 #endif
-#if defined(ARCH_m68hc11) || defined(ARCH_m68hc12)
+#if defined(ARCH_m68hc11) || defined(ARCH_m68hc12) || defined(ARCH_9s12x) || defined(ARCH_m9s12xg)
     case bfd_arch_m68hc11:
       disassemble = print_insn_m68hc11;
       break;
     case bfd_arch_m68hc12:
       disassemble = print_insn_m68hc12;
       break;
+    case bfd_arch_m9s12x:
+      disassemble = print_insn_m9s12x;
+      break;
+    case bfd_arch_m9s12xg:
+      disassemble = print_insn_m9s12xg;
+      break;
 #endif
 #ifdef ARCH_m68k
     case bfd_arch_m68k:
diff -u -r -N binutils-2.18/opcodes/m68hc11-dis.c binutils-2.18-s12x/opcodes/m68hc11-dis.c
--- binutils-2.18/opcodes/m68hc11-dis.c	2007-08-06 20:59:06.000000000 +0100
+++ binutils-2.18-s12x/opcodes/m68hc11-dis.c	2009-10-09 00:48:35.000000000 +0100
@@ -2,6 +2,7 @@
    Copyright 1999, 2000, 2001, 2002, 2003, 2006, 2007
    Free Software Foundation, Inc.
    Written by Stephane Carrez (stcarrez@nerim.fr)
+   XGATE and S12X added by James Murray (jsm@jsm-net.demon.co.uk)
 
    This file is part of the GNU opcodes library.
 
@@ -98,8 +99,8 @@
       /* 68HC12 requires an adjustment for movb/movw pc relative modes.  */
       if (reg == PC_REGNUM && info->mach == bfd_mach_m6812 && mov_insn)
         sval += pc_offset;
-      (*info->fprintf_func) (info->stream, "%d,%s",
-			     (int) sval, reg_name[reg]);
+      (*info->fprintf_func) (info->stream, "0x%x,%s",
+			     (unsigned short) sval, reg_name[reg]);
 
       if (reg == PC_REGNUM)
         {
@@ -127,8 +128,8 @@
 	  sval = sval + 1;
 	  mode = "+";
 	}
-      (*info->fprintf_func) (info->stream, "%d,%s%s%s",
-			     (int) sval,
+      (*info->fprintf_func) (info->stream, "0x%x,%s%s%s",
+			     (unsigned short) sval,
 			     (buffer[0] & 0x10 ? "" : mode),
 			     reg_name[reg], (buffer[0] & 0x10 ? mode : ""));
     }
@@ -151,7 +152,7 @@
 
       pos += 2;
       sval = ((buffer[0] << 8) | (buffer[1] & 0x0FF));
-      (*info->fprintf_func) (info->stream, "[%u,%s]",
+      (*info->fprintf_func) (info->stream, "[0x%x,%s]",
 			     sval & 0x0ffff, reg_name[reg]);
       if (indirect)
         *indirect = 1;
@@ -188,8 +189,8 @@
 	  pos++;
           endaddr++;
 	}
-      (*info->fprintf_func) (info->stream, "%d,%s",
-			     (int) sval, reg_name[reg]);
+      (*info->fprintf_func) (info->stream, "0x%x,%s",
+			     (unsigned short) sval, reg_name[reg]);
       if (reg == PC_REGNUM)
         {
           (* info->fprintf_func) (info->stream, " {");
@@ -230,11 +231,89 @@
 {
   int status;
   bfd_byte buffer[4];
-  unsigned char code;
+  unsigned int code;
   long format, pos, i;
   short sval;
   const struct m68hc11_opcode *opcode;
 
+  if (arch & cpuxgate)
+    {
+    int val;
+  /* Get two bytes as all XGATE instructions are 16bit.  */
+  status = read_memory (memaddr, buffer, 2, info);
+  if (status != 0)
+    {
+      return status;
+    }
+
+  format = 0;
+  code = (buffer[0]<<8) + buffer[1];
+
+  /* Scan the opcode table until we find the opcode
+     with the corresponding page.  */
+  opcode = m68hc11_opcodes;
+  for (i = 0; i < m68hc11_num_opcodes; i++, opcode++)
+    {
+        if ((opcode->opcode != (code & opcode->xg_mask)) || (opcode->arch != cpuxgate)) {
+    	    continue;
+        }
+        /* We have found the opcode.  Extract the operand and print it.  */
+        (*info->fprintf_func) (info->stream, "%s", opcode->name);
+        format = opcode->format;
+        if (format & (M68XG_OP_NONE)) {
+            // ok
+        } else if (format & M68XG_OP_IMM3) {
+    	    (*info->fprintf_func) (info->stream, " #0x%x", (code >> 8) & 0x7 );
+        } else if (format & M68XG_OP_R_R) {
+    	    (*info->fprintf_func) (info->stream, " R%x, R%x", (code >> 8) & 0x7, (code >> 5) & 0x7 );
+        } else if (format & M68XG_OP_R_R_R) {
+    	    (*info->fprintf_func) (info->stream, " R%x, R%x, R%x", (code >> 8) & 0x7, (code >> 5) & 0x7, (code >> 2) & 0x7 );
+        } else if (format & M68XG_OP_RD_RB_RI) {
+    	    (*info->fprintf_func) (info->stream, " R%x, (R%x, R%x)", (code >> 8) & 0x7, (code >> 5) & 0x7, (code >> 2) & 0x7 );
+        } else if (format & M68XG_OP_RD_RB_RIp) {
+    	    (*info->fprintf_func) (info->stream, " R%x, (R%x, R%x+)", (code >> 8) & 0x7, (code >> 5) & 0x7, (code >> 2) & 0x7 );
+        } else if (format & M68XG_OP_RD_RB_mRI) {
+    	    (*info->fprintf_func) (info->stream, " R%x, (R%x, -R%x)", (code >> 8) & 0x7, (code >> 5) & 0x7, (code >> 2) & 0x7 );
+        } else if (format & M68XG_OP_R_R_OFFS5) {
+    	    (*info->fprintf_func) (info->stream, " R%x, (R%x, #0x%x)", (code >> 8) & 0x7, (code >> 5) & 0x7, code & 0x1f );
+        } else if (format & M68XG_OP_R_IMM8) {
+    	    (*info->fprintf_func) (info->stream, " R%x, #0x%02x", (code >> 8) & 0x7, code & 0xff);
+        } else if (format & M68XG_OP_R_IMM4) {
+    	    (*info->fprintf_func) (info->stream, " R%x, #0x%x", (code >> 8) & 0x7, (code & 0xf0)>>4);
+        } else if (format & M68XG_OP_REL9) {
+   	        (*info->fprintf_func) (info->stream, " 0x");
+            val = (buffer[0] & 0x1) ? buffer[1] | 0xFFFFFF00 : buffer[1];
+            (*info->print_address_func) (memaddr + (val<<1) + 2, info);
+
+        } else if (format & M68XG_OP_REL10) {
+   	        (*info->fprintf_func) (info->stream, " 0x");
+            val = (buffer[0]<<8) | (unsigned int)buffer[1];
+            if (val & 0x200) {
+                val |= 0xfffffc00;
+            } else {
+                val &= 0x000001ff;
+            }
+            (*info->print_address_func) (memaddr + (val<<1) +2 , info);
+        } else if ((code & 0x00ff) == 0x00f8) {
+    	    (*info->fprintf_func) (info->stream, " R%x, CCR", (code >> 8) & 0x7);
+        } else if ((code & 0x00ff) == 0x00f9) {
+    	    (*info->fprintf_func) (info->stream, " CCR, R%x", (code >> 8) & 0x7);
+        } else if ((code & 0x00ff) == 0x0) {
+    	    (*info->fprintf_func) (info->stream, " R%x, PC", (code >> 8) & 0x7);
+        } else if (format & M68XG_OP_R) {
+    	    (*info->fprintf_func) (info->stream, " R%x", (code >> 8) & 0x7 );
+	    } else {
+            /* Opcode not recognized.  */
+            (*info->fprintf_func) (info->stream, "Not yet handled .byte\t0x%04x", code);
+        }
+        return 2;
+    }
+   /* Opcode not recognized.  */
+   (*info->fprintf_func) (info->stream, ".byte\t0x%04x", code);
+   return 2; // everything is two bytes
+    }
+    else  /* HC11 and HC12 */
+    {
   /* Get first byte.  Only one at a time because we don't know the
      size of the insn.  */
   status = read_memory (memaddr, buffer, 1, info);
@@ -441,7 +520,7 @@
           pc_dst_offset = 2;
 	  if (format & M6811_OP_IMM8)
 	    {
-	      (*info->fprintf_func) (info->stream, "#%d", (int) buffer[0]);
+	      (*info->fprintf_func) (info->stream, "#0x%x", (int) buffer[0]);
 	      format &= ~M6811_OP_IMM8;
               /* Set PC destination offset.  */
               pc_dst_offset = 1;
@@ -449,17 +528,17 @@
 	  else if (format & M6811_OP_IX)
 	    {
 	      /* Offsets are in range 0..255, print them unsigned.  */
-	      (*info->fprintf_func) (info->stream, "%u,x", buffer[0] & 0x0FF);
+	      (*info->fprintf_func) (info->stream, "0x%x,x", buffer[0] & 0x0FF);
 	      format &= ~M6811_OP_IX;
 	    }
 	  else if (format & M6811_OP_IY)
 	    {
-	      (*info->fprintf_func) (info->stream, "%u,y", buffer[0] & 0x0FF);
+	      (*info->fprintf_func) (info->stream, "0x%x,y", buffer[0] & 0x0FF);
 	      format &= ~M6811_OP_IY;
 	    }
 	  else if (format & M6811_OP_DIRECT)
 	    {
-	      (*info->fprintf_func) (info->stream, "*");
+	      (*info->fprintf_func) (info->stream, "*0x");
 	      (*info->print_address_func) (buffer[0] & 0x0FF, info);
 	      format &= ~M6811_OP_DIRECT;
 	    }
@@ -508,6 +587,7 @@
 	    sval |= 0xff00;
 
 	  pos += 2;
+   	  (*info->fprintf_func) (info->stream, " 0x");
 	  (*info->print_address_func) (memaddr + pos + sval, info);
 	  format &= ~(M6812_OP_REG | M6811_OP_JUMP_REL);
 	}
@@ -585,12 +665,13 @@
 	  else
 	    format &= ~M6811_OP_IND16;
 
+      (*info->fprintf_func) (info->stream, "0x");
 	  (*info->print_address_func) (addr, info);
           if (format & M6812_OP_PAGE)
             {
               (* info->fprintf_func) (info->stream, " {");
               (* info->print_address_func) (val, info);
-              (* info->fprintf_func) (info->stream, ", %d}", page);
+              (* info->fprintf_func) (info->stream, ", 0x%x}", page);
               format &= ~M6812_OP_PAGE;
               pos += 1;
             }
@@ -622,6 +703,7 @@
 
 	  val = ((buffer[0] << 8) | (buffer[1] & 0x0FF));
 	  val &= 0x0FFFF;
+   	  (*info->fprintf_func) (info->stream, " 0x");
 	  (*info->print_address_func) (val, info);
 	}
 
@@ -636,7 +718,7 @@
 	      return status;
 	    }
 	  pos++;
-	  (*info->fprintf_func) (info->stream, " #$%02x%s",
+	  (*info->fprintf_func) (info->stream, ", #0x%02x%s",
 				 buffer[0] & 0x0FF,
 				 (format & M6811_OP_JUMP_REL ? " " : ""));
 	  format &= ~M6811_OP_BITMASK;
@@ -651,6 +733,7 @@
 	      return status;
 	    }
 
+      (*info->fprintf_func) (info->stream, " 0x");
 	  pos++;
 	  val = (buffer[0] & 0x80) ? buffer[0] | 0xFFFFFF00 : buffer[0];
 	  (*info->print_address_func) (memaddr + pos + val, info);
@@ -671,6 +754,7 @@
 	  if (val & 0x8000)
 	    val |= 0xffff0000;
 
+   	  (*info->fprintf_func) (info->stream, " 0x");
 	  (*info->print_address_func) (memaddr + pos + val, info);
 	  format &= ~M6812_OP_JUMP_REL16;
 	}
@@ -687,7 +771,7 @@
 	  pos += 1;
 
 	  val = buffer[0] & 0x0ff;
-	  (*info->fprintf_func) (info->stream, ", %d", val);
+	  (*info->fprintf_func) (info->stream, ", 0x%x", val);
 	}
       
 #ifdef DEBUG
@@ -710,7 +794,7 @@
   /* Opcode not recognized.  */
   if (format == M6811_OP_PAGE2 && arch & cpu6812
       && ((code >= 0x30 && code <= 0x39) || (code >= 0x40)))
-    (*info->fprintf_func) (info->stream, "trap\t#%d", code & 0x0ff);
+    (*info->fprintf_func) (info->stream, "trap\t#0x%02x", code & 0x0ff);
 
   else if (format == M6811_OP_PAGE2)
     (*info->fprintf_func) (info->stream, ".byte\t0x%02x, 0x%02x",
@@ -725,6 +809,7 @@
     (*info->fprintf_func) (info->stream, ".byte\t0x%02x", code);
 
   return pos;
+  }
 }
 
 /* Disassemble one instruction at address 'memaddr'.  Returns the number
@@ -740,3 +825,18 @@
 {
   return print_insn (memaddr, info, cpu6812);
 }
+
+int
+print_insn_m9s12x (bfd_vma memaddr, struct disassemble_info* info)
+{
+  return print_insn (memaddr, info, cpu6812|cpu9s12x);
+}
+
+int
+print_insn_m9s12xg (bfd_vma memaddr, struct disassemble_info* info)
+{
+  return print_insn (memaddr, info, cpuxgate);
+}
+
+
+
diff -u -r -N binutils-2.18/opcodes/m68hc11-opc.c binutils-2.18-s12x/opcodes/m68hc11-opc.c
--- binutils-2.18/opcodes/m68hc11-opc.c	2007-08-06 20:59:06.000000000 +0100
+++ binutils-2.18-s12x/opcodes/m68hc11-opc.c	2010-05-04 11:36:22.000000000 +0100
@@ -1,6 +1,9 @@
-/* m68hc11-opc.c -- Motorola 68HC11 & 68HC12 opcode list
-   Copyright 1999, 2000, 2002, 2007 Free Software Foundation, Inc.
+/* m68hc11-opc.c -- Motorola/Freescale 68HC11, 68HC12, S12X and XGATE
+   opcode list.
+   Copyright 1999, 2000, 2002, 2007, 2008 Free Software Foundation, Inc.
    Written by Stephane Carrez (stcarrez@nerim.fr)
+   XGATE and S12X added by James Murray (jsm@jsm-net.demon.co.uk)
+   Note: min/max cycles not updated for S12X opcodes.
 
    This file is part of the GNU opcodes library.
 
@@ -91,6 +94,10 @@
 #define OP_REG_1        M6812_OP_REG
 #define OP_REG_2        M6812_OP_REG_2
 #define OP_IDX_p2       M6812_OP_IDX_P2
+#define OP_IDX1_p2      M6812_OP_IDX1_P2
+#define OP_IDX2_p2      M6812_OP_IDX2_P2
+#define OP_D_IDX_p2     M6812_OP_D_IDX_P2
+#define OP_D_IDX2_p2    M6812_OP_D_IDX2_P2
 #define OP_IND16_p2     M6812_OP_IND16_P2
 #define OP_TRAP_ID      M6812_OP_TRAP_ID
 #define OP_EXG_MARKER   M6812_OP_EXG_MARKER
@@ -103,956 +110,1603 @@
 #define OP_IBNE_MARKER  (M6812_OP_IBCC_MARKER)
 
 /*
-   { "test", OP_NONE,          1, 0x00,  5, _M,  CHG_NONE,  cpu6811 },
-                                                            +-- cpu
+   { "test", OP_NONE,          1, 0x00,  5, _M,  CHG_NONE,  cpu6811, 0 },
+                                                            +-- cpu  +-- XGATE opcode mask
   Name -+                                        +------- Insn CCR changes
   Format  ------+                            +----------- Max # cycles
   Size     --------------------+         +--------------- Min # cycles
                                    +--------------------- Opcode
 */
 const struct m68hc11_opcode m68hc11_opcodes[] = {
-  { "aba",  OP_NONE,           1, 0x1b,  2,  2,  CHG_HNZVC, cpu6811 },
-  { "aba",  OP_NONE | OP_PAGE2,2, 0x06,  2,  2,  CHG_HNZVC, cpu6812 },
-  { "abx",  OP_NONE,           1, 0x3a,  3,  3,  CHG_NONE,  cpu6811 },
-  { "aby",  OP_NONE | OP_PAGE2,2, 0x3a,  4,  4,  CHG_NONE,  cpu6811 },
-
-  { "adca", OP_IMM8,           2, 0x89,  1,  1,  CHG_HNZVC, cpu6811|cpu6812 },
-  { "adca", OP_DIRECT,         2, 0x99,  3,  3,  CHG_HNZVC, cpu6811|cpu6812 },
-  { "adca", OP_IND16,          3, 0xb9,  3,  3,  CHG_HNZVC, cpu6811|cpu6812 },
-  { "adca", OP_IX,             2, 0xa9,  4,  4,  CHG_HNZVC, cpu6811 },
-  { "adca", OP_IY | OP_PAGE2,  3, 0xa9,  5,  5,  CHG_HNZVC, cpu6811 },
-  { "adca", OP_IDX,            2, 0xa9,  3,  3,  CHG_HNZVC, cpu6812 },
-  { "adca", OP_IDX_1,          3, 0xa9,  3,  3,  CHG_HNZVC, cpu6812 },
-  { "adca", OP_IDX_2,          4, 0xa9,  4,  4,  CHG_HNZVC, cpu6812 },
-  { "adca", OP_D_IDX,          2, 0xa9,  6,  6,  CHG_HNZVC, cpu6812 },
-  { "adca", OP_D_IDX_2,        4, 0xa9,  6,  6,  CHG_HNZVC, cpu6812 },
-
-  { "adcb", OP_IMM8,           2, 0xc9,  1,  1,  CHG_HNZVC, cpu6811|cpu6812 },
-  { "adcb", OP_DIRECT,         2, 0xd9,  3,  3,  CHG_HNZVC, cpu6811|cpu6812 },
-  { "adcb", OP_IND16,          3, 0xf9,  3,  3,  CHG_HNZVC, cpu6811|cpu6812 },
-  { "adcb", OP_IX,             2, 0xe9,  4,  4,  CHG_HNZVC, cpu6811 },
-  { "adcb", OP_IY | OP_PAGE2,  3, 0xe9,  5,  5,  CHG_HNZVC, cpu6811 },
-  { "adcb", OP_IDX,            2, 0xe9,  3,  3,  CHG_HNZVC, cpu6812 },
-  { "adcb", OP_IDX_1,          3, 0xe9,  3,  3,  CHG_HNZVC, cpu6812 },
-  { "adcb", OP_IDX_2,          4, 0xe9,  4,  4,  CHG_HNZVC, cpu6812 },
-  { "adcb", OP_D_IDX,          2, 0xe9,  6,  6,  CHG_HNZVC, cpu6812 },
-  { "adcb", OP_D_IDX_2,        4, 0xe9,  6,  6,  CHG_HNZVC, cpu6812 },
-
-  { "adda", OP_IMM8,           2, 0x8b,  1,  1,  CHG_HNZVC, cpu6811|cpu6812 },
-  { "adda", OP_DIRECT,         2, 0x9b,  3,  3,  CHG_HNZVC, cpu6811|cpu6812 },
-  { "adda", OP_IND16,          3, 0xbb,  3,  3,  CHG_HNZVC, cpu6811|cpu6812 },
-  { "adda", OP_IX,             2, 0xab,  4,  4,  CHG_HNZVC, cpu6811 },
-  { "adda", OP_IY | OP_PAGE2,  3, 0xab,  5,  5,  CHG_HNZVC, cpu6811 },
-  { "adda", OP_IDX,            2, 0xab,  3,  3,  CHG_HNZVC, cpu6812 },
-  { "adda", OP_IDX_1,          3, 0xab,  3,  3,  CHG_HNZVC, cpu6812 },
-  { "adda", OP_IDX_2,          4, 0xab,  4,  4,  CHG_HNZVC, cpu6812 },
-  { "adda", OP_D_IDX,          2, 0xab,  6,  6,  CHG_HNZVC, cpu6812 },
-  { "adda", OP_D_IDX_2,        4, 0xab,  6,  6,  CHG_HNZVC, cpu6812 },
-
-  { "addb", OP_IMM8,           2, 0xcb,  1,  1,  CHG_HNZVC, cpu6811|cpu6812 },
-  { "addb", OP_DIRECT,         2, 0xdb,  3,  3,  CHG_HNZVC, cpu6811|cpu6812 },
-  { "addb", OP_IND16,          3, 0xfb,  3,  3,  CHG_HNZVC, cpu6811|cpu6812 },
-  { "addb", OP_IX,             2, 0xeb,  4,  4,  CHG_HNZVC, cpu6811 },
-  { "addb", OP_IY | OP_PAGE2,  3, 0xeb,  5,  5,  CHG_HNZVC, cpu6811 },
-  { "addb", OP_IDX,            2, 0xeb,  3,  3,  CHG_HNZVC, cpu6812 },
-  { "addb", OP_IDX_1,          3, 0xeb,  3,  3,  CHG_HNZVC, cpu6812 },
-  { "addb", OP_IDX_2,          4, 0xeb,  4,  4,  CHG_HNZVC, cpu6812 },
-  { "addb", OP_D_IDX,          2, 0xeb,  6,  6,  CHG_HNZVC, cpu6812 },
-  { "addb", OP_D_IDX_2,        4, 0xeb,  6,  6,  CHG_HNZVC, cpu6812 },
-
-  { "addd", OP_IMM16,          3, 0xc3,  2,  2,  CHG_NZVC, cpu6811|cpu6812 },
-  { "addd", OP_DIRECT,         2, 0xd3,  3,  3,  CHG_NZVC, cpu6811|cpu6812 },
-  { "addd", OP_IND16,          3, 0xf3,  3,  3,  CHG_NZVC, cpu6811|cpu6812 },
-  { "addd", OP_IX,             2, 0xe3,  6,  6,  CHG_NZVC, cpu6811 },
-  { "addd", OP_IY | OP_PAGE2,  3, 0xe3,  7,  7,  CHG_NZVC, cpu6811 },
-  { "addd", OP_IDX,            2, 0xe3,  3,  3,  CHG_NZVC, cpu6812 },
-  { "addd", OP_IDX_1,          3, 0xe3,  3,  3,  CHG_NZVC, cpu6812 },
-  { "addd", OP_IDX_2,          4, 0xe3,  4,  4,  CHG_NZVC, cpu6812 },
-  { "addd", OP_D_IDX,          2, 0xe3,  6,  6,  CHG_NZVC, cpu6812 },
-  { "addd", OP_D_IDX_2,        4, 0xe3,  6,  6,  CHG_NZVC, cpu6812 },
-
-  { "anda", OP_IMM8,         2, 0x84,  1,  1,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "anda", OP_DIRECT,       2, 0x94,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "anda", OP_IND16,        3, 0xb4,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "anda", OP_IX,             2, 0xa4,  4,  4,  CLR_V_CHG_NZ, cpu6811 },
-  { "anda", OP_IY | OP_PAGE2,  3, 0xa4,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "anda", OP_IDX,            2, 0xa4,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "anda", OP_IDX_1,          3, 0xa4,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "anda", OP_IDX_2,          4, 0xa4,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "anda", OP_D_IDX,          2, 0xa4,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-  { "anda", OP_D_IDX_2,        4, 0xa4,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "andb", OP_IMM8,         2, 0xc4,  1,  1,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "andb", OP_DIRECT,       2, 0xd4,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "andb", OP_IND16,        3, 0xf4,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "andb", OP_IX,             2, 0xe4,  4,  4,  CLR_V_CHG_NZ, cpu6811 },
-  { "andb", OP_IY | OP_PAGE2,  3, 0xe4,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "andb", OP_IDX,            2, 0xe4,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "andb", OP_IDX_1,          3, 0xe4,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "andb", OP_IDX_2,          4, 0xe4,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "andb", OP_D_IDX,          2, 0xe4,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-  { "andb", OP_D_IDX_2,        4, 0xe4,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "andcc", OP_IMM8,          2, 0x10,  1,  1,  CHG_ALL,  cpu6812 },
-
-  { "asl",  OP_IND16,          3, 0x78,  4,  4,  CHG_NZVC, cpu6811|cpu6812 },
-  { "asl",  OP_IX,             2, 0x68,  6,  6,  CHG_NZVC, cpu6811 },
-  { "asl",  OP_IY | OP_PAGE2,  3, 0x68,  7,  7,  CHG_NZVC, cpu6811 },
-  { "asl",  OP_IDX,            2, 0x68,  3,  3,  CHG_NZVC, cpu6812 },
-  { "asl",  OP_IDX_1,          3, 0x68,  4,  4,  CHG_NZVC, cpu6812 },
-  { "asl",  OP_IDX_2,          4, 0x68,  5,  5,  CHG_NZVC, cpu6812 },
-  { "asl",  OP_D_IDX,          2, 0x68,  6,  6,  CHG_NZVC, cpu6812 },
-  { "asl",  OP_D_IDX_2,        4, 0x68,  6,  6,  CHG_NZVC, cpu6812 },
-
-  { "asla", OP_NONE,           1, 0x48,  1,  1,  CHG_NZVC, cpu6811|cpu6812 },
-  { "aslb", OP_NONE,           1, 0x58,  1,  1,  CHG_NZVC, cpu6811|cpu6812 },
-  { "asld", OP_NONE,           1, 0x05,  3,  3,  CHG_NZVC, cpu6811 },
-  { "asld", OP_NONE,           1, 0x59,  1,  1,  CHG_NZVC, cpu6812 },
-
-  { "asr",  OP_IND16,          3, 0x77,  4,  4,  CHG_NZVC, cpu6811|cpu6812 },
-  { "asr",  OP_IX,             2, 0x67,  6,  6,  CHG_NZVC, cpu6811 },
-  { "asr",  OP_IY | OP_PAGE2,  3, 0x67,  7,  7,  CHG_NZVC, cpu6811 },
-  { "asr",  OP_IDX,            2, 0x67,  3,  3,  CHG_NZVC, cpu6812 },
-  { "asr",  OP_IDX_1,          3, 0x67,  4,  4,  CHG_NZVC, cpu6812 },
-  { "asr",  OP_IDX_2,          4, 0x67,  5,  5,  CHG_NZVC, cpu6812 },
-  { "asr",  OP_D_IDX,          2, 0x67,  6,  6,  CHG_NZVC, cpu6812 },
-  { "asr",  OP_D_IDX_2,        4, 0x67,  6,  6,  CHG_NZVC, cpu6812 },
-
-  { "asra", OP_NONE,           1, 0x47,  1,  1,  CHG_NZVC, cpu6811|cpu6812 },
-  { "asrb", OP_NONE,           1, 0x57,  1,  1,  CHG_NZVC, cpu6811|cpu6812 },
-
-  { "bcc", OP_JUMP_REL,        2, 0x24,  1,  3,  CHG_NONE, cpu6811|cpu6812 },
-
-  { "bclr", OP_BITMASK|OP_DIRECT,  3, 0x15,  6,  6,  CLR_V_CHG_NZ, cpu6811 },
-  { "bclr", OP_BITMASK|OP_IX,       3, 0x1d,  7,  7,  CLR_V_CHG_NZ, cpu6811 },
-  { "bclr", OP_BITMASK|OP_IY|OP_PAGE2, 4, 0x1d, 8, 8, CLR_V_CHG_NZ, cpu6811},
-  { "bclr", OP_BITMASK|OP_DIRECT,   3, 0x4d,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "bclr", OP_BITMASK|OP_IND16,    4, 0x1d,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "bclr", OP_BITMASK|OP_IDX,      3, 0x0d,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "bclr", OP_BITMASK|OP_IDX_1,    4, 0x0d,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "bclr", OP_BITMASK|OP_IDX_2,    5, 0x0d,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "bcs", OP_JUMP_REL,        2, 0x25,  1,  3, CHG_NONE, cpu6811 | cpu6812 },
-  { "beq", OP_JUMP_REL,        2, 0x27,  1,  3, CHG_NONE, cpu6811 | cpu6812 },
-  { "bge", OP_JUMP_REL,        2, 0x2c,  1,  3, CHG_NONE, cpu6811 | cpu6812 },
-
-  { "bgnd", OP_NONE,           1, 0x00,  5,  5, CHG_NONE, cpu6811 | cpu6812 },
-
-  { "bgt", OP_JUMP_REL,        2, 0x2e,  1,  3, CHG_NONE, cpu6811 | cpu6812 },
-  { "bhi", OP_JUMP_REL,        2, 0x22,  1,  3, CHG_NONE, cpu6811 | cpu6812 },
-  { "bhs", OP_JUMP_REL,        2, 0x24,  1,  3, CHG_NONE, cpu6811 | cpu6812 },
+  { "aba",  OP_NONE,           1, 0x1b,  2,  2,  CHG_HNZVC, cpu6811, 0 },
+  { "aba",  OP_NONE | OP_PAGE2,2, 0x06,  2,  2,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+  { "abx",  OP_NONE,           1, 0x3a,  3,  3,  CHG_NONE,  cpu6811, 0 },
+  { "aby",  OP_NONE | OP_PAGE2,2, 0x3a,  4,  4,  CHG_NONE,  cpu6811, 0 },
+
+  { "adca", OP_IMM8,           2, 0x89,  1,  1,  CHG_HNZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "adca", OP_DIRECT,         2, 0x99,  3,  3,  CHG_HNZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "adca", OP_IND16,          3, 0xb9,  3,  3,  CHG_HNZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "adca", OP_IX,             2, 0xa9,  4,  4,  CHG_HNZVC, cpu6811, 0 },
+  { "adca", OP_IY | OP_PAGE2,  3, 0xa9,  5,  5,  CHG_HNZVC, cpu6811, 0 },
+  { "adca", OP_IDX,            2, 0xa9,  3,  3,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+  { "adca", OP_IDX_1,          3, 0xa9,  3,  3,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+  { "adca", OP_IDX_2,          4, 0xa9,  4,  4,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+  { "adca", OP_D_IDX,          2, 0xa9,  6,  6,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+  { "adca", OP_D_IDX_2,        4, 0xa9,  6,  6,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+
+  { "adcb", OP_IMM8,           2, 0xc9,  1,  1,  CHG_HNZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "adcb", OP_DIRECT,         2, 0xd9,  3,  3,  CHG_HNZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "adcb", OP_IND16,          3, 0xf9,  3,  3,  CHG_HNZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "adcb", OP_IX,             2, 0xe9,  4,  4,  CHG_HNZVC, cpu6811, 0 },
+  { "adcb", OP_IY | OP_PAGE2,  3, 0xe9,  5,  5,  CHG_HNZVC, cpu6811, 0 },
+  { "adcb", OP_IDX,            2, 0xe9,  3,  3,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+  { "adcb", OP_IDX_1,          3, 0xe9,  3,  3,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+  { "adcb", OP_IDX_2,          4, 0xe9,  4,  4,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+  { "adcb", OP_D_IDX,          2, 0xe9,  6,  6,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+  { "adcb", OP_D_IDX_2,        4, 0xe9,  6,  6,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+
+  { "adda", OP_IMM8,           2, 0x8b,  1,  1,  CHG_HNZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "adda", OP_DIRECT,         2, 0x9b,  3,  3,  CHG_HNZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "adda", OP_IND16,          3, 0xbb,  3,  3,  CHG_HNZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "adda", OP_IX,             2, 0xab,  4,  4,  CHG_HNZVC, cpu6811, 0 },
+  { "adda", OP_IY | OP_PAGE2,  3, 0xab,  5,  5,  CHG_HNZVC, cpu6811, 0 },
+  { "adda", OP_IDX,            2, 0xab,  3,  3,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+  { "adda", OP_IDX_1,          3, 0xab,  3,  3,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+  { "adda", OP_IDX_2,          4, 0xab,  4,  4,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+  { "adda", OP_D_IDX,          2, 0xab,  6,  6,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+  { "adda", OP_D_IDX_2,        4, 0xab,  6,  6,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+
+  { "addb", OP_IMM8,           2, 0xcb,  1,  1,  CHG_HNZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "addb", OP_DIRECT,         2, 0xdb,  3,  3,  CHG_HNZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "addb", OP_IND16,          3, 0xfb,  3,  3,  CHG_HNZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "addb", OP_IX,             2, 0xeb,  4,  4,  CHG_HNZVC, cpu6811, 0 },
+  { "addb", OP_IY | OP_PAGE2,  3, 0xeb,  5,  5,  CHG_HNZVC, cpu6811, 0 },
+  { "addb", OP_IDX,            2, 0xeb,  3,  3,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+  { "addb", OP_IDX_1,          3, 0xeb,  3,  3,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+  { "addb", OP_IDX_2,          4, 0xeb,  4,  4,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+  { "addb", OP_D_IDX,          2, 0xeb,  6,  6,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+  { "addb", OP_D_IDX_2,        4, 0xeb,  6,  6,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+
+  { "addd", OP_IMM16,          3, 0xc3,  2,  2,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "addd", OP_DIRECT,         2, 0xd3,  3,  3,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "addd", OP_IND16,          3, 0xf3,  3,  3,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "addd", OP_IX,             2, 0xe3,  6,  6,  CHG_NZVC, cpu6811, 0 },
+  { "addd", OP_IY | OP_PAGE2,  3, 0xe3,  7,  7,  CHG_NZVC, cpu6811, 0 },
+  { "addd", OP_IDX,            2, 0xe3,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "addd", OP_IDX_1,          3, 0xe3,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "addd", OP_IDX_2,          4, 0xe3,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "addd", OP_D_IDX,          2, 0xe3,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "addd", OP_D_IDX_2,        4, 0xe3,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "addx", OP_IMM16 | OP_PAGE2,          3, 0x8b,  2,  2,  CHG_NZVC, cpu9s12x, 0 },
+  { "addx", OP_DIRECT | OP_PAGE2,         2, 0x9b,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "addx", OP_IND16 | OP_PAGE2,          3, 0xbb,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "addx", OP_IDX | OP_PAGE2,            2, 0xab,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "addx", OP_IDX_1 | OP_PAGE2,          3, 0xab,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "addx", OP_IDX_2 | OP_PAGE2,          4, 0xab,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "addx", OP_D_IDX | OP_PAGE2,          2, 0xab,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "addx", OP_D_IDX_2 | OP_PAGE2,        4, 0xab,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "addy", OP_IMM16 | OP_PAGE2,          3, 0xcb,  2,  2,  CHG_NZVC, cpu9s12x, 0 },
+  { "addy", OP_DIRECT | OP_PAGE2,         2, 0xdb,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "addy", OP_IND16 | OP_PAGE2,          3, 0xfb,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "addy", OP_IDX | OP_PAGE2,            2, 0xeb,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "addy", OP_IDX_1 | OP_PAGE2,          3, 0xeb,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "addy", OP_IDX_2 | OP_PAGE2,          4, 0xeb,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "addy", OP_D_IDX | OP_PAGE2,          2, 0xeb,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "addy", OP_D_IDX_2 | OP_PAGE2,        4, 0xeb,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "aded", OP_IMM16 | OP_PAGE2,          3, 0xc3,  2,  2,  CHG_NZVC, cpu9s12x, 0 },
+  { "aded", OP_DIRECT | OP_PAGE2,         2, 0xd3,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "aded", OP_IND16 | OP_PAGE2,          3, 0xf3,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "aded", OP_IDX | OP_PAGE2,            2, 0xe3,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "aded", OP_IDX_1 | OP_PAGE2,          3, 0xe3,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "aded", OP_IDX_2 | OP_PAGE2,          4, 0xe3,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "aded", OP_D_IDX | OP_PAGE2,          2, 0xe3,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "aded", OP_D_IDX_2 | OP_PAGE2,        4, 0xe3,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "adex", OP_IMM16 | OP_PAGE2,          3, 0x89,  2,  2,  CHG_NZVC, cpu9s12x, 0 },
+  { "adex", OP_DIRECT | OP_PAGE2,         2, 0x99,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "adex", OP_IND16 | OP_PAGE2,          3, 0xb9,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "adex", OP_IDX | OP_PAGE2,            2, 0xa9,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "adex", OP_IDX_1 | OP_PAGE2,          3, 0xa9,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "adex", OP_IDX_2 | OP_PAGE2,          4, 0xa9,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "adex", OP_D_IDX | OP_PAGE2,          2, 0xa9,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "adex", OP_D_IDX_2 | OP_PAGE2,        4, 0xa9,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "adey", OP_IMM16 | OP_PAGE2,          3, 0xc9,  2,  2,  CHG_NZVC, cpu9s12x, 0 },
+  { "adey", OP_DIRECT | OP_PAGE2,         2, 0xd9,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "adey", OP_IND16 | OP_PAGE2,          3, 0xf9,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "adey", OP_IDX | OP_PAGE2,            2, 0xe9,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "adey", OP_IDX_1 | OP_PAGE2,          3, 0xe9,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "adey", OP_IDX_2 | OP_PAGE2,          4, 0xe9,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "adey", OP_D_IDX | OP_PAGE2,          2, 0xe9,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "adey", OP_D_IDX_2 | OP_PAGE2,        4, 0xe9,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "anda", OP_IMM8,         2, 0x84,  1,  1,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "anda", OP_DIRECT,       2, 0x94,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "anda", OP_IND16,        3, 0xb4,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "anda", OP_IX,             2, 0xa4,  4,  4,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "anda", OP_IY | OP_PAGE2,  3, 0xa4,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "anda", OP_IDX,            2, 0xa4,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "anda", OP_IDX_1,          3, 0xa4,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "anda", OP_IDX_2,          4, 0xa4,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "anda", OP_D_IDX,          2, 0xa4,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "anda", OP_D_IDX_2,        4, 0xa4,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "andb", OP_IMM8,         2, 0xc4,  1,  1,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "andb", OP_DIRECT,       2, 0xd4,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "andb", OP_IND16,        3, 0xf4,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "andb", OP_IX,             2, 0xe4,  4,  4,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "andb", OP_IY | OP_PAGE2,  3, 0xe4,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "andb", OP_IDX,            2, 0xe4,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "andb", OP_IDX_1,          3, 0xe4,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "andb", OP_IDX_2,          4, 0xe4,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "andb", OP_D_IDX,          2, 0xe4,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "andb", OP_D_IDX_2,        4, 0xe4,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "andcc", OP_IMM8,          2, 0x10,  1,  1,  CHG_ALL,  cpu6812|cpu9s12x, 0 },
+
+  { "andx", OP_IMM16 | OP_PAGE2,         2, 0x84,  1,  1,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "andx", OP_DIRECT | OP_PAGE2,       2, 0x94,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "andx", OP_IND16 | OP_PAGE2,        3, 0xb4,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "andx", OP_IDX | OP_PAGE2,            2, 0xa4,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "andx", OP_IDX_1 | OP_PAGE2,          3, 0xa4,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "andx", OP_IDX_2 | OP_PAGE2,          4, 0xa4,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "andx", OP_D_IDX | OP_PAGE2,          2, 0xa4,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "andx", OP_D_IDX_2 | OP_PAGE2,        4, 0xa4,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "andy", OP_IMM16 | OP_PAGE2,         2, 0xc4,  1,  1,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "andy", OP_DIRECT | OP_PAGE2,       2, 0xd4,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "andy", OP_IND16 | OP_PAGE2,        3, 0xf4,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "andy", OP_IDX | OP_PAGE2,            2, 0xe4,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "andy", OP_IDX_1 | OP_PAGE2,          3, 0xe4,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "andy", OP_IDX_2 | OP_PAGE2,          4, 0xe4,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "andy", OP_D_IDX | OP_PAGE2,          2, 0xe4,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "andy", OP_D_IDX_2 | OP_PAGE2,        4, 0xe4,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "asl",  OP_IND16,          3, 0x78,  4,  4,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "asl",  OP_IX,             2, 0x68,  6,  6,  CHG_NZVC, cpu6811, 0 },
+  { "asl",  OP_IY | OP_PAGE2,  3, 0x68,  7,  7,  CHG_NZVC, cpu6811, 0 },
+  { "asl",  OP_IDX,            2, 0x68,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "asl",  OP_IDX_1,          3, 0x68,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "asl",  OP_IDX_2,          4, 0x68,  5,  5,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "asl",  OP_D_IDX,          2, 0x68,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "asl",  OP_D_IDX_2,        4, 0x68,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "asla", OP_NONE,           1, 0x48,  1,  1,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "aslb", OP_NONE,           1, 0x58,  1,  1,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "asld", OP_NONE,           1, 0x05,  3,  3,  CHG_NZVC, cpu6811, 0 },
+  { "asld", OP_NONE,           1, 0x59,  1,  1,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "aslw",  OP_IND16 | OP_PAGE2,          3, 0x78,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "aslw",  OP_IDX | OP_PAGE2,            2, 0x68,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "aslw",  OP_IDX_1 | OP_PAGE2,          3, 0x68,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "aslw",  OP_IDX_2 | OP_PAGE2,          4, 0x68,  5,  5,  CHG_NZVC, cpu9s12x, 0 },
+  { "aslw",  OP_D_IDX | OP_PAGE2,          2, 0x68,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "aslw",  OP_D_IDX_2 | OP_PAGE2,        4, 0x68,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "aslx", OP_NONE | OP_PAGE2,           1, 0x48,  1,  1,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "asly", OP_NONE | OP_PAGE2,           1, 0x58,  1,  1,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "asr",  OP_IND16,          3, 0x77,  4,  4,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "asr",  OP_IX,             2, 0x67,  6,  6,  CHG_NZVC, cpu6811, 0 },
+  { "asr",  OP_IY | OP_PAGE2,  3, 0x67,  7,  7,  CHG_NZVC, cpu6811, 0 },
+  { "asr",  OP_IDX,            2, 0x67,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "asr",  OP_IDX_1,          3, 0x67,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "asr",  OP_IDX_2,          4, 0x67,  5,  5,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "asr",  OP_D_IDX,          2, 0x67,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "asr",  OP_D_IDX_2,        4, 0x67,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "asra", OP_NONE,           1, 0x47,  1,  1,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "asrb", OP_NONE,           1, 0x57,  1,  1,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+
+  { "asrw",  OP_IND16 | OP_PAGE2,          3, 0x77,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "asrw",  OP_IDX | OP_PAGE2,            2, 0x67,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "asrw",  OP_IDX_1 | OP_PAGE2,          3, 0x67,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "asrw",  OP_IDX_2 | OP_PAGE2,          4, 0x67,  5,  5,  CHG_NZVC, cpu9s12x, 0 },
+  { "asrw",  OP_D_IDX | OP_PAGE2,          2, 0x67,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "asrw",  OP_D_IDX_2 | OP_PAGE2,        4, 0x67,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "asrx", OP_NONE | OP_PAGE2,           1, 0x47,  1,  1,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "asry", OP_NONE | OP_PAGE2,           1, 0x57,  1,  1,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "bcc", OP_JUMP_REL,        2, 0x24,  1,  3,  CHG_NONE, cpu6811|cpu6812|cpu9s12x, 0 },
+
+  { "bclr", OP_BITMASK|OP_DIRECT,  3, 0x15,  6,  6,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "bclr", OP_BITMASK|OP_IX,       3, 0x1d,  7,  7,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "bclr", OP_BITMASK|OP_IY|OP_PAGE2, 4, 0x1d, 8, 8, CLR_V_CHG_NZ, cpu6811, 0 },
+  { "bclr", OP_BITMASK|OP_DIRECT,   3, 0x4d,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "bclr", OP_BITMASK|OP_IND16,    4, 0x1d,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "bclr", OP_BITMASK|OP_IDX,      3, 0x0d,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "bclr", OP_BITMASK|OP_IDX_1,    4, 0x0d,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "bclr", OP_BITMASK|OP_IDX_2,    5, 0x0d,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "bcs", OP_JUMP_REL,        2, 0x25,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
+  { "beq", OP_JUMP_REL,        2, 0x27,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
+  { "bge", OP_JUMP_REL,        2, 0x2c,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
+
+  { "bgnd", OP_NONE,           1, 0x00,  5,  5, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
+
+  { "bgt", OP_JUMP_REL,        2, 0x2e,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
+  { "bhi", OP_JUMP_REL,        2, 0x22,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
+  { "bhs", OP_JUMP_REL,        2, 0x24,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
   
-  { "bita", OP_IMM8,          2, 0x85,  1,  1, CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "bita", OP_DIRECT,        2, 0x95,  3,  3, CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "bita", OP_IND16,         3, 0xb5,  3,  3, CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "bita", OP_IX,             2, 0xa5,  4,  4,  CLR_V_CHG_NZ, cpu6811 },
-  { "bita", OP_IY | OP_PAGE2,  3, 0xa5,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "bita", OP_IDX,            2, 0xa5,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "bita", OP_IDX_1,          3, 0xa5,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "bita", OP_IDX_2,          4, 0xa5,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "bita", OP_D_IDX,          2, 0xa5,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-  { "bita", OP_D_IDX_2,        4, 0xa5,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "bitb", OP_IMM8,          2, 0xc5,  1,  1, CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "bitb", OP_DIRECT,        2, 0xd5,  3,  3, CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "bitb", OP_IND16,         3, 0xf5,  3,  3, CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "bitb", OP_IX,             2, 0xe5,  4,  4,  CLR_V_CHG_NZ, cpu6811 },
-  { "bitb", OP_IY | OP_PAGE2,  3, 0xe5,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "bitb", OP_IDX,            2, 0xe5,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "bitb", OP_IDX_1,          3, 0xe5,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "bitb", OP_IDX_2,          4, 0xe5,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "bitb", OP_D_IDX,          2, 0xe5,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-  { "bitb", OP_D_IDX_2,        4, 0xe5,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "ble", OP_JUMP_REL,        2, 0x2f,  1,  3, CHG_NONE, cpu6811 | cpu6812 },
-  { "blo", OP_JUMP_REL,        2, 0x25,  1,  3, CHG_NONE, cpu6811 | cpu6812 },
-  { "bls", OP_JUMP_REL,        2, 0x23,  1,  3, CHG_NONE, cpu6811 | cpu6812 },
-  { "blt", OP_JUMP_REL,        2, 0x2d,  1,  3, CHG_NONE, cpu6811 | cpu6812 },
-  { "bmi", OP_JUMP_REL,        2, 0x2b,  1,  3, CHG_NONE, cpu6811 | cpu6812 },
-  { "bne", OP_JUMP_REL,        2, 0x26,  1,  3, CHG_NONE, cpu6811 | cpu6812 },
-  { "bpl", OP_JUMP_REL,        2, 0x2a,  1,  3, CHG_NONE, cpu6811 | cpu6812 },
-  { "bra", OP_JUMP_REL,        2, 0x20,  1,  3, CHG_NONE, cpu6811 | cpu6812 },
+  { "bita", OP_IMM8,          2, 0x85,  1,  1, CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "bita", OP_DIRECT,        2, 0x95,  3,  3, CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "bita", OP_IND16,         3, 0xb5,  3,  3, CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "bita", OP_IX,             2, 0xa5,  4,  4,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "bita", OP_IY | OP_PAGE2,  3, 0xa5,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "bita", OP_IDX,            2, 0xa5,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "bita", OP_IDX_1,          3, 0xa5,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "bita", OP_IDX_2,          4, 0xa5,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "bita", OP_D_IDX,          2, 0xa5,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "bita", OP_D_IDX_2,        4, 0xa5,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "bitb", OP_IMM8,          2, 0xc5,  1,  1, CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "bitb", OP_DIRECT,        2, 0xd5,  3,  3, CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "bitb", OP_IND16,         3, 0xf5,  3,  3, CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "bitb", OP_IX,             2, 0xe5,  4,  4,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "bitb", OP_IY | OP_PAGE2,  3, 0xe5,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "bitb", OP_IDX,            2, 0xe5,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "bitb", OP_IDX_1,          3, 0xe5,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "bitb", OP_IDX_2,          4, 0xe5,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "bitb", OP_D_IDX,          2, 0xe5,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "bitb", OP_D_IDX_2,        4, 0xe5,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "bitx", OP_IMM16 | OP_PAGE2,          2, 0x85,  1,  1, CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "bitx", OP_DIRECT | OP_PAGE2,        2, 0x95,  3,  3, CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "bitx", OP_IND16 | OP_PAGE2,         3, 0xb5,  3,  3, CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "bitx", OP_IDX | OP_PAGE2,            2, 0xa5,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "bitx", OP_IDX_1 | OP_PAGE2,          3, 0xa5,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "bitx", OP_IDX_2 | OP_PAGE2,          4, 0xa5,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "bitx", OP_D_IDX | OP_PAGE2,          2, 0xa5,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "bitx", OP_D_IDX_2 | OP_PAGE2,        4, 0xa5,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "bity", OP_IMM16 | OP_PAGE2,          2, 0xc5,  1,  1, CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "bity", OP_DIRECT | OP_PAGE2,        2, 0xd5,  3,  3, CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "bity", OP_IND16 | OP_PAGE2,         3, 0xf5,  3,  3, CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "bity", OP_IDX | OP_PAGE2,            2, 0xe5,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "bity", OP_IDX_1 | OP_PAGE2,          3, 0xe5,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "bity", OP_IDX_2 | OP_PAGE2,          4, 0xe5,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "bity", OP_D_IDX | OP_PAGE2,          2, 0xe5,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "bity", OP_D_IDX_2 | OP_PAGE2,        4, 0xe5,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "ble", OP_JUMP_REL,        2, 0x2f,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
+  { "blo", OP_JUMP_REL,        2, 0x25,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
+  { "bls", OP_JUMP_REL,        2, 0x23,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
+  { "blt", OP_JUMP_REL,        2, 0x2d,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
+  { "bmi", OP_JUMP_REL,        2, 0x2b,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
+  { "bne", OP_JUMP_REL,        2, 0x26,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
+  { "bpl", OP_JUMP_REL,        2, 0x2a,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
+  { "bra", OP_JUMP_REL,        2, 0x20,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
 
   { "brclr", OP_BITMASK | OP_JUMP_REL
-           | OP_DIRECT,         4, 0x13,  6,  6, CHG_NONE, cpu6811 },
+           | OP_DIRECT,         4, 0x13,  6,  6, CHG_NONE, cpu6811, 0 },
   { "brclr", OP_BITMASK | OP_JUMP_REL
-           | OP_IX,             4, 0x1f,  7,  7, CHG_NONE, cpu6811 },
+           | OP_IX,             4, 0x1f,  7,  7, CHG_NONE, cpu6811, 0 },
   { "brclr", OP_BITMASK | OP_JUMP_REL
-           | OP_IY | OP_PAGE2,  5, 0x1f,  8,  8, CHG_NONE, cpu6811 },
+           | OP_IY | OP_PAGE2,  5, 0x1f,  8,  8, CHG_NONE, cpu6811, 0 },
   { "brclr", OP_BITMASK | OP_JUMP_REL
-           | OP_DIRECT,         4, 0x4f,  4,  4,  CHG_NONE, cpu6812 },
+           | OP_DIRECT,         4, 0x4f,  4,  4,  CHG_NONE, cpu6812|cpu9s12x, 0 },
   { "brclr", OP_BITMASK | OP_JUMP_REL
-           | OP_IND16,          5, 0x1f,  5,  5,  CHG_NONE, cpu6812 },
+           | OP_IND16,          5, 0x1f,  5,  5,  CHG_NONE, cpu6812|cpu9s12x, 0 },
   { "brclr", OP_BITMASK | OP_JUMP_REL
-           | OP_IDX,            4, 0x0f,  4,  4,  CHG_NONE, cpu6812 },
+           | OP_IDX,            4, 0x0f,  4,  4,  CHG_NONE, cpu6812|cpu9s12x, 0 },
   { "brclr", OP_BITMASK | OP_JUMP_REL
-           | OP_IDX_1,          5, 0x0f,  6,  6,  CHG_NONE, cpu6812 },
+           | OP_IDX_1,          5, 0x0f,  6,  6,  CHG_NONE, cpu6812|cpu9s12x, 0 },
   { "brclr", OP_BITMASK
            | OP_JUMP_REL
-           | OP_IDX_2,          6, 0x0f,  8,  8,  CHG_NONE, cpu6812 },
+           | OP_IDX_2,          6, 0x0f,  8,  8,  CHG_NONE, cpu6812|cpu9s12x, 0 },
 
-  { "brn", OP_JUMP_REL,         2, 0x21,  1,  3,  CHG_NONE, cpu6811|cpu6812 },
+  { "brn", OP_JUMP_REL,         2, 0x21,  1,  3,  CHG_NONE, cpu6811|cpu6812|cpu9s12x, 0 },
 
   { "brset", OP_BITMASK | OP_JUMP_REL
-           | OP_DIRECT,         4, 0x12,  6,  6,  CHG_NONE, cpu6811 },
+           | OP_DIRECT,         4, 0x12,  6,  6,  CHG_NONE, cpu6811, 0 },
   { "brset", OP_BITMASK
            | OP_JUMP_REL
-           | OP_IX,             4, 0x1e,  7,  7,  CHG_NONE, cpu6811 },
+           | OP_IX,             4, 0x1e,  7,  7,  CHG_NONE, cpu6811, 0 },
   { "brset", OP_BITMASK | OP_JUMP_REL
-           | OP_IY | OP_PAGE2,  5, 0x1e,  8,  8,  CHG_NONE, cpu6811 },
+           | OP_IY | OP_PAGE2,  5, 0x1e,  8,  8,  CHG_NONE, cpu6811, 0 },
   { "brset", OP_BITMASK | OP_JUMP_REL
-           | OP_DIRECT,   4, 0x4e,  4,  4,  CHG_NONE, cpu6812 },
+           | OP_DIRECT,   4, 0x4e,  4,  4,  CHG_NONE, cpu6812|cpu9s12x, 0 },
   { "brset", OP_BITMASK | OP_JUMP_REL
-           | OP_IND16,    5, 0x1e,  5,  5,  CHG_NONE, cpu6812 },
+           | OP_IND16,    5, 0x1e,  5,  5,  CHG_NONE, cpu6812|cpu9s12x, 0 },
   { "brset", OP_BITMASK | OP_JUMP_REL
-           | OP_IDX,            4, 0x0e,  4,  4,  CHG_NONE, cpu6812 },
+           | OP_IDX,            4, 0x0e,  4,  4,  CHG_NONE, cpu6812|cpu9s12x, 0 },
   { "brset", OP_BITMASK | OP_JUMP_REL
-           | OP_IDX_1,          5, 0x0e,  6,  6,  CHG_NONE, cpu6812 },
+           | OP_IDX_1,          5, 0x0e,  6,  6,  CHG_NONE, cpu6812|cpu9s12x, 0 },
   { "brset", OP_BITMASK | OP_JUMP_REL
-           | OP_IDX_2,          6, 0x0e,  8,  8,  CHG_NONE, cpu6812 },
+           | OP_IDX_2,          6, 0x0e,  8,  8,  CHG_NONE, cpu6812|cpu9s12x, 0 },
 
 
-  { "bset", OP_BITMASK | OP_DIRECT,   3, 0x14,  6,  6, CLR_V_CHG_NZ, cpu6811 },
-  { "bset", OP_BITMASK | OP_IX,       3, 0x1c,  7,  7, CLR_V_CHG_NZ, cpu6811 },
-  { "bset", OP_BITMASK|OP_IY|OP_PAGE2, 4, 0x1c, 8, 8, CLR_V_CHG_NZ, cpu6811 },
-  { "bset", OP_BITMASK|OP_DIRECT,   3, 0x4c,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "bset", OP_BITMASK|OP_IND16,    4, 0x1c,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "bset", OP_BITMASK|OP_IDX,      3, 0x0c,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "bset", OP_BITMASK|OP_IDX_1,    4, 0x0c,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "bset", OP_BITMASK|OP_IDX_2,    5, 0x0c,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
+  { "bset", OP_BITMASK | OP_DIRECT,   3, 0x14,  6,  6, CLR_V_CHG_NZ, cpu6811, 0 },
+  { "bset", OP_BITMASK | OP_IX,       3, 0x1c,  7,  7, CLR_V_CHG_NZ, cpu6811, 0 },
+  { "bset", OP_BITMASK|OP_IY|OP_PAGE2, 4, 0x1c, 8, 8, CLR_V_CHG_NZ, cpu6811, 0 },
+  { "bset", OP_BITMASK|OP_DIRECT,   3, 0x4c,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "bset", OP_BITMASK|OP_IND16,    4, 0x1c,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "bset", OP_BITMASK|OP_IDX,      3, 0x0c,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "bset", OP_BITMASK|OP_IDX_1,    4, 0x0c,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "bset", OP_BITMASK|OP_IDX_2,    5, 0x0c,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "bsr",  OP_JUMP_REL,       2, 0x8d,  6,  6, CHG_NONE, cpu6811, 0 },
+  { "bsr",  OP_JUMP_REL,       2, 0x07,  4,  4, CHG_NONE, cpu6812|cpu9s12x, 0 },
+
+  { "btas", OP_BITMASK|OP_DIRECT | OP_PAGE2,   3, 0x35,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "btas", OP_BITMASK|OP_IND16 | OP_PAGE2,    4, 0x36,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "btas", OP_BITMASK|OP_IDX | OP_PAGE2,      3, 0x37,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "btas", OP_BITMASK|OP_IDX_1 | OP_PAGE2,    4, 0x37,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "btas", OP_BITMASK|OP_IDX_2 | OP_PAGE2,    5, 0x37,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
 
-  { "bsr",  OP_JUMP_REL,       2, 0x8d,  6,  6, CHG_NONE, cpu6811 },
-  { "bsr",  OP_JUMP_REL,       2, 0x07,  4,  4, CHG_NONE, cpu6812 },
-
-  { "bvc",  OP_JUMP_REL,       2, 0x28,  1,  3, CHG_NONE, cpu6811 | cpu6812 },
-  { "bvs",  OP_JUMP_REL,       2, 0x29,  1,  3, CHG_NONE, cpu6811 | cpu6812 },
+  { "bvc",  OP_JUMP_REL,       2, 0x28,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
+  { "bvs",  OP_JUMP_REL,       2, 0x29,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
 
   { "call", OP_IND16 | OP_PAGE
-          | OP_BRANCH,         4, 0x4a,  8,  8,  CHG_NONE, cpu6812 },
+          | OP_BRANCH,         4, 0x4a,  8,  8,  CHG_NONE, cpu6812|cpu9s12x, 0 },
   { "call", OP_IDX | OP_PAGE
-          | OP_BRANCH,         3, 0x4b,  8,  8,  CHG_NONE, cpu6812 },
+          | OP_BRANCH,         3, 0x4b,  8,  8,  CHG_NONE, cpu6812|cpu9s12x, 0 },
   { "call", OP_IDX_1 | OP_PAGE
-          | OP_BRANCH,         4, 0x4b,  8,  8,  CHG_NONE, cpu6812 },
+          | OP_BRANCH,         4, 0x4b,  8,  8,  CHG_NONE, cpu6812|cpu9s12x, 0 },
   { "call", OP_IDX_2 | OP_PAGE
-          | OP_BRANCH,         5, 0x4b,  9,  9,  CHG_NONE, cpu6812 },
+          | OP_BRANCH,         5, 0x4b,  9,  9,  CHG_NONE, cpu6812|cpu9s12x, 0 },
   { "call", OP_D_IDX
-          | OP_BRANCH,         2, 0x4b, 10, 10,  CHG_NONE, cpu6812 },
+          | OP_BRANCH,         2, 0x4b, 10, 10,  CHG_NONE, cpu6812|cpu9s12x, 0 },
   { "call", OP_D_IDX_2
-          | OP_BRANCH,         4, 0x4b, 10, 10,  CHG_NONE, cpu6812 },
+          | OP_BRANCH,         4, 0x4b, 10, 10,  CHG_NONE, cpu6812|cpu9s12x, 0 },
 
-  { "cba",  OP_NONE,           1, 0x11,  2,  2,  CHG_NZVC, cpu6811 },
-  { "cba",  OP_NONE | OP_PAGE2,2, 0x17,  2,  2,  CHG_NZVC, cpu6812 },
+  { "cba",  OP_NONE,           1, 0x11,  2,  2,  CHG_NZVC, cpu6811, 0 },
+  { "cba",  OP_NONE | OP_PAGE2,2, 0x17,  2,  2,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
 
-  { "clc",  OP_NONE,           1, 0x0c,  2,  2,  CLR_C, cpu6811 },
-  { "cli",  OP_NONE,           1, 0x0e,  2,  2,  CLR_I, cpu6811 },
+  { "clc",  OP_NONE,           1, 0x0c,  2,  2,  CLR_C, cpu6811, 0 },
+  { "cli",  OP_NONE,           1, 0x0e,  2,  2,  CLR_I, cpu6811, 0 },
 
-  { "clr", OP_IND16,           3, 0x7f,  6,  6,  SET_Z_CLR_NVC, cpu6811 },
-  { "clr", OP_IX,              2, 0x6f,  6,  6,  SET_Z_CLR_NVC, cpu6811 },
-  { "clr", OP_IY | OP_PAGE2,   3, 0x6f,  7,  7,  SET_Z_CLR_NVC, cpu6811 },
-  { "clr", OP_IND16,           3, 0x79,  3,  3,  SET_Z_CLR_NVC, cpu6812 },
-  { "clr", OP_IDX,             2, 0x69,  2,  2,  SET_Z_CLR_NVC, cpu6812 },
-  { "clr", OP_IDX_1,           3, 0x69,  3,  3,  SET_Z_CLR_NVC, cpu6812 },
-  { "clr", OP_IDX_2,           4, 0x69,  4,  4,  SET_Z_CLR_NVC, cpu6812 },
-  { "clr", OP_D_IDX,           2, 0x69,  5,  5,  SET_Z_CLR_NVC, cpu6812 },
-  { "clr", OP_D_IDX_2,         4, 0x69,  5,  5,  SET_Z_CLR_NVC, cpu6812 },
-
-  { "clra", OP_NONE,           1, 0x4f,  2,  2,  SET_Z_CLR_NVC, cpu6811 },
-  { "clrb", OP_NONE,           1, 0x5f,  2,  2,  SET_Z_CLR_NVC, cpu6811 },
-  { "clra", OP_NONE,           1, 0x87,  1,  1,  SET_Z_CLR_NVC, cpu6812 },
-  { "clrb", OP_NONE,           1, 0xc7,  1,  1,  SET_Z_CLR_NVC, cpu6812 },
-
-  { "clv",  OP_NONE,           1, 0x0a,  2,  2,  CLR_V, cpu6811 },
-
-  { "cmpa", OP_IMM8,           2, 0x81,  1,  1,  CHG_NZVC, cpu6811|cpu6812 },
-  { "cmpa", OP_DIRECT,         2, 0x91,  3,  3,  CHG_NZVC, cpu6811|cpu6812 },
-  { "cmpa", OP_IND16,          3, 0xb1,  3,  3,  CHG_NZVC, cpu6811|cpu6812 },
-  { "cmpa", OP_IX,             2, 0xa1,  4,  4,  CHG_NZVC, cpu6811 },
-  { "cmpa", OP_IY | OP_PAGE2,  3, 0xa1,  5,  5,  CHG_NZVC, cpu6811 },
-  { "cmpa", OP_IDX,            2, 0xa1,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cmpa", OP_IDX_1,          3, 0xa1,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cmpa", OP_IDX_2,          4, 0xa1,  4,  4,  CHG_NZVC, cpu6812 },
-  { "cmpa", OP_D_IDX,          2, 0xa1,  6,  6,  CHG_NZVC, cpu6812 },
-  { "cmpa", OP_D_IDX_2,        4, 0xa1,  6,  6,  CHG_NZVC, cpu6812 },
-
-  { "cmpb", OP_IMM8,           2, 0xc1,  1,  1,  CHG_NZVC, cpu6811|cpu6812 },
-  { "cmpb", OP_DIRECT,         2, 0xd1,  3,  3,  CHG_NZVC, cpu6811|cpu6812 },
-  { "cmpb", OP_IND16,          3, 0xf1,  3,  3,  CHG_NZVC, cpu6811|cpu6812 },
-  { "cmpb", OP_IX,             2, 0xe1,  4,  4,  CHG_NZVC, cpu6811 },
-  { "cmpb", OP_IY | OP_PAGE2,  3, 0xe1,  5,  5,  CHG_NZVC, cpu6811 },
-  { "cmpb", OP_IDX,            2, 0xe1,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cmpb", OP_IDX_1,          3, 0xe1,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cmpb", OP_IDX_2,          4, 0xe1,  4,  4,  CHG_NZVC, cpu6812 },
-  { "cmpb", OP_D_IDX,          2, 0xe1,  6,  6,  CHG_NZVC, cpu6812 },
-  { "cmpb", OP_D_IDX_2,        4, 0xe1,  6,  6,  CHG_NZVC, cpu6812 },
-
-  { "com", OP_IND16,           3, 0x73,  6,  6,  SET_C_CLR_V_CHG_NZ, cpu6811 },
-  { "com", OP_IX,              2, 0x63,  6,  6,  SET_C_CLR_V_CHG_NZ, cpu6811 },
-  { "com", OP_IY | OP_PAGE2,   3, 0x63,  7,  7,  SET_C_CLR_V_CHG_NZ, cpu6811 },
-  { "com", OP_IND16,           3, 0x71,  4,  4,  SET_C_CLR_V_CHG_NZ, cpu6812 },
-  { "com", OP_IDX,             2, 0x61,  3,  3,  SET_C_CLR_V_CHG_NZ, cpu6812 },
-  { "com", OP_IDX_1,           3, 0x61,  4,  4,  SET_C_CLR_V_CHG_NZ, cpu6812 },
-  { "com", OP_IDX_2,           4, 0x61,  5,  5,  SET_C_CLR_V_CHG_NZ, cpu6812 },
-  { "com", OP_D_IDX,           2, 0x61,  6,  6,  SET_C_CLR_V_CHG_NZ, cpu6812 },
-  { "com", OP_D_IDX_2,         4, 0x61,  6,  6,  SET_C_CLR_V_CHG_NZ, cpu6812 },
-
-  { "coma", OP_NONE,           1, 0x43,  2,  2,  SET_C_CLR_V_CHG_NZ, cpu6811 },
-  { "coma", OP_NONE,           1, 0x41,  1,  1,  SET_C_CLR_V_CHG_NZ, cpu6812 },
-  { "comb", OP_NONE,           1, 0x53,  2,  2,  SET_C_CLR_V_CHG_NZ, cpu6811 },
-  { "comb", OP_NONE,           1, 0x51,  1,  1,  SET_C_CLR_V_CHG_NZ, cpu6812 },
-
-  { "cpd", OP_IMM16 | OP_PAGE3,  4, 0x83,  5,  5,  CHG_NZVC, cpu6811 },
-  { "cpd", OP_DIRECT | OP_PAGE3, 3, 0x93,  6,  6,  CHG_NZVC, cpu6811 },
-  { "cpd", OP_IND16 | OP_PAGE3,  4, 0xb3,  7,  7,  CHG_NZVC, cpu6811 },
-  { "cpd", OP_IX | OP_PAGE3,     3, 0xa3,  7,  7,  CHG_NZVC, cpu6811 },
-  { "cpd", OP_IY | OP_PAGE4,     3, 0xa3,  7,  7,  CHG_NZVC, cpu6811 },
-  { "cpd", OP_IMM16,             3, 0x8c,  2,  2,  CHG_NZVC, cpu6812 },
-  { "cpd", OP_DIRECT,            2, 0x9c,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cpd", OP_IND16,             3, 0xbc,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cpd", OP_IDX,               2, 0xac,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cpd", OP_IDX_1,             3, 0xac,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cpd", OP_IDX_2,             4, 0xac,  4,  4,  CHG_NZVC, cpu6812 },
-  { "cpd", OP_D_IDX,             2, 0xac,  6,  6,  CHG_NZVC, cpu6812 },
-  { "cpd", OP_D_IDX_2,           4, 0xac,  6,  6,  CHG_NZVC, cpu6812 },
-
-  { "cps", OP_IMM16,             3, 0x8f,  2,  2,  CHG_NZVC, cpu6812 },
-  { "cps", OP_DIRECT,            2, 0x9f,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cps", OP_IND16,             3, 0xbf,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cps", OP_IDX,               2, 0xaf,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cps", OP_IDX_1,             3, 0xaf,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cps", OP_IDX_2,             4, 0xaf,  4,  4,  CHG_NZVC, cpu6812 },
-  { "cps", OP_D_IDX,             2, 0xaf,  6,  6,  CHG_NZVC, cpu6812 },
-  { "cps", OP_D_IDX_2,           4, 0xaf,  6,  6,  CHG_NZVC, cpu6812 },
-
-  { "cpx", OP_IMM16,             3, 0x8c,  4,  4,  CHG_NZVC, cpu6811 },
-  { "cpx", OP_DIRECT,            2, 0x9c,  5,  5,  CHG_NZVC, cpu6811 },
-  { "cpx", OP_IND16,             3, 0xbc,  5,  5,  CHG_NZVC, cpu6811 },
-  { "cpx", OP_IX,                2, 0xac,  6,  6,  CHG_NZVC, cpu6811 },
-  { "cpx", OP_IY | OP_PAGE4,     3, 0xac,  7,  7,  CHG_NZVC, cpu6811 },
-  { "cpx", OP_IMM16,             3, 0x8e,  2,  2,  CHG_NZVC, cpu6812 },
-  { "cpx", OP_DIRECT,            2, 0x9e,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cpx", OP_IND16,             3, 0xbe,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cpx", OP_IDX,               2, 0xae,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cpx", OP_IDX_1,             3, 0xae,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cpx", OP_IDX_2,             4, 0xae,  4,  4,  CHG_NZVC, cpu6812 },
-  { "cpx", OP_D_IDX,             2, 0xae,  6,  6,  CHG_NZVC, cpu6812 },
-  { "cpx", OP_D_IDX_2,           4, 0xae,  6,  6,  CHG_NZVC, cpu6812 },
-
-  { "cpy", OP_PAGE2 | OP_IMM16,  4, 0x8c,  5,  5,  CHG_NZVC, cpu6811 },
-  { "cpy", OP_PAGE2 | OP_DIRECT, 3, 0x9c,  6,  6,  CHG_NZVC, cpu6811 },
-  { "cpy", OP_PAGE2 | OP_IY,     3, 0xac,  7,  7,  CHG_NZVC, cpu6811 },
-  { "cpy", OP_PAGE2 | OP_IND16,  4, 0xbc,  7,  7,  CHG_NZVC, cpu6811 },
-  { "cpy", OP_PAGE3 | OP_IX,     3, 0xac,  7,  7,  CHG_NZVC, cpu6811 },
-  { "cpy", OP_IMM16,             3, 0x8d,  2,  2,  CHG_NZVC, cpu6812 },
-  { "cpy", OP_DIRECT,            2, 0x9d,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cpy", OP_IND16,             3, 0xbd,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cpy", OP_IDX,               2, 0xad,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cpy", OP_IDX_1,             3, 0xad,  3,  3,  CHG_NZVC, cpu6812 },
-  { "cpy", OP_IDX_2,             4, 0xad,  4,  4,  CHG_NZVC, cpu6812 },
-  { "cpy", OP_D_IDX,             2, 0xad,  6,  6,  CHG_NZVC, cpu6812 },
-  { "cpy", OP_D_IDX_2,           4, 0xad,  6,  6,  CHG_NZVC, cpu6812 },
+  { "clr", OP_IND16,           3, 0x7f,  6,  6,  SET_Z_CLR_NVC, cpu6811, 0 },
+  { "clr", OP_IX,              2, 0x6f,  6,  6,  SET_Z_CLR_NVC, cpu6811, 0 },
+  { "clr", OP_IY | OP_PAGE2,   3, 0x6f,  7,  7,  SET_Z_CLR_NVC, cpu6811, 0 },
+  { "clr", OP_IND16,           3, 0x79,  3,  3,  SET_Z_CLR_NVC, cpu6812|cpu9s12x, 0 },
+  { "clr", OP_IDX,             2, 0x69,  2,  2,  SET_Z_CLR_NVC, cpu6812|cpu9s12x, 0 },
+  { "clr", OP_IDX_1,           3, 0x69,  3,  3,  SET_Z_CLR_NVC, cpu6812|cpu9s12x, 0 },
+  { "clr", OP_IDX_2,           4, 0x69,  4,  4,  SET_Z_CLR_NVC, cpu6812|cpu9s12x, 0 },
+  { "clr", OP_D_IDX,           2, 0x69,  5,  5,  SET_Z_CLR_NVC, cpu6812|cpu9s12x, 0 },
+  { "clr", OP_D_IDX_2,         4, 0x69,  5,  5,  SET_Z_CLR_NVC, cpu6812|cpu9s12x, 0 },
+
+  { "clra", OP_NONE,           1, 0x4f,  2,  2,  SET_Z_CLR_NVC, cpu6811, 0 },
+  { "clrb", OP_NONE,           1, 0x5f,  2,  2,  SET_Z_CLR_NVC, cpu6811, 0 },
+  { "clra", OP_NONE,           1, 0x87,  1,  1,  SET_Z_CLR_NVC, cpu6812|cpu9s12x, 0 },
+  { "clrb", OP_NONE,           1, 0xc7,  1,  1,  SET_Z_CLR_NVC, cpu6812|cpu9s12x, 0 },
+
+  { "clrw",  OP_IND16 | OP_PAGE2,          3, 0x79,  4,  4,  SET_Z_CLR_NVC, cpu9s12x, 0 },
+  { "clrw",  OP_IDX | OP_PAGE2,            2, 0x69,  3,  3,  SET_Z_CLR_NVC, cpu9s12x, 0 },
+  { "clrw",  OP_IDX_1 | OP_PAGE2,          3, 0x69,  4,  4,  SET_Z_CLR_NVC, cpu9s12x, 0 },
+  { "clrw",  OP_IDX_2 | OP_PAGE2,          4, 0x69,  5,  5,  SET_Z_CLR_NVC, cpu9s12x, 0 },
+  { "clrw",  OP_D_IDX | OP_PAGE2,          2, 0x69,  6,  6,  SET_Z_CLR_NVC, cpu9s12x, 0 },
+  { "clrw",  OP_D_IDX_2 | OP_PAGE2,        4, 0x69,  6,  6,  SET_Z_CLR_NVC, cpu9s12x, 0 },
+
+  { "clrx",  OP_NONE | OP_PAGE2,          3, 0x87,  4,  4,  SET_Z_CLR_NVC, cpu9s12x, 0 },
+
+  { "clry",  OP_NONE | OP_PAGE2,          3, 0xc7,  4,  4,  SET_Z_CLR_NVC, cpu9s12x, 0 },
+
+  { "clv",  OP_NONE,           1, 0x0a,  2,  2,  CLR_V, cpu6811, 0 },
+
+  { "cmpa", OP_IMM8,           2, 0x81,  1,  1,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "cmpa", OP_DIRECT,         2, 0x91,  3,  3,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "cmpa", OP_IND16,          3, 0xb1,  3,  3,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "cmpa", OP_IX,             2, 0xa1,  4,  4,  CHG_NZVC, cpu6811, 0 },
+  { "cmpa", OP_IY | OP_PAGE2,  3, 0xa1,  5,  5,  CHG_NZVC, cpu6811, 0 },
+  { "cmpa", OP_IDX,            2, 0xa1,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cmpa", OP_IDX_1,          3, 0xa1,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cmpa", OP_IDX_2,          4, 0xa1,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cmpa", OP_D_IDX,          2, 0xa1,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cmpa", OP_D_IDX_2,        4, 0xa1,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "cmpb", OP_IMM8,           2, 0xc1,  1,  1,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "cmpb", OP_DIRECT,         2, 0xd1,  3,  3,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "cmpb", OP_IND16,          3, 0xf1,  3,  3,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "cmpb", OP_IX,             2, 0xe1,  4,  4,  CHG_NZVC, cpu6811, 0 },
+  { "cmpb", OP_IY | OP_PAGE2,  3, 0xe1,  5,  5,  CHG_NZVC, cpu6811, 0 },
+  { "cmpb", OP_IDX,            2, 0xe1,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cmpb", OP_IDX_1,          3, 0xe1,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cmpb", OP_IDX_2,          4, 0xe1,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cmpb", OP_D_IDX,          2, 0xe1,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cmpb", OP_D_IDX_2,        4, 0xe1,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "com", OP_IND16,           3, 0x73,  6,  6,  SET_C_CLR_V_CHG_NZ, cpu6811, 0 },
+  { "com", OP_IX,              2, 0x63,  6,  6,  SET_C_CLR_V_CHG_NZ, cpu6811, 0 },
+  { "com", OP_IY | OP_PAGE2,   3, 0x63,  7,  7,  SET_C_CLR_V_CHG_NZ, cpu6811, 0 },
+  { "com", OP_IND16,           3, 0x71,  4,  4,  SET_C_CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "com", OP_IDX,             2, 0x61,  3,  3,  SET_C_CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "com", OP_IDX_1,           3, 0x61,  4,  4,  SET_C_CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "com", OP_IDX_2,           4, 0x61,  5,  5,  SET_C_CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "com", OP_D_IDX,           2, 0x61,  6,  6,  SET_C_CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "com", OP_D_IDX_2,         4, 0x61,  6,  6,  SET_C_CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "coma", OP_NONE,           1, 0x43,  2,  2,  SET_C_CLR_V_CHG_NZ, cpu6811, 0 },
+  { "coma", OP_NONE,           1, 0x41,  1,  1,  SET_C_CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "comb", OP_NONE,           1, 0x53,  2,  2,  SET_C_CLR_V_CHG_NZ, cpu6811, 0 },
+  { "comb", OP_NONE,           1, 0x51,  1,  1,  SET_C_CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "comw",  OP_IND16 | OP_PAGE2,          3, 0x71,  4,  4,  SET_C_CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "comw",  OP_IDX | OP_PAGE2,            2, 0x61,  3,  3,  SET_C_CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "comw",  OP_IDX_1 | OP_PAGE2,          3, 0x61,  4,  4,  SET_C_CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "comw",  OP_IDX_2 | OP_PAGE2,          4, 0x61,  5,  5,  SET_C_CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "comw",  OP_D_IDX | OP_PAGE2,          2, 0x61,  6,  6,  SET_C_CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "comw",  OP_D_IDX_2 | OP_PAGE2,        4, 0x61,  6,  6,  SET_C_CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "comx", OP_NONE | OP_PAGE2,           1, 0x41,  2,  2,  SET_C_CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "comy", OP_NONE | OP_PAGE2,           1, 0x51,  2,  2,  SET_C_CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "cpd", OP_IMM16 | OP_PAGE3,  4, 0x83,  5,  5,  CHG_NZVC, cpu6811, 0 },
+  { "cpd", OP_DIRECT | OP_PAGE3, 3, 0x93,  6,  6,  CHG_NZVC, cpu6811, 0 },
+  { "cpd", OP_IND16 | OP_PAGE3,  4, 0xb3,  7,  7,  CHG_NZVC, cpu6811, 0 },
+  { "cpd", OP_IX | OP_PAGE3,     3, 0xa3,  7,  7,  CHG_NZVC, cpu6811, 0 },
+  { "cpd", OP_IY | OP_PAGE4,     3, 0xa3,  7,  7,  CHG_NZVC, cpu6811, 0 },
+  { "cpd", OP_IMM16,             3, 0x8c,  2,  2,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpd", OP_DIRECT,            2, 0x9c,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpd", OP_IND16,             3, 0xbc,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpd", OP_IDX,               2, 0xac,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpd", OP_IDX_1,             3, 0xac,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpd", OP_IDX_2,             4, 0xac,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpd", OP_D_IDX,             2, 0xac,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpd", OP_D_IDX_2,           4, 0xac,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "cped", OP_IMM16 | OP_PAGE2,             3, 0x8c,  2,  2,  CHG_NZVC, cpu9s12x, 0 },
+  { "cped", OP_DIRECT | OP_PAGE2,            2, 0x9c,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "cped", OP_IND16 | OP_PAGE2,             3, 0xbc,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "cped", OP_IDX | OP_PAGE2,               2, 0xac,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "cped", OP_IDX_1 | OP_PAGE2,             3, 0xac,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "cped", OP_IDX_2 | OP_PAGE2,             4, 0xac,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "cped", OP_D_IDX | OP_PAGE2,             2, 0xac,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "cped", OP_D_IDX_2 | OP_PAGE2,           4, 0xac,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "cpes", OP_IMM16 | OP_PAGE2,             3, 0x8f,  2,  2,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpes", OP_DIRECT | OP_PAGE2,            2, 0x9f,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpes", OP_IND16 | OP_PAGE2,             3, 0xbf,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpes", OP_IDX | OP_PAGE2,               2, 0xaf,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpes", OP_IDX_1 | OP_PAGE2,             3, 0xaf,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpes", OP_IDX_2 | OP_PAGE2,             4, 0xaf,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpes", OP_D_IDX | OP_PAGE2,             2, 0xaf,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpes", OP_D_IDX_2 | OP_PAGE2,           4, 0xaf,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "cpex", OP_IMM16 | OP_PAGE2,             3, 0x8e,  2,  2,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpex", OP_DIRECT | OP_PAGE2,            2, 0x9e,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpex", OP_IND16 | OP_PAGE2,             3, 0xbe,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpex", OP_IDX | OP_PAGE2,               2, 0xae,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpex", OP_IDX_1 | OP_PAGE2,             3, 0xae,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpex", OP_IDX_2 | OP_PAGE2,             4, 0xae,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpex", OP_D_IDX | OP_PAGE2,             2, 0xae,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpex", OP_D_IDX_2 | OP_PAGE2,           4, 0xae,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "cpey", OP_IMM16 | OP_PAGE2,             3, 0x8d,  2,  2,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpey", OP_DIRECT | OP_PAGE2,            2, 0x9d,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpey", OP_IND16 | OP_PAGE2,             3, 0xbd,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpey", OP_IDX | OP_PAGE2,               2, 0xad,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpey", OP_IDX_1 | OP_PAGE2,             3, 0xad,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpey", OP_IDX_2 | OP_PAGE2,             4, 0xad,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpey", OP_D_IDX | OP_PAGE2,             2, 0xad,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "cpey", OP_D_IDX_2 | OP_PAGE2,           4, 0xad,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "cps", OP_IMM16,             3, 0x8f,  2,  2,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cps", OP_DIRECT,            2, 0x9f,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cps", OP_IND16,             3, 0xbf,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cps", OP_IDX,               2, 0xaf,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cps", OP_IDX_1,             3, 0xaf,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cps", OP_IDX_2,             4, 0xaf,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cps", OP_D_IDX,             2, 0xaf,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cps", OP_D_IDX_2,           4, 0xaf,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "cpx", OP_IMM16,             3, 0x8c,  4,  4,  CHG_NZVC, cpu6811, 0 },
+  { "cpx", OP_DIRECT,            2, 0x9c,  5,  5,  CHG_NZVC, cpu6811, 0 },
+  { "cpx", OP_IND16,             3, 0xbc,  5,  5,  CHG_NZVC, cpu6811, 0 },
+  { "cpx", OP_IX,                2, 0xac,  6,  6,  CHG_NZVC, cpu6811, 0 },
+  { "cpx", OP_IY | OP_PAGE4,     3, 0xac,  7,  7,  CHG_NZVC, cpu6811, 0 },
+  { "cpx", OP_IMM16,             3, 0x8e,  2,  2,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpx", OP_DIRECT,            2, 0x9e,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpx", OP_IND16,             3, 0xbe,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpx", OP_IDX,               2, 0xae,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpx", OP_IDX_1,             3, 0xae,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpx", OP_IDX_2,             4, 0xae,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpx", OP_D_IDX,             2, 0xae,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpx", OP_D_IDX_2,           4, 0xae,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "cpy", OP_PAGE2 | OP_IMM16,  4, 0x8c,  5,  5,  CHG_NZVC, cpu6811, 0 },
+  { "cpy", OP_PAGE2 | OP_DIRECT, 3, 0x9c,  6,  6,  CHG_NZVC, cpu6811, 0 },
+  { "cpy", OP_PAGE2 | OP_IY,     3, 0xac,  7,  7,  CHG_NZVC, cpu6811, 0 },
+  { "cpy", OP_PAGE2 | OP_IND16,  4, 0xbc,  7,  7,  CHG_NZVC, cpu6811, 0 },
+  { "cpy", OP_PAGE3 | OP_IX,     3, 0xac,  7,  7,  CHG_NZVC, cpu6811, 0 },
+  { "cpy", OP_IMM16,             3, 0x8d,  2,  2,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpy", OP_DIRECT,            2, 0x9d,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpy", OP_IND16,             3, 0xbd,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpy", OP_IDX,               2, 0xad,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpy", OP_IDX_1,             3, 0xad,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpy", OP_IDX_2,             4, 0xad,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpy", OP_D_IDX,             2, 0xad,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "cpy", OP_D_IDX_2,           4, 0xad,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
 
   /* After 'daa', the Z flag is undefined. Mark it as changed.  */
-  { "daa", OP_NONE,              1, 0x19,  2,  2,  CHG_NZVC, cpu6811 },
-  { "daa", OP_NONE | OP_PAGE2,  2, 0x07,  3,  3,  CHG_NZVC, cpu6812 },
+  { "daa", OP_NONE,              1, 0x19,  2,  2,  CHG_NZVC, cpu6811, 0 },
+  { "daa", OP_NONE | OP_PAGE2,  2, 0x07,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
 
   { "dbeq", OP_DBEQ_MARKER
-          | OP_REG | OP_JUMP_REL,3, 0x04,  3,  3, CHG_NONE, cpu6812 },
+          | OP_REG | OP_JUMP_REL,3, 0x04,  3,  3, CHG_NONE, cpu6812|cpu9s12x, 0 },
   { "dbne", OP_DBNE_MARKER
-          | OP_REG | OP_JUMP_REL,3, 0x04,  3,  3, CHG_NONE, cpu6812 },
+          | OP_REG | OP_JUMP_REL,3, 0x04,  3,  3, CHG_NONE, cpu6812|cpu9s12x, 0 },
 
-  { "dec", OP_IX,                2, 0x6a,  6,  6,  CHG_NZV, cpu6811 },
-  { "dec", OP_IND16,             3, 0x7a,  6,  6,  CHG_NZV, cpu6811 },
-  { "dec", OP_IY | OP_PAGE2,     3, 0x6a,  7,  7,  CHG_NZV, cpu6811 },
-  { "dec", OP_IND16,             3, 0x73,  4,  4,  CHG_NZV, cpu6812 },
-  { "dec", OP_IDX,               2, 0x63,  3,  3,  CHG_NZV, cpu6812 },
-  { "dec", OP_IDX_1,             3, 0x63,  4,  4,  CHG_NZV, cpu6812 },
-  { "dec", OP_IDX_2,             4, 0x63,  5,  5,  CHG_NZV, cpu6812 },
-  { "dec", OP_D_IDX,             2, 0x63,  6,  6,  CHG_NZV, cpu6812 },
-  { "dec", OP_D_IDX_2,           4, 0x63,  6,  6,  CHG_NZV, cpu6812 },
-
-  { "des",  OP_NONE,             1, 0x34,  3,  3,  CHG_NONE, cpu6811 },
-
-  { "deca", OP_NONE,             1, 0x4a,  2,  2,  CHG_NZV, cpu6811 },
-  { "deca", OP_NONE,             1, 0x43,  1,  1,  CHG_NZV, cpu6812 },
-  { "decb", OP_NONE,             1, 0x5a,  2,  2,  CHG_NZV, cpu6811 },
-  { "decb", OP_NONE,             1, 0x53,  1,  1,  CHG_NZV, cpu6812 },
-
-  { "dex",  OP_NONE,             1, 0x09,  1,  1,  CHG_Z, cpu6812|cpu6811 },
-  { "dey",  OP_NONE | OP_PAGE2,  2, 0x09,  4,  4,  CHG_Z, cpu6811 },
-  { "dey",  OP_NONE,             1, 0x03,  1,  1,  CHG_Z, cpu6812 },
-
-  { "ediv", OP_NONE,             1, 0x11,  11,  11,  CHG_NZVC, cpu6812 },
-  { "edivs", OP_NONE | OP_PAGE2, 2, 0x14,  12,  12,  CHG_NZVC, cpu6812 },
-  { "emacs", OP_IND16 | OP_PAGE2, 4, 0x12,  13,  13,  CHG_NZVC, cpu6812 },
-
-  { "emaxd", OP_IDX | OP_PAGE2,     3, 0x1a,  4,  4,  CHG_NZVC, cpu6812 },
-  { "emaxd", OP_IDX_1 | OP_PAGE2,   4, 0x1a,  4,  4,  CHG_NZVC, cpu6812 },
-  { "emaxd", OP_IDX_2 | OP_PAGE2,   5, 0x1a,  5,  5,  CHG_NZVC, cpu6812 },
-  { "emaxd", OP_D_IDX | OP_PAGE2,   3, 0x1a,  7,  7,  CHG_NZVC, cpu6812 },
-  { "emaxd", OP_D_IDX_2 | OP_PAGE2, 5, 0x1a,  7,  7,  CHG_NZVC, cpu6812 },
-
-  { "emaxm", OP_IDX | OP_PAGE2,     3, 0x1e,  4,  4,  CHG_NZVC, cpu6812 },
-  { "emaxm", OP_IDX_1 | OP_PAGE2,   4, 0x1e,  5,  5,  CHG_NZVC, cpu6812 },
-  { "emaxm", OP_IDX_2 | OP_PAGE2,   5, 0x1e,  6,  6,  CHG_NZVC, cpu6812 },
-  { "emaxm", OP_D_IDX | OP_PAGE2,   3, 0x1e,  7,  7,  CHG_NZVC, cpu6812 },
-  { "emaxm", OP_D_IDX_2 | OP_PAGE2, 5, 0x1e,  7,  7,  CHG_NZVC, cpu6812 },
-
-  { "emind", OP_IDX | OP_PAGE2,     3, 0x1b,  4,  4,  CHG_NZVC, cpu6812 },
-  { "emind", OP_IDX_1 | OP_PAGE2,   4, 0x1b,  4,  4,  CHG_NZVC, cpu6812 },
-  { "emind", OP_IDX_2 | OP_PAGE2,   5, 0x1b,  5,  5,  CHG_NZVC, cpu6812 },
-  { "emind", OP_D_IDX | OP_PAGE2,   3, 0x1b,  7,  7,  CHG_NZVC, cpu6812 },
-  { "emind", OP_D_IDX_2 | OP_PAGE2, 5, 0x1b,  7,  7,  CHG_NZVC, cpu6812 },
-
-  { "eminm", OP_IDX | OP_PAGE2,     3, 0x1f,  4,  4,  CHG_NZVC, cpu6812 },
-  { "eminm", OP_IDX_1 | OP_PAGE2,   4, 0x1f,  5,  5,  CHG_NZVC, cpu6812 },
-  { "eminm", OP_IDX_2 | OP_PAGE2,   5, 0x1f,  6,  6,  CHG_NZVC, cpu6812 },
-  { "eminm", OP_D_IDX | OP_PAGE2,   3, 0x1f,  7,  7,  CHG_NZVC, cpu6812 },
-  { "eminm", OP_D_IDX_2 | OP_PAGE2, 5, 0x1f,  7,  7,  CHG_NZVC, cpu6812 },
-
-  { "emul",  OP_NONE,               1, 0x13,  3,  3,  CHG_NZC, cpu6812 },
-  { "emuls", OP_NONE | OP_PAGE2,    2, 0x13,  3,  3,  CHG_NZC, cpu6812 },
-
-  { "eora", OP_IMM8,         2, 0x88,  1,  1,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "eora", OP_DIRECT,       2, 0x98,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "eora", OP_IND16,        3, 0xb8,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "eora", OP_IX,             2, 0xa8,  4,  4,  CLR_V_CHG_NZ, cpu6811 },
-  { "eora", OP_IY | OP_PAGE2,  3, 0xa8,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "eora", OP_IDX,            2, 0xa8,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "eora", OP_IDX_1,          3, 0xa8,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "eora", OP_IDX_2,          4, 0xa8,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "eora", OP_D_IDX,          2, 0xa8,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-  { "eora", OP_D_IDX_2,        4, 0xa8,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "eorb", OP_IMM8,         2, 0xc8,  1,  1,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "eorb", OP_DIRECT,       2, 0xd8,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "eorb", OP_IND16,        3, 0xf8,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "eorb", OP_IX,             2, 0xe8,  4,  4,  CLR_V_CHG_NZ, cpu6811 },
-  { "eorb", OP_IY | OP_PAGE2,  3, 0xe8,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "eorb", OP_IDX,            2, 0xe8,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "eorb", OP_IDX_1,          3, 0xe8,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "eorb", OP_IDX_2,          4, 0xe8,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "eorb", OP_D_IDX,          2, 0xe8,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-  { "eorb", OP_D_IDX_2,        4, 0xe8,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
+  { "dec", OP_IX,                2, 0x6a,  6,  6,  CHG_NZV, cpu6811, 0 },
+  { "dec", OP_IND16,             3, 0x7a,  6,  6,  CHG_NZV, cpu6811, 0 },
+  { "dec", OP_IY | OP_PAGE2,     3, 0x6a,  7,  7,  CHG_NZV, cpu6811, 0 },
+  { "dec", OP_IND16,             3, 0x73,  4,  4,  CHG_NZV, cpu6812|cpu9s12x, 0 },
+  { "dec", OP_IDX,               2, 0x63,  3,  3,  CHG_NZV, cpu6812|cpu9s12x, 0 },
+  { "dec", OP_IDX_1,             3, 0x63,  4,  4,  CHG_NZV, cpu6812|cpu9s12x, 0 },
+  { "dec", OP_IDX_2,             4, 0x63,  5,  5,  CHG_NZV, cpu6812|cpu9s12x, 0 },
+  { "dec", OP_D_IDX,             2, 0x63,  6,  6,  CHG_NZV, cpu6812|cpu9s12x, 0 },
+  { "dec", OP_D_IDX_2,           4, 0x63,  6,  6,  CHG_NZV, cpu6812|cpu9s12x, 0 },
+
+  { "des",  OP_NONE,             1, 0x34,  3,  3,  CHG_NONE, cpu6811, 0 },
+
+  { "deca", OP_NONE,             1, 0x4a,  2,  2,  CHG_NZV, cpu6811, 0 },
+  { "deca", OP_NONE,             1, 0x43,  1,  1,  CHG_NZV, cpu6812|cpu9s12x, 0 },
+  { "decb", OP_NONE,             1, 0x5a,  2,  2,  CHG_NZV, cpu6811, 0 },
+  { "decb", OP_NONE,             1, 0x53,  1,  1,  CHG_NZV, cpu6812|cpu9s12x, 0 },
+
+  { "decw",  OP_IND16 | OP_PAGE2,          3, 0x73,  4,  4,  CHG_NZV, cpu9s12x, 0 },
+  { "decw",  OP_IDX | OP_PAGE2,            2, 0x63,  3,  3,  CHG_NZV, cpu9s12x, 0 },
+  { "decw",  OP_IDX_1 | OP_PAGE2,          3, 0x63,  4,  4,  CHG_NZV, cpu9s12x, 0 },
+  { "decw",  OP_IDX_2 | OP_PAGE2,          4, 0x63,  5,  5,  CHG_NZV, cpu9s12x, 0 },
+  { "decw",  OP_D_IDX | OP_PAGE2,          2, 0x63,  6,  6,  CHG_NZV, cpu9s12x, 0 },
+  { "decw",  OP_D_IDX_2 | OP_PAGE2,        4, 0x63,  6,  6,  CHG_NZV, cpu9s12x, 0 },
+
+  { "decx",  OP_NONE | OP_PAGE2,          3, 0x43,  4,  4,  CHG_NZV, cpu9s12x, 0 },
+
+  { "decy",  OP_NONE | OP_PAGE2,          3, 0x53,  4,  4,  CHG_NZV, cpu9s12x, 0 },
+
+  { "dex",  OP_NONE,             1, 0x09,  1,  1,  CHG_Z, cpu6812|cpu9s12x|cpu6811, 0 },
+  { "dey",  OP_NONE | OP_PAGE2,  2, 0x09,  4,  4,  CHG_Z, cpu6811, 0 },
+  { "dey",  OP_NONE,             1, 0x03,  1,  1,  CHG_Z, cpu6812|cpu9s12x, 0 },
+
+  { "ediv", OP_NONE,             1, 0x11,  11,  11,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "edivs", OP_NONE | OP_PAGE2, 2, 0x14,  12,  12,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "emacs", OP_IND16 | OP_PAGE2, 4, 0x12,  13,  13,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "emaxd", OP_IDX | OP_PAGE2,     3, 0x1a,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "emaxd", OP_IDX_1 | OP_PAGE2,   4, 0x1a,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "emaxd", OP_IDX_2 | OP_PAGE2,   5, 0x1a,  5,  5,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "emaxd", OP_D_IDX | OP_PAGE2,   3, 0x1a,  7,  7,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "emaxd", OP_D_IDX_2 | OP_PAGE2, 5, 0x1a,  7,  7,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "emaxm", OP_IDX | OP_PAGE2,     3, 0x1e,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "emaxm", OP_IDX_1 | OP_PAGE2,   4, 0x1e,  5,  5,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "emaxm", OP_IDX_2 | OP_PAGE2,   5, 0x1e,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "emaxm", OP_D_IDX | OP_PAGE2,   3, 0x1e,  7,  7,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "emaxm", OP_D_IDX_2 | OP_PAGE2, 5, 0x1e,  7,  7,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "emind", OP_IDX | OP_PAGE2,     3, 0x1b,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "emind", OP_IDX_1 | OP_PAGE2,   4, 0x1b,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "emind", OP_IDX_2 | OP_PAGE2,   5, 0x1b,  5,  5,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "emind", OP_D_IDX | OP_PAGE2,   3, 0x1b,  7,  7,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "emind", OP_D_IDX_2 | OP_PAGE2, 5, 0x1b,  7,  7,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "eminm", OP_IDX | OP_PAGE2,     3, 0x1f,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "eminm", OP_IDX_1 | OP_PAGE2,   4, 0x1f,  5,  5,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "eminm", OP_IDX_2 | OP_PAGE2,   5, 0x1f,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "eminm", OP_D_IDX | OP_PAGE2,   3, 0x1f,  7,  7,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "eminm", OP_D_IDX_2 | OP_PAGE2, 5, 0x1f,  7,  7,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "emul",  OP_NONE,               1, 0x13,  3,  3,  CHG_NZC, cpu6812|cpu9s12x, 0 },
+  { "emuls", OP_NONE | OP_PAGE2,    2, 0x13,  3,  3,  CHG_NZC, cpu6812|cpu9s12x, 0 },
+
+  { "eora", OP_IMM8,         2, 0x88,  1,  1,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "eora", OP_DIRECT,       2, 0x98,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "eora", OP_IND16,        3, 0xb8,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "eora", OP_IX,             2, 0xa8,  4,  4,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "eora", OP_IY | OP_PAGE2,  3, 0xa8,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "eora", OP_IDX,            2, 0xa8,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "eora", OP_IDX_1,          3, 0xa8,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "eora", OP_IDX_2,          4, 0xa8,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "eora", OP_D_IDX,          2, 0xa8,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "eora", OP_D_IDX_2,        4, 0xa8,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "eorb", OP_IMM8,         2, 0xc8,  1,  1,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "eorb", OP_DIRECT,       2, 0xd8,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "eorb", OP_IND16,        3, 0xf8,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "eorb", OP_IX,             2, 0xe8,  4,  4,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "eorb", OP_IY | OP_PAGE2,  3, 0xe8,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "eorb", OP_IDX,            2, 0xe8,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "eorb", OP_IDX_1,          3, 0xe8,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "eorb", OP_IDX_2,          4, 0xe8,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "eorb", OP_D_IDX,          2, 0xe8,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "eorb", OP_D_IDX_2,        4, 0xe8,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "eorx", OP_IMM16 | OP_PAGE2,         2, 0x88,  1,  1,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "eorx", OP_DIRECT | OP_PAGE2,       2, 0x98,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "eorx", OP_IND16 | OP_PAGE2,        3, 0xb8,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "eorx", OP_IDX | OP_PAGE2,            2, 0xa8,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "eorx", OP_IDX_1 | OP_PAGE2,          3, 0xa8,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "eorx", OP_IDX_2 | OP_PAGE2,          4, 0xa8,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "eorx", OP_D_IDX | OP_PAGE2,          2, 0xa8,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "eorx", OP_D_IDX_2 | OP_PAGE2,        4, 0xa8,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "eory", OP_IMM16 | OP_PAGE2,         2, 0xc8,  1,  1,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "eory", OP_DIRECT | OP_PAGE2,       2, 0xd8,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "eory", OP_IND16 | OP_PAGE2,        3, 0xf8,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "eory", OP_IDX | OP_PAGE2,            2, 0xe8,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "eory", OP_IDX_1 | OP_PAGE2,          3, 0xe8,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "eory", OP_IDX_2 | OP_PAGE2,          4, 0xe8,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "eory", OP_D_IDX | OP_PAGE2,          2, 0xe8,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "eory", OP_D_IDX_2 | OP_PAGE2,        4, 0xe8,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
 
-  { "etbl", OP_IDX | OP_PAGE2,3, 0x3f, 10, 10,  CHG_NZC, cpu6812 },
+  { "etbl", OP_IDX | OP_PAGE2,3, 0x3f, 10, 10,  CHG_NZC, cpu6812|cpu9s12x, 0 },
 
+/* FIXME S12X support more exg variants */
   { "exg",  OP_EXG_MARKER
-          | OP_REG | OP_REG_2, 2, 0xb7, 1, 1,  CHG_NONE, cpu6812 },
+          | OP_REG | OP_REG_2, 2, 0xb7, 1, 1,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+
+  { "fdiv", OP_NONE,             1, 0x03,  3, 41, CHG_ZVC, cpu6811, 0 },
+  { "fdiv", OP_NONE | OP_PAGE2, 2, 0x11, 12, 12, CHG_ZVC, cpu6812|cpu9s12x, 0 },
 
-  { "fdiv", OP_NONE,             1, 0x03,  3, 41, CHG_ZVC, cpu6811},
-  { "fdiv", OP_NONE | OP_PAGE2, 2, 0x11, 12, 12, CHG_ZVC, cpu6812 },
+  { "gldaa", OP_DIRECT | OP_PAGE2,       2, 0x96,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldaa", OP_IND16 | OP_PAGE2,        3, 0xb6,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldaa", OP_IDX | OP_PAGE2,            2, 0xa6,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldaa", OP_IDX_1 | OP_PAGE2,          3, 0xa6,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldaa", OP_IDX_2 | OP_PAGE2,          4, 0xa6,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldaa", OP_D_IDX | OP_PAGE2,          2, 0xa6,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldaa", OP_D_IDX_2 | OP_PAGE2,        4, 0xa6,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "gldab", OP_DIRECT | OP_PAGE2,       2, 0xd6,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldab", OP_IND16 | OP_PAGE2,        3, 0xf6,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldab", OP_IDX | OP_PAGE2,            2, 0xe6,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldab", OP_IDX_1 | OP_PAGE2,          3, 0xe6,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldab", OP_IDX_2 | OP_PAGE2,          4, 0xe6,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldab", OP_D_IDX | OP_PAGE2,          2, 0xe6,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldab", OP_D_IDX_2 | OP_PAGE2,        4, 0xe6,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "gldd", OP_DIRECT | OP_PAGE2,       2, 0xdc,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldd", OP_IND16 | OP_PAGE2,        3, 0xfc,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldd", OP_IDX | OP_PAGE2,            2, 0xec,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldd", OP_IDX_1 | OP_PAGE2,          3, 0xec,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldd", OP_IDX_2 | OP_PAGE2,          4, 0xec,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldd", OP_D_IDX | OP_PAGE2,          2, 0xec,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldd", OP_D_IDX_2 | OP_PAGE2,        4, 0xec,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "glds", OP_DIRECT | OP_PAGE2,       2, 0xdf,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "glds", OP_IND16 | OP_PAGE2,        3, 0xff,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "glds", OP_IDX | OP_PAGE2,            2, 0xef,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "glds", OP_IDX_1 | OP_PAGE2,          3, 0xef,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "glds", OP_IDX_2 | OP_PAGE2,          4, 0xef,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "glds", OP_D_IDX | OP_PAGE2,          2, 0xef,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "glds", OP_D_IDX_2 | OP_PAGE2,        4, 0xef,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "gldx", OP_DIRECT | OP_PAGE2,       2, 0xde,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldx", OP_IND16 | OP_PAGE2,        3, 0xfe,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldx", OP_IDX | OP_PAGE2,            2, 0xee,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldx", OP_IDX_1 | OP_PAGE2,          3, 0xee,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldx", OP_IDX_2 | OP_PAGE2,          4, 0xee,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldx", OP_D_IDX | OP_PAGE2,          2, 0xee,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldx", OP_D_IDX_2 | OP_PAGE2,        4, 0xee,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "gldy", OP_DIRECT | OP_PAGE2,       2, 0xdd,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldy", OP_IND16 | OP_PAGE2,        3, 0xfd,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldy", OP_IDX | OP_PAGE2,            2, 0xed,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldy", OP_IDX_1 | OP_PAGE2,          3, 0xed,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldy", OP_IDX_2 | OP_PAGE2,          4, 0xed,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldy", OP_D_IDX | OP_PAGE2,          2, 0xed,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gldy", OP_D_IDX_2 | OP_PAGE2,        4, 0xed,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "gstaa", OP_DIRECT | OP_PAGE2,       2, 0x5a,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstaa", OP_IND16 | OP_PAGE2,        3, 0x7a,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstaa", OP_IDX | OP_PAGE2,            2, 0x6a,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstaa", OP_IDX_1 | OP_PAGE2,          3, 0x6a,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstaa", OP_IDX_2 | OP_PAGE2,          4, 0x6a,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstaa", OP_D_IDX | OP_PAGE2,          2, 0x6a,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstaa", OP_D_IDX_2 | OP_PAGE2,        4, 0x6a,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "gstab", OP_DIRECT | OP_PAGE2,       2, 0x5b,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstab", OP_IND16 | OP_PAGE2,        3, 0x7b,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstab", OP_IDX | OP_PAGE2,            2, 0x6b,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstab", OP_IDX_1 | OP_PAGE2,          3, 0x6b,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstab", OP_IDX_2 | OP_PAGE2,          4, 0x6b,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstab", OP_D_IDX | OP_PAGE2,          2, 0x6b,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstab", OP_D_IDX_2 | OP_PAGE2,        4, 0x6b,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "gstd", OP_DIRECT | OP_PAGE2,       2, 0x5c,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstd", OP_IND16 | OP_PAGE2,        3, 0x7c,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstd", OP_IDX | OP_PAGE2,            2, 0x6c,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstd", OP_IDX_1 | OP_PAGE2,          3, 0x6c,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstd", OP_IDX_2 | OP_PAGE2,          4, 0x6c,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstd", OP_D_IDX | OP_PAGE2,          2, 0x6c,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstd", OP_D_IDX_2 | OP_PAGE2,        4, 0x6c,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "gsts", OP_DIRECT | OP_PAGE2,       2, 0x5f,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gsts", OP_IND16 | OP_PAGE2,        3, 0x6f,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gsts", OP_IDX | OP_PAGE2,            2, 0x6f,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gsts", OP_IDX_1 | OP_PAGE2,          3, 0x6f,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gsts", OP_IDX_2 | OP_PAGE2,          4, 0x6f,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gsts", OP_D_IDX | OP_PAGE2,          2, 0x6f,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gsts", OP_D_IDX_2 | OP_PAGE2,        4, 0x6f,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "gstx", OP_DIRECT | OP_PAGE2,       2, 0x5e,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstx", OP_IND16 | OP_PAGE2,        3, 0x7e,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstx", OP_IDX | OP_PAGE2,            2, 0x6e,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstx", OP_IDX_1 | OP_PAGE2,          3, 0x6e,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstx", OP_IDX_2 | OP_PAGE2,          4, 0x6e,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstx", OP_D_IDX | OP_PAGE2,          2, 0x6e,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gstx", OP_D_IDX_2 | OP_PAGE2,        4, 0x6e,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "gsty", OP_DIRECT | OP_PAGE2,       2, 0x5d,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gsty", OP_IND16 | OP_PAGE2,        3, 0x7d,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gsty", OP_IDX | OP_PAGE2,            2, 0x6d,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gsty", OP_IDX_1 | OP_PAGE2,          3, 0x6d,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gsty", OP_IDX_2 | OP_PAGE2,          4, 0x6d,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gsty", OP_D_IDX | OP_PAGE2,          2, 0x6d,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "gsty", OP_D_IDX_2 | OP_PAGE2,        4, 0x6d,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
 
   { "ibeq", OP_IBEQ_MARKER
-          | OP_REG | OP_JUMP_REL,  3, 0x04,  3,  3, CHG_NONE, cpu6812 },
+          | OP_REG | OP_JUMP_REL,  3, 0x04,  3,  3, CHG_NONE, cpu6812|cpu9s12x, 0 },
   { "ibne", OP_IBNE_MARKER
-          | OP_REG | OP_JUMP_REL,  3, 0x04,  3,  3, CHG_NONE, cpu6812 },
+          | OP_REG | OP_JUMP_REL,  3, 0x04,  3,  3, CHG_NONE, cpu6812|cpu9s12x, 0 },
 
-  { "idiv",  OP_NONE,              1, 0x02,  3, 41, CLR_V_CHG_ZC, cpu6811},
-  { "idiv",  OP_NONE | OP_PAGE2,  2, 0x10, 12, 12, CLR_V_CHG_ZC, cpu6812 },
-  { "idivs", OP_NONE | OP_PAGE2,  2, 0x15, 12, 12, CHG_NZVC, cpu6812 },
-
-  { "inc", OP_IX,                  2, 0x6c,  6,  6,  CHG_NZV, cpu6811 },
-  { "inc", OP_IND16,               3, 0x7c,  6,  6,  CHG_NZV, cpu6811 },
-  { "inc", OP_IY | OP_PAGE2,       3, 0x6c,  7,  7,  CHG_NZV, cpu6811 },
-  { "inc", OP_IND16,               3, 0x72,  4,  4,  CHG_NZV, cpu6812 },
-  { "inc", OP_IDX,                 2, 0x62,  3,  3,  CHG_NZV, cpu6812 },
-  { "inc", OP_IDX_1,               3, 0x62,  4,  4,  CHG_NZV, cpu6812 },
-  { "inc", OP_IDX_2,               4, 0x62,  5,  5,  CHG_NZV, cpu6812 },
-  { "inc", OP_D_IDX,               2, 0x62,  6,  6,  CHG_NZV, cpu6812 },
-  { "inc", OP_D_IDX_2,             4, 0x62,  6,  6,  CHG_NZV, cpu6812 },
-
-  { "inca", OP_NONE,               1, 0x4c,  2,  2,  CHG_NZV, cpu6811 },
-  { "inca", OP_NONE,               1, 0x42,  1,  1,  CHG_NZV, cpu6812 },
-  { "incb", OP_NONE,               1, 0x5c,  2,  2,  CHG_NZV, cpu6811 },
-  { "incb", OP_NONE,               1, 0x52,  1,  1,  CHG_NZV, cpu6812 },
-
-  { "ins",  OP_NONE,               1, 0x31,  3,  3,  CHG_NONE, cpu6811 },
-
-  { "inx",  OP_NONE,               1, 0x08,  1,  1,  CHG_Z, cpu6811|cpu6812 },
-  { "iny",  OP_NONE |OP_PAGE2,     2, 0x08,  4,  4,  CHG_Z, cpu6811 },
-  { "iny",  OP_NONE,               1, 0x02,  1,  1,  CHG_Z, cpu6812 },
-
-  { "jmp",  OP_IND16 | OP_BRANCH,  3, 0x7e,  3,  3,  CHG_NONE, cpu6811 },
-  { "jmp",  OP_IX,                 2, 0x6e,  3,  3,  CHG_NONE, cpu6811 },
-  { "jmp",  OP_IY | OP_PAGE2,      3, 0x6e,  4,  4,  CHG_NONE, cpu6811 },
-  { "jmp",  OP_IND16 | OP_BRANCH,  3, 0x06,  3,  3,  CHG_NONE, cpu6812 },
-  { "jmp",  OP_IDX,                2, 0x05,  3,  3,  CHG_NONE, cpu6812 },
-  { "jmp",  OP_IDX_1,              3, 0x05,  3,  3,  CHG_NONE, cpu6812 },
-  { "jmp",  OP_IDX_2,              4, 0x05,  4,  4,  CHG_NONE, cpu6812 },
-  { "jmp",  OP_D_IDX,              2, 0x05,  6,  6,  CHG_NONE, cpu6812 },
-  { "jmp",  OP_D_IDX_2,            4, 0x05,  6,  6,  CHG_NONE, cpu6812 },
-
-  { "jsr",  OP_DIRECT | OP_BRANCH, 2, 0x9d,  5,  5,  CHG_NONE, cpu6811 },
-  { "jsr",  OP_IND16 | OP_BRANCH,  3, 0xbd,  6,  6,  CHG_NONE, cpu6811 },
-  { "jsr",  OP_IX,                 2, 0xad,  6,  6,  CHG_NONE, cpu6811 },
-  { "jsr",  OP_IY | OP_PAGE2,      3, 0xad,  6,  6,  CHG_NONE, cpu6811 },
-  { "jsr",  OP_DIRECT | OP_BRANCH, 2, 0x17,  4,  4,  CHG_NONE, cpu6812 },
-  { "jsr",  OP_IND16 | OP_BRANCH,  3, 0x16,  4,  3,  CHG_NONE, cpu6812 },
-  { "jsr",  OP_IDX,                2, 0x15,  4,  4,  CHG_NONE, cpu6812 },
-  { "jsr",  OP_IDX_1,              3, 0x15,  4,  4,  CHG_NONE, cpu6812 },
-  { "jsr",  OP_IDX_2,              4, 0x15,  5,  5,  CHG_NONE, cpu6812 },
-  { "jsr",  OP_D_IDX,              2, 0x15,  7,  7,  CHG_NONE, cpu6812 },
-  { "jsr",  OP_D_IDX_2,            4, 0x15,  7,  7,  CHG_NONE, cpu6812 },
-
-  { "lbcc", OP_JUMP_REL16 | OP_PAGE2,  4, 0x24,  3,  4, CHG_NONE, cpu6812 },
-  { "lbcs", OP_JUMP_REL16 | OP_PAGE2,  4, 0x25,  3,  4, CHG_NONE, cpu6812 },
-  { "lbeq", OP_JUMP_REL16 | OP_PAGE2,  4, 0x27,  3,  4, CHG_NONE, cpu6812 },
-  { "lbge", OP_JUMP_REL16 | OP_PAGE2,  4, 0x2c,  3,  4, CHG_NONE, cpu6812 },
-  { "lbgt", OP_JUMP_REL16 | OP_PAGE2,  4, 0x2e,  3,  4, CHG_NONE, cpu6812 },
-  { "lbhi", OP_JUMP_REL16 | OP_PAGE2,  4, 0x22,  3,  4, CHG_NONE, cpu6812 },
-  { "lbhs", OP_JUMP_REL16 | OP_PAGE2,  4, 0x24,  3,  4, CHG_NONE, cpu6812 },
-  { "lble", OP_JUMP_REL16 | OP_PAGE2,  4, 0x2f,  3,  4, CHG_NONE, cpu6812 },
-  { "lblo", OP_JUMP_REL16 | OP_PAGE2,  4, 0x25,  3,  4, CHG_NONE, cpu6812 },
-  { "lbls", OP_JUMP_REL16 | OP_PAGE2,  4, 0x23,  3,  4, CHG_NONE, cpu6812 },
-  { "lblt", OP_JUMP_REL16 | OP_PAGE2,  4, 0x2d,  3,  4, CHG_NONE, cpu6812 },
-  { "lbmi", OP_JUMP_REL16 | OP_PAGE2,  4, 0x2b,  3,  4, CHG_NONE, cpu6812 },
-  { "lbne", OP_JUMP_REL16 | OP_PAGE2,  4, 0x26,  3,  4, CHG_NONE, cpu6812 },
-  { "lbpl", OP_JUMP_REL16 | OP_PAGE2,  4, 0x2a,  3,  4, CHG_NONE, cpu6812 },
-  { "lbra", OP_JUMP_REL16 | OP_PAGE2,  4, 0x20,  4,  4, CHG_NONE, cpu6812 },
-  { "lbrn", OP_JUMP_REL16 | OP_PAGE2,  4, 0x21,  3,  3, CHG_NONE, cpu6812 },
-  { "lbvc", OP_JUMP_REL16 | OP_PAGE2,  4, 0x28,  3,  4, CHG_NONE, cpu6812 },
-  { "lbvs", OP_JUMP_REL16 | OP_PAGE2,  4, 0x29,  3,  4, CHG_NONE, cpu6812 },
-
-  { "ldaa", OP_IMM8,         2, 0x86,  1,  1,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "ldaa", OP_DIRECT,       2, 0x96,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "ldaa", OP_IND16,        3, 0xb6,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "ldaa", OP_IX,             2, 0xa6,  4,  4,  CLR_V_CHG_NZ, cpu6811 },
-  { "ldaa", OP_IY | OP_PAGE2,  3, 0xa6,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "ldaa", OP_IDX,            2, 0xa6,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldaa", OP_IDX_1,          3, 0xa6,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldaa", OP_IDX_2,          4, 0xa6,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldaa", OP_D_IDX,          2, 0xa6,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldaa", OP_D_IDX_2,        4, 0xa6,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "ldab", OP_IMM8,         2, 0xc6,  1,  1,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "ldab", OP_DIRECT,       2, 0xd6,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "ldab", OP_IND16,        3, 0xf6,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "ldab", OP_IX,             2, 0xe6,  4,  4,  CLR_V_CHG_NZ, cpu6811 },
-  { "ldab", OP_IY | OP_PAGE2,  3, 0xe6,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "ldab", OP_IDX,            2, 0xe6,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldab", OP_IDX_1,          3, 0xe6,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldab", OP_IDX_2,          4, 0xe6,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldab", OP_D_IDX,          2, 0xe6,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldab", OP_D_IDX_2,        4, 0xe6,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "ldd", OP_IMM16,         3, 0xcc,  2,  2,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "ldd", OP_DIRECT,        2, 0xdc,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "ldd", OP_IND16,         3, 0xfc,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "ldd", OP_IX,              2, 0xec,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "ldd", OP_IY | OP_PAGE2,   3, 0xec,  6,  6,  CLR_V_CHG_NZ, cpu6811 },
-  { "ldd", OP_IDX,             2, 0xec,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldd", OP_IDX_1,           3, 0xec,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldd", OP_IDX_2,           4, 0xec,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldd", OP_D_IDX,           2, 0xec,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldd", OP_D_IDX_2,         4, 0xec,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "lds",  OP_IMM16,          3, 0x8e,  3,  3,  CLR_V_CHG_NZ, cpu6811 },
-  { "lds",  OP_DIRECT,         2, 0x9e,  4,  4,  CLR_V_CHG_NZ, cpu6811 },
-  { "lds",  OP_IND16,          3, 0xbe,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "lds",  OP_IX,             2, 0xae,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "lds",  OP_IY | OP_PAGE2,  3, 0xae,  6,  6,  CLR_V_CHG_NZ, cpu6811 },
-  { "lds",  OP_IMM16,          3, 0xcf,  2,  2,  CLR_V_CHG_NZ, cpu6812 },
-  { "lds",  OP_DIRECT,         2, 0xdf,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "lds",  OP_IND16,          3, 0xff,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "lds",  OP_IDX,            2, 0xef,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "lds",  OP_IDX_1,          3, 0xef,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "lds",  OP_IDX_2,          4, 0xef,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "lds",  OP_D_IDX,          2, 0xef,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-  { "lds",  OP_D_IDX_2,        4, 0xef,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "ldx",  OP_IMM16,        3, 0xce,  2,  2,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "ldx",  OP_DIRECT,       2, 0xde,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "ldx",  OP_IND16,        3, 0xfe,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "ldx",  OP_IX,             2, 0xee,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "ldx",  OP_IY | OP_PAGE4,  3, 0xee,  6,  6,  CLR_V_CHG_NZ, cpu6811 },
-  { "ldx",  OP_IDX,            2, 0xee,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldx",  OP_IDX_1,          3, 0xee,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldx",  OP_IDX_2,          4, 0xee,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldx",  OP_D_IDX,          2, 0xee,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldx",  OP_D_IDX_2,        4, 0xee,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "ldy",  OP_IMM16 | OP_PAGE2,  4, 0xce, 4, 4, CLR_V_CHG_NZ, cpu6811 },
-  { "ldy",  OP_DIRECT | OP_PAGE2, 3, 0xde, 5, 5, CLR_V_CHG_NZ, cpu6811 },
-  { "ldy",  OP_IND16 | OP_PAGE2,  4, 0xfe, 6, 6, CLR_V_CHG_NZ, cpu6811 },
-  { "ldy",  OP_IX | OP_PAGE3,     3, 0xee, 6, 6, CLR_V_CHG_NZ, cpu6811 },
-  { "ldy",  OP_IY | OP_PAGE2,     3, 0xee, 6, 6, CLR_V_CHG_NZ, cpu6811 },
-  { "ldy",  OP_IMM16,          3, 0xcd,  2,  2,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldy",  OP_DIRECT,         2, 0xdd,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldy",  OP_IND16,          3, 0xfd,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldy",  OP_IDX,            2, 0xed,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldy",  OP_IDX_1,          3, 0xed,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldy",  OP_IDX_2,          4, 0xed,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldy",  OP_D_IDX,          2, 0xed,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-  { "ldy",  OP_D_IDX_2,        4, 0xed,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "leas", OP_IDX,            2, 0x1b,  2,  2,  CHG_NONE, cpu6812 },
-  { "leas", OP_IDX_1,          3, 0x1b,  2,  2,  CHG_NONE, cpu6812 },
-  { "leas", OP_IDX_2,          4, 0x1b,  2,  2,  CHG_NONE, cpu6812 },
-
-  { "leax", OP_IDX,            2, 0x1a,  2,  2,  CHG_NONE, cpu6812 },
-  { "leax", OP_IDX_1,          3, 0x1a,  2,  2,  CHG_NONE, cpu6812 },
-  { "leax", OP_IDX_2,          4, 0x1a,  2,  2,  CHG_NONE, cpu6812 },
-
-  { "leay", OP_IDX,            2, 0x19,  2,  2,  CHG_NONE, cpu6812 },
-  { "leay", OP_IDX_1,          3, 0x19,  2,  2,  CHG_NONE, cpu6812 },
-  { "leay", OP_IDX_2,          4, 0x19,  2,  2,  CHG_NONE, cpu6812 },
-
-  { "lsl",  OP_IND16,          3, 0x78,  4,  4,  CHG_NZVC, cpu6811|cpu6812 },
-  { "lsl",  OP_IX,             2, 0x68,  6,  6,  CHG_NZVC, cpu6811 },
-  { "lsl",  OP_IY | OP_PAGE2,  3, 0x68,  7,  7,  CHG_NZVC, cpu6811 },
-  { "lsl",  OP_IDX,            2, 0x68,  3,  3,  CHG_NZVC, cpu6812 },
-  { "lsl",  OP_IDX_1,          3, 0x68,  4,  4,  CHG_NZVC, cpu6812 },
-  { "lsl",  OP_IDX_2,          4, 0x68,  5,  5,  CHG_NZVC, cpu6812 },
-  { "lsl",  OP_D_IDX,          2, 0x68,  6,  6,  CHG_NZVC, cpu6812 },
-  { "lsl",  OP_D_IDX_2,        4, 0x68,  6,  6,  CHG_NZVC, cpu6812 },
-
-  { "lsla", OP_NONE,           1, 0x48,  1,  1,  CHG_NZVC, cpu6811|cpu6812 },
-  { "lslb", OP_NONE,           1, 0x58,  1,  1,  CHG_NZVC, cpu6811|cpu6812 },
-  { "lsld", OP_NONE,           1, 0x05,  3,  3,  CHG_NZVC, cpu6811 },
-  { "lsld", OP_NONE,           1, 0x59,  1,  1,  CHG_NZVC, cpu6812 },
-
-  { "lsr",  OP_IND16,        3, 0x74,  4,  4,  CLR_N_CHG_ZVC, cpu6811|cpu6812},
-  { "lsr",  OP_IX,             2, 0x64,  6,  6,  CLR_N_CHG_ZVC, cpu6811 },
-  { "lsr",  OP_IY | OP_PAGE2,  3, 0x64,  7,  7,  CLR_V_CHG_ZVC, cpu6811 },
-  { "lsr",  OP_IDX,            2, 0x64,  3,  3,  CLR_N_CHG_ZVC, cpu6812 },
-  { "lsr",  OP_IDX_1,          3, 0x64,  4,  4,  CLR_N_CHG_ZVC, cpu6812 },
-  { "lsr",  OP_IDX_2,          4, 0x64,  5,  5,  CLR_N_CHG_ZVC, cpu6812 },
-  { "lsr",  OP_D_IDX,          2, 0x64,  6,  6,  CLR_N_CHG_ZVC, cpu6812 },
-  { "lsr",  OP_D_IDX_2,        4, 0x64,  6,  6,  CLR_N_CHG_ZVC, cpu6812 },
-
-  { "lsra", OP_NONE,         1, 0x44,  1,  1,  CLR_N_CHG_ZVC, cpu6811|cpu6812},
-  { "lsrb", OP_NONE,         1, 0x54,  1,  1,  CLR_N_CHG_ZVC, cpu6811|cpu6812},
-  { "lsrd", OP_NONE,           1, 0x04,  3,  3,  CLR_N_CHG_ZVC, cpu6811 },
-  { "lsrd", OP_NONE,           1, 0x49,  1,  1,  CLR_N_CHG_ZVC, cpu6812 },
-
-  { "maxa", OP_IDX | OP_PAGE2,     3, 0x18,  4,  4,  CHG_NZVC, cpu6812 },
-  { "maxa", OP_IDX_1 | OP_PAGE2,   4, 0x18,  4,  4,  CHG_NZVC, cpu6812 },
-  { "maxa", OP_IDX_2 | OP_PAGE2,   5, 0x18,  5,  5,  CHG_NZVC, cpu6812 },
-  { "maxa", OP_D_IDX | OP_PAGE2,   3, 0x18,  7,  7,  CHG_NZVC, cpu6812 },
-  { "maxa", OP_D_IDX_2 | OP_PAGE2, 5, 0x18,  7,  7,  CHG_NZVC, cpu6812 },
-
-  { "maxm", OP_IDX | OP_PAGE2,     3, 0x1c,  4,  4,  CHG_NZVC, cpu6812 },
-  { "maxm", OP_IDX_1 | OP_PAGE2,   4, 0x1c,  5,  5,  CHG_NZVC, cpu6812 },
-  { "maxm", OP_IDX_2 | OP_PAGE2,   5, 0x1c,  6,  6,  CHG_NZVC, cpu6812 },
-  { "maxm", OP_D_IDX | OP_PAGE2,   3, 0x1c,  7,  7,  CHG_NZVC, cpu6812 },
-  { "maxm", OP_D_IDX_2 | OP_PAGE2, 5, 0x1c,  7,  7,  CHG_NZVC, cpu6812 },
-
-  { "mem",  OP_NONE,                1, 0x01,  5,  5,  CHG_HNZVC, cpu6812 },
-
-  { "mina", OP_IDX | OP_PAGE2,     3, 0x19,  4,  4,  CHG_NZVC, cpu6812 },
-  { "mina", OP_IDX_1 | OP_PAGE2,   4, 0x19,  4,  4,  CHG_NZVC, cpu6812 },
-  { "mina", OP_IDX_2 | OP_PAGE2,   5, 0x19,  5,  5,  CHG_NZVC, cpu6812 },
-  { "mina", OP_D_IDX | OP_PAGE2,   3, 0x19,  7,  7,  CHG_NZVC, cpu6812 },
-  { "mina", OP_D_IDX_2 | OP_PAGE2, 5, 0x19,  7,  7,  CHG_NZVC, cpu6812 },
-
-  { "minm", OP_IDX | OP_PAGE2,     3, 0x1d,  4,  4,  CHG_NZVC, cpu6812 },
-  { "minm", OP_IDX_1 | OP_PAGE2,   4, 0x1d,  5,  5,  CHG_NZVC, cpu6812 },
-  { "minm", OP_IDX_2 | OP_PAGE2,   5, 0x1d,  6,  6,  CHG_NZVC, cpu6812 },
-  { "minm", OP_D_IDX | OP_PAGE2,   3, 0x1d,  7,  7,  CHG_NZVC, cpu6812 },
-  { "minm", OP_D_IDX_2 | OP_PAGE2, 5, 0x1d,  7,  7,  CHG_NZVC, cpu6812 },
-
-  { "movb", OP_IMM8|OP_IND16_p2|OP_PAGE2, 5, 0x0b, 4, 4,  CHG_NONE, cpu6812 },
-  { "movb", OP_IMM8|OP_IDX_p2|OP_PAGE2,     4, 0x08,  4,  4,  CHG_NONE, cpu6812 },
-  { "movb", OP_IND16|OP_IND16_p2|OP_PAGE2,  6, 0x0c,  6,  6,  CHG_NONE, cpu6812 },
-  { "movb", OP_IND16 | OP_IDX_p2 | OP_PAGE2,    5, 0x09,  5,  5,  CHG_NONE, cpu6812 },
-  { "movb", OP_IDX | OP_IND16_p2 | OP_PAGE2,    5, 0x0d,  5,  5,  CHG_NONE, cpu6812 },
-  { "movb", OP_IDX | OP_IDX_p2 | OP_PAGE2,      4, 0x0a,  5,  5,  CHG_NONE, cpu6812 },
-
-  { "movw", OP_IMM16 | OP_IND16_p2 | OP_PAGE2,  6, 0x03,  5,  5,  CHG_NONE, cpu6812 },
-  { "movw", OP_IMM16 | OP_IDX_p2 | OP_PAGE2,    5, 0x00,  4,  4,  CHG_NONE, cpu6812 },
-  { "movw", OP_IND16 | OP_IND16_p2 | OP_PAGE2,  6, 0x04,  6,  6,  CHG_NONE, cpu6812 },
-  { "movw", OP_IND16 | OP_IDX_p2 | OP_PAGE2,    5, 0x01,  5,  5,  CHG_NONE, cpu6812 },
-  { "movw", OP_IDX | OP_IND16_p2 | OP_PAGE2,    5, 0x05,  5,  5,  CHG_NONE, cpu6812 },
-  { "movw", OP_IDX | OP_IDX_p2 | OP_PAGE2,      4, 0x02,  5,  5,  CHG_NONE, cpu6812 },
-
-  { "mul",  OP_NONE,           1, 0x3d,  3, 10,  CHG_C, cpu6811 },
-  { "mul",  OP_NONE,           1, 0x12,  3,  3,  CHG_C, cpu6812 },
-
-  { "neg",  OP_IND16,          3, 0x70,  4,  4,  CHG_NZVC, cpu6811|cpu6812 },
-  { "neg",  OP_IX,             2, 0x60,  6,  6,  CHG_NZVC, cpu6811 },
-  { "neg",  OP_IY | OP_PAGE2,  3, 0x60,  7,  7,  CHG_NZVC, cpu6811 },
-  { "neg",  OP_IDX,            2, 0x60,  3,  3,  CHG_NZVC, cpu6812 },
-  { "neg",  OP_IDX_1,          3, 0x60,  4,  4,  CHG_NZVC, cpu6812 },
-  { "neg",  OP_IDX_2,          4, 0x60,  5,  5,  CHG_NZVC, cpu6812 },
-  { "neg",  OP_D_IDX,          2, 0x60,  6,  6,  CHG_NZVC, cpu6812 },
-  { "neg",  OP_D_IDX_2,        4, 0x60,  6,  6,  CHG_NZVC, cpu6812 },
-
-  { "nega", OP_NONE,           1, 0x40,  1,  1,  CHG_NZVC, cpu6811|cpu6812 },
-  { "negb", OP_NONE,           1, 0x50,  1,  1,  CHG_NZVC, cpu6811|cpu6812 },
-  { "nop",  OP_NONE,           1, 0x01,  2,  2,  CHG_NONE, cpu6811 },
-  { "nop",  OP_NONE,           1, 0xa7,  1,  1,  CHG_NONE, cpu6812 },
-
-  { "oraa", OP_IMM8,         2, 0x8a,  1,  1,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "oraa", OP_DIRECT,       2, 0x9a,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "oraa", OP_IND16,        3, 0xba,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "oraa", OP_IX,             2, 0xaa,  4,  4,  CLR_V_CHG_NZ, cpu6811 },
-  { "oraa", OP_IY | OP_PAGE2,  3, 0xaa,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "oraa", OP_IDX,            2, 0xaa,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "oraa", OP_IDX_1,          3, 0xaa,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "oraa", OP_IDX_2,          4, 0xaa,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "oraa", OP_D_IDX,          2, 0xaa,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-  { "oraa", OP_D_IDX_2,        4, 0xaa,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "orab", OP_IMM8,         2, 0xca,  1,  1,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "orab", OP_DIRECT,       2, 0xda,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "orab", OP_IND16,        3, 0xfa,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812 },
-  { "orab", OP_IX,             2, 0xea,  4,  4,  CLR_V_CHG_NZ, cpu6811 },
-  { "orab", OP_IY | OP_PAGE2,  3, 0xea,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "orab", OP_IDX,            2, 0xea,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "orab", OP_IDX_1,          3, 0xea,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "orab", OP_IDX_2,          4, 0xea,  4,  4,  CLR_V_CHG_NZ, cpu6812 },
-  { "orab", OP_D_IDX,          2, 0xea,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-  { "orab", OP_D_IDX_2,        4, 0xea,  6,  6,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "orcc", OP_IMM8,           2, 0x14,  1,  1,  CHG_ALL, cpu6812 },
-
-  { "psha", OP_NONE,           1, 0x36,  2,  2,  CHG_NONE, cpu6811|cpu6812 },
-  { "pshb", OP_NONE,           1, 0x37,  2,  2,  CHG_NONE, cpu6811|cpu6812 },
-  { "pshc", OP_NONE,           1, 0x39,  2,  2,  CHG_NONE, cpu6812 },
-  { "pshd", OP_NONE,           1, 0x3b,  2,  2,  CHG_NONE, cpu6812 },
-  { "pshx", OP_NONE,           1, 0x3c,  4,  4,  CHG_NONE, cpu6811 },
-  { "pshx", OP_NONE,           1, 0x34,  2,  2,  CHG_NONE, cpu6812 },
-  { "pshy", OP_NONE | OP_PAGE2,2, 0x3c,  5,  5,  CHG_NONE, cpu6811 },
-  { "pshy", OP_NONE,           1, 0x35,  2,  2,  CHG_NONE, cpu6812 },
-
-  { "pula", OP_NONE,           1, 0x32,  3,  3,  CHG_NONE, cpu6811|cpu6812 },
-  { "pulb", OP_NONE,           1, 0x33,  3,  3,  CHG_NONE, cpu6811|cpu6812 },
-  { "pulc", OP_NONE,           1, 0x38,  3,  3,  CHG_NONE, cpu6812 },
-  { "puld", OP_NONE,           1, 0x3a,  3,  3,  CHG_NONE, cpu6812 },
-  { "pulx", OP_NONE,           1, 0x38,  5,  5,  CHG_NONE, cpu6811 },
-  { "pulx", OP_NONE,           1, 0x30,  3,  3,  CHG_NONE, cpu6812 },
-  { "puly", OP_NONE | OP_PAGE2,2, 0x38,  6,  6,  CHG_NONE, cpu6811 },
-  { "puly", OP_NONE,           1, 0x31,  3,  3,  CHG_NONE, cpu6812 },
-
-  { "rev",  OP_NONE | OP_PAGE2, 2, 0x3a,  _M,  _M,  CHG_HNZVC, cpu6812 },
-  { "revw", OP_NONE | OP_PAGE2, 2, 0x3b,  _M,  _M,  CHG_HNZVC, cpu6812 },
-
-  { "rol",  OP_IND16,          3, 0x79,  6,  6,  CHG_NZVC, cpu6811 },
-  { "rol",  OP_IX,             2, 0x69,  6,  6,  CHG_NZVC, cpu6811 },
-  { "rol",  OP_IY | OP_PAGE2,  3, 0x69,  7,  7,  CHG_NZVC, cpu6811 },
-  { "rol",  OP_IND16,          3, 0x75,  4,  4,  CHG_NZVC, cpu6812 },
-  { "rol",  OP_IDX,            2, 0x65,  3,  3,  CHG_NZVC, cpu6812 },
-  { "rol",  OP_IDX_1,          3, 0x65,  4,  4,  CHG_NZVC, cpu6812 },
-  { "rol",  OP_IDX_2,          4, 0x65,  5,  5,  CHG_NZVC, cpu6812 },
-  { "rol",  OP_D_IDX,          2, 0x65,  6,  6,  CHG_NZVC, cpu6812 },
-  { "rol",  OP_D_IDX_2,        4, 0x65,  6,  6,  CHG_NZVC, cpu6812 },
-
-  { "rola", OP_NONE,           1, 0x49,  2,  2,  CHG_NZVC, cpu6811 },
-  { "rola", OP_NONE,           1, 0x45,  1,  1,  CHG_NZVC, cpu6812 },
-  { "rolb", OP_NONE,           1, 0x59,  2,  2,  CHG_NZVC, cpu6811 },
-  { "rolb", OP_NONE,           1, 0x55,  1,  1,  CHG_NZVC, cpu6812 },
-
-  { "ror",  OP_IND16,          3, 0x76,  4,  4,  CHG_NZVC, cpu6811|cpu6812 },
-  { "ror",  OP_IX,             2, 0x66,  6,  6,  CHG_NZVC, cpu6811 },
-  { "ror",  OP_IY | OP_PAGE2,  3, 0x66,  7,  7,  CHG_NZVC, cpu6811 },
-  { "ror",  OP_IDX,            2, 0x66,  3,  3,  CHG_NZVC, cpu6812 },
-  { "ror",  OP_IDX_1,          3, 0x66,  4,  4,  CHG_NZVC, cpu6812 },
-  { "ror",  OP_IDX_2,          4, 0x66,  5,  5,  CHG_NZVC, cpu6812 },
-  { "ror",  OP_D_IDX,          2, 0x66,  6,  6,  CHG_NZVC, cpu6812 },
-  { "ror",  OP_D_IDX_2,        4, 0x66,  6,  6,  CHG_NZVC, cpu6812 },
-
-  { "rora", OP_NONE,           1, 0x46,  1,  1,  CHG_NZVC, cpu6811|cpu6812 },
-  { "rorb", OP_NONE,           1, 0x56,  1,  1,  CHG_NZVC, cpu6811|cpu6812 },
-
-  { "rtc",  OP_NONE,           1, 0x0a,  6,  6,  CHG_NONE, cpu6812 },
-  { "rti",  OP_NONE,           1, 0x3b, 12, 12,  CHG_ALL, cpu6811},
-  { "rti",  OP_NONE,           1, 0x0b,  8, 10,  CHG_ALL, cpu6812},
-  { "rts",  OP_NONE,           1, 0x39,  5,  5,  CHG_NONE, cpu6811 },
-  { "rts",  OP_NONE,           1, 0x3d,  5,  5,  CHG_NONE, cpu6812 },
-
-  { "sba",  OP_NONE,             1, 0x10,  2,  2,  CHG_NZVC, cpu6811 },
-  { "sba",  OP_NONE | OP_PAGE2, 2, 0x16,  2,  2,  CHG_NZVC, cpu6812 },
-
-  { "sbca", OP_IMM8,           2, 0x82,  1,  1,  CHG_NZVC, cpu6811|cpu6812 },
-  { "sbca", OP_DIRECT,         2, 0x92,  3,  3,  CHG_NZVC, cpu6811|cpu6812 },
-  { "sbca", OP_IND16,          3, 0xb2,  3,  3,  CHG_NZVC, cpu6811|cpu6812 },
-  { "sbca", OP_IX,             2, 0xa2,  4,  4,  CHG_NZVC, cpu6811 },
-  { "sbca", OP_IY | OP_PAGE2,  3, 0xa2,  5,  5,  CHG_NZVC, cpu6811 },
-  { "sbca", OP_IDX,            2, 0xa2,  3,  3,  CHG_NZVC, cpu6812 },
-  { "sbca", OP_IDX_1,          3, 0xa2,  3,  3,  CHG_NZVC, cpu6812 },
-  { "sbca", OP_IDX_2,          4, 0xa2,  4,  4,  CHG_NZVC, cpu6812 },
-  { "sbca", OP_D_IDX,          2, 0xa2,  6,  6,  CHG_NZVC, cpu6812 },
-  { "sbca", OP_D_IDX_2,        4, 0xa2,  6,  6,  CHG_NZVC, cpu6812 },
-
-  { "sbcb", OP_IMM8,           2, 0xc2,  1,  1,  CHG_NZVC, cpu6811|cpu6812 },
-  { "sbcb", OP_DIRECT,         2, 0xd2,  3,  3,  CHG_NZVC, cpu6811|cpu6812 },
-  { "sbcb", OP_IND16,          3, 0xf2,  3,  3,  CHG_NZVC, cpu6811|cpu6812 },
-  { "sbcb", OP_IX,             2, 0xe2,  4,  4,  CHG_NZVC, cpu6811 },
-  { "sbcb", OP_IY | OP_PAGE2,  3, 0xe2,  5,  5,  CHG_NZVC, cpu6811 },
-  { "sbcb", OP_IDX,            2, 0xe2,  3,  3,  CHG_NZVC, cpu6812 },
-  { "sbcb", OP_IDX_1,          3, 0xe2,  3,  3,  CHG_NZVC, cpu6812 },
-  { "sbcb", OP_IDX_2,          4, 0xe2,  4,  4,  CHG_NZVC, cpu6812 },
-  { "sbcb", OP_D_IDX,          2, 0xe2,  6,  6,  CHG_NZVC, cpu6812 },
-  { "sbcb", OP_D_IDX_2,        4, 0xe2,  6,  6,  CHG_NZVC, cpu6812 },
-
-  { "sec",  OP_NONE,           1, 0x0d,  2,  2,  SET_C, cpu6811 },
-  { "sei",  OP_NONE,           1, 0x0f,  2,  2,  SET_I, cpu6811 },
-  { "sev",  OP_NONE,           1, 0x0b,  2,  2,  SET_V, cpu6811 },
+  { "idiv",  OP_NONE,              1, 0x02,  3, 41, CLR_V_CHG_ZC, cpu6811, 0 },
+  { "idiv",  OP_NONE | OP_PAGE2,  2, 0x10, 12, 12, CLR_V_CHG_ZC, cpu6812|cpu9s12x, 0 },
+  { "idivs", OP_NONE | OP_PAGE2,  2, 0x15, 12, 12, CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "inc", OP_IX,                  2, 0x6c,  6,  6,  CHG_NZV, cpu6811, 0 },
+  { "inc", OP_IND16,               3, 0x7c,  6,  6,  CHG_NZV, cpu6811, 0 },
+  { "inc", OP_IY | OP_PAGE2,       3, 0x6c,  7,  7,  CHG_NZV, cpu6811, 0 },
+  { "inc", OP_IND16,               3, 0x72,  4,  4,  CHG_NZV, cpu6812|cpu9s12x, 0 },
+  { "inc", OP_IDX,                 2, 0x62,  3,  3,  CHG_NZV, cpu6812|cpu9s12x, 0 },
+  { "inc", OP_IDX_1,               3, 0x62,  4,  4,  CHG_NZV, cpu6812|cpu9s12x, 0 },
+  { "inc", OP_IDX_2,               4, 0x62,  5,  5,  CHG_NZV, cpu6812|cpu9s12x, 0 },
+  { "inc", OP_D_IDX,               2, 0x62,  6,  6,  CHG_NZV, cpu6812|cpu9s12x, 0 },
+  { "inc", OP_D_IDX_2,             4, 0x62,  6,  6,  CHG_NZV, cpu6812|cpu9s12x, 0 },
+
+  { "inca", OP_NONE,               1, 0x4c,  2,  2,  CHG_NZV, cpu6811, 0 },
+  { "inca", OP_NONE,               1, 0x42,  1,  1,  CHG_NZV, cpu6812|cpu9s12x, 0 },
+  { "incb", OP_NONE,               1, 0x5c,  2,  2,  CHG_NZV, cpu6811, 0 },
+  { "incb", OP_NONE,               1, 0x52,  1,  1,  CHG_NZV, cpu6812|cpu9s12x, 0 },
+
+  { "incw",  OP_IND16 | OP_PAGE2,          3, 0x72,  4,  4,  CHG_NZV, cpu9s12x, 0 },
+  { "incw",  OP_IDX | OP_PAGE2,            2, 0x62,  3,  3,  CHG_NZV, cpu9s12x, 0 },
+  { "incw",  OP_IDX_1 | OP_PAGE2,          3, 0x62,  4,  4,  CHG_NZV, cpu9s12x, 0 },
+  { "incw",  OP_IDX_2 | OP_PAGE2,          4, 0x62,  5,  5,  CHG_NZV, cpu9s12x, 0 },
+  { "incw",  OP_D_IDX | OP_PAGE2,          2, 0x62,  6,  6,  CHG_NZV, cpu9s12x, 0 },
+  { "incw",  OP_D_IDX_2 | OP_PAGE2,        4, 0x62,  6,  6,  CHG_NZV, cpu9s12x, 0 },
+
+  { "incx",  OP_NONE | OP_PAGE2,          3, 0x42,  4,  4,  CHG_NZV, cpu9s12x, 0 },
+
+  { "incy",  OP_NONE | OP_PAGE2,          3, 0x52,  4,  4,  CHG_NZV, cpu9s12x, 0 },
+
+  { "ins",  OP_NONE,               1, 0x31,  3,  3,  CHG_NONE, cpu6811, 0 },
+
+  { "inx",  OP_NONE,               1, 0x08,  1,  1,  CHG_Z, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "iny",  OP_NONE |OP_PAGE2,     2, 0x08,  4,  4,  CHG_Z, cpu6811, 0 },
+  { "iny",  OP_NONE,               1, 0x02,  1,  1,  CHG_Z, cpu6812|cpu9s12x, 0 },
+
+  { "jmp",  OP_IND16 | OP_BRANCH,  3, 0x7e,  3,  3,  CHG_NONE, cpu6811, 0 },
+  { "jmp",  OP_IX,                 2, 0x6e,  3,  3,  CHG_NONE, cpu6811, 0 },
+  { "jmp",  OP_IY | OP_PAGE2,      3, 0x6e,  4,  4,  CHG_NONE, cpu6811, 0 },
+  { "jmp",  OP_IND16 | OP_BRANCH,  3, 0x06,  3,  3,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "jmp",  OP_IDX,                2, 0x05,  3,  3,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "jmp",  OP_IDX_1,              3, 0x05,  3,  3,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "jmp",  OP_IDX_2,              4, 0x05,  4,  4,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "jmp",  OP_D_IDX,              2, 0x05,  6,  6,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "jmp",  OP_D_IDX_2,            4, 0x05,  6,  6,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+
+  { "jsr",  OP_DIRECT | OP_BRANCH, 2, 0x9d,  5,  5,  CHG_NONE, cpu6811, 0 },
+  { "jsr",  OP_IND16 | OP_BRANCH,  3, 0xbd,  6,  6,  CHG_NONE, cpu6811, 0 },
+  { "jsr",  OP_IX,                 2, 0xad,  6,  6,  CHG_NONE, cpu6811, 0 },
+  { "jsr",  OP_IY | OP_PAGE2,      3, 0xad,  6,  6,  CHG_NONE, cpu6811, 0 },
+  { "jsr",  OP_DIRECT | OP_BRANCH, 2, 0x17,  4,  4,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "jsr",  OP_IND16 | OP_BRANCH,  3, 0x16,  4,  3,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "jsr",  OP_IDX,                2, 0x15,  4,  4,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "jsr",  OP_IDX_1,              3, 0x15,  4,  4,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "jsr",  OP_IDX_2,              4, 0x15,  5,  5,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "jsr",  OP_D_IDX,              2, 0x15,  7,  7,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "jsr",  OP_D_IDX_2,            4, 0x15,  7,  7,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+
+  { "lbcc", OP_JUMP_REL16 | OP_PAGE2,  4, 0x24,  3,  4, CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "lbcs", OP_JUMP_REL16 | OP_PAGE2,  4, 0x25,  3,  4, CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "lbeq", OP_JUMP_REL16 | OP_PAGE2,  4, 0x27,  3,  4, CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "lbge", OP_JUMP_REL16 | OP_PAGE2,  4, 0x2c,  3,  4, CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "lbgt", OP_JUMP_REL16 | OP_PAGE2,  4, 0x2e,  3,  4, CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "lbhi", OP_JUMP_REL16 | OP_PAGE2,  4, 0x22,  3,  4, CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "lbhs", OP_JUMP_REL16 | OP_PAGE2,  4, 0x24,  3,  4, CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "lble", OP_JUMP_REL16 | OP_PAGE2,  4, 0x2f,  3,  4, CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "lblo", OP_JUMP_REL16 | OP_PAGE2,  4, 0x25,  3,  4, CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "lbls", OP_JUMP_REL16 | OP_PAGE2,  4, 0x23,  3,  4, CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "lblt", OP_JUMP_REL16 | OP_PAGE2,  4, 0x2d,  3,  4, CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "lbmi", OP_JUMP_REL16 | OP_PAGE2,  4, 0x2b,  3,  4, CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "lbne", OP_JUMP_REL16 | OP_PAGE2,  4, 0x26,  3,  4, CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "lbpl", OP_JUMP_REL16 | OP_PAGE2,  4, 0x2a,  3,  4, CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "lbra", OP_JUMP_REL16 | OP_PAGE2,  4, 0x20,  4,  4, CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "lbrn", OP_JUMP_REL16 | OP_PAGE2,  4, 0x21,  3,  3, CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "lbvc", OP_JUMP_REL16 | OP_PAGE2,  4, 0x28,  3,  4, CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "lbvs", OP_JUMP_REL16 | OP_PAGE2,  4, 0x29,  3,  4, CHG_NONE, cpu6812|cpu9s12x, 0 },
+
+  { "ldaa", OP_IMM8,         2, 0x86,  1,  1,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "ldaa", OP_DIRECT,       2, 0x96,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "ldaa", OP_IND16,        3, 0xb6,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "ldaa", OP_IX,             2, 0xa6,  4,  4,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "ldaa", OP_IY | OP_PAGE2,  3, 0xa6,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "ldaa", OP_IDX,            2, 0xa6,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldaa", OP_IDX_1,          3, 0xa6,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldaa", OP_IDX_2,          4, 0xa6,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldaa", OP_D_IDX,          2, 0xa6,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldaa", OP_D_IDX_2,        4, 0xa6,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "ldab", OP_IMM8,         2, 0xc6,  1,  1,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "ldab", OP_DIRECT,       2, 0xd6,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "ldab", OP_IND16,        3, 0xf6,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "ldab", OP_IX,             2, 0xe6,  4,  4,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "ldab", OP_IY | OP_PAGE2,  3, 0xe6,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "ldab", OP_IDX,            2, 0xe6,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldab", OP_IDX_1,          3, 0xe6,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldab", OP_IDX_2,          4, 0xe6,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldab", OP_D_IDX,          2, 0xe6,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldab", OP_D_IDX_2,        4, 0xe6,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "ldd", OP_IMM16,         3, 0xcc,  2,  2,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "ldd", OP_DIRECT,        2, 0xdc,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "ldd", OP_IND16,         3, 0xfc,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "ldd", OP_IX,              2, 0xec,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "ldd", OP_IY | OP_PAGE2,   3, 0xec,  6,  6,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "ldd", OP_IDX,             2, 0xec,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldd", OP_IDX_1,           3, 0xec,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldd", OP_IDX_2,           4, 0xec,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldd", OP_D_IDX,           2, 0xec,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldd", OP_D_IDX_2,         4, 0xec,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "lds",  OP_IMM16,          3, 0x8e,  3,  3,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "lds",  OP_DIRECT,         2, 0x9e,  4,  4,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "lds",  OP_IND16,          3, 0xbe,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "lds",  OP_IX,             2, 0xae,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "lds",  OP_IY | OP_PAGE2,  3, 0xae,  6,  6,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "lds",  OP_IMM16,          3, 0xcf,  2,  2,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "lds",  OP_DIRECT,         2, 0xdf,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "lds",  OP_IND16,          3, 0xff,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "lds",  OP_IDX,            2, 0xef,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "lds",  OP_IDX_1,          3, 0xef,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "lds",  OP_IDX_2,          4, 0xef,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "lds",  OP_D_IDX,          2, 0xef,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "lds",  OP_D_IDX_2,        4, 0xef,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "ldx",  OP_IMM16,        3, 0xce,  2,  2,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "ldx",  OP_DIRECT,       2, 0xde,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "ldx",  OP_IND16,        3, 0xfe,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "ldx",  OP_IX,             2, 0xee,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "ldx",  OP_IY | OP_PAGE4,  3, 0xee,  6,  6,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "ldx",  OP_IDX,            2, 0xee,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldx",  OP_IDX_1,          3, 0xee,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldx",  OP_IDX_2,          4, 0xee,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldx",  OP_D_IDX,          2, 0xee,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldx",  OP_D_IDX_2,        4, 0xee,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "ldy",  OP_IMM16 | OP_PAGE2,  4, 0xce, 4, 4, CLR_V_CHG_NZ, cpu6811, 0 },
+  { "ldy",  OP_DIRECT | OP_PAGE2, 3, 0xde, 5, 5, CLR_V_CHG_NZ, cpu6811, 0 },
+  { "ldy",  OP_IND16 | OP_PAGE2,  4, 0xfe, 6, 6, CLR_V_CHG_NZ, cpu6811, 0 },
+  { "ldy",  OP_IX | OP_PAGE3,     3, 0xee, 6, 6, CLR_V_CHG_NZ, cpu6811, 0 },
+  { "ldy",  OP_IY | OP_PAGE2,     3, 0xee, 6, 6, CLR_V_CHG_NZ, cpu6811, 0 },
+  { "ldy",  OP_IMM16,          3, 0xcd,  2,  2,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldy",  OP_DIRECT,         2, 0xdd,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldy",  OP_IND16,          3, 0xfd,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldy",  OP_IDX,            2, 0xed,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldy",  OP_IDX_1,          3, 0xed,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldy",  OP_IDX_2,          4, 0xed,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldy",  OP_D_IDX,          2, 0xed,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "ldy",  OP_D_IDX_2,        4, 0xed,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "leas", OP_IDX,            2, 0x1b,  2,  2,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "leas", OP_IDX_1,          3, 0x1b,  2,  2,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "leas", OP_IDX_2,          4, 0x1b,  2,  2,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+
+  { "leax", OP_IDX,            2, 0x1a,  2,  2,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "leax", OP_IDX_1,          3, 0x1a,  2,  2,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "leax", OP_IDX_2,          4, 0x1a,  2,  2,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+
+  { "leay", OP_IDX,            2, 0x19,  2,  2,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "leay", OP_IDX_1,          3, 0x19,  2,  2,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "leay", OP_IDX_2,          4, 0x19,  2,  2,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+
+  { "lsl",  OP_IND16,          3, 0x78,  4,  4,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "lsl",  OP_IX,             2, 0x68,  6,  6,  CHG_NZVC, cpu6811, 0 },
+  { "lsl",  OP_IY | OP_PAGE2,  3, 0x68,  7,  7,  CHG_NZVC, cpu6811, 0 },
+  { "lsl",  OP_IDX,            2, 0x68,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "lsl",  OP_IDX_1,          3, 0x68,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "lsl",  OP_IDX_2,          4, 0x68,  5,  5,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "lsl",  OP_D_IDX,          2, 0x68,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "lsl",  OP_D_IDX_2,        4, 0x68,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "lsla", OP_NONE,           1, 0x48,  1,  1,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "lslb", OP_NONE,           1, 0x58,  1,  1,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "lsld", OP_NONE,           1, 0x05,  3,  3,  CHG_NZVC, cpu6811, 0 },
+  { "lsld", OP_NONE,           1, 0x59,  1,  1,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+/* same as aslw */
+  { "lslw",  OP_IND16 | OP_PAGE2,          3, 0x78,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "lslw",  OP_IDX | OP_PAGE2,            2, 0x68,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "lslw",  OP_IDX_1 | OP_PAGE2,          3, 0x68,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "lslw",  OP_IDX_2 | OP_PAGE2,          4, 0x68,  5,  5,  CHG_NZVC, cpu9s12x, 0 },
+  { "lslw",  OP_D_IDX | OP_PAGE2,          2, 0x68,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "lslw",  OP_D_IDX_2 | OP_PAGE2,        4, 0x68,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+/* same as lslw */
+  { "lslx", OP_NONE | OP_PAGE2,           1, 0x48,  1,  1,  CHG_NZVC, cpu9s12x, 0 },
+/* same as lslw */
+  { "lsly", OP_NONE | OP_PAGE2,           1, 0x58,  1,  1,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "lsr",  OP_IND16,        3, 0x74,  4,  4,  CLR_N_CHG_ZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "lsr",  OP_IX,             2, 0x64,  6,  6,  CLR_N_CHG_ZVC, cpu6811, 0 },
+  { "lsr",  OP_IY | OP_PAGE2,  3, 0x64,  7,  7,  CLR_V_CHG_ZVC, cpu6811, 0 },
+  { "lsr",  OP_IDX,            2, 0x64,  3,  3,  CLR_N_CHG_ZVC, cpu6812|cpu9s12x, 0 },
+  { "lsr",  OP_IDX_1,          3, 0x64,  4,  4,  CLR_N_CHG_ZVC, cpu6812|cpu9s12x, 0 },
+  { "lsr",  OP_IDX_2,          4, 0x64,  5,  5,  CLR_N_CHG_ZVC, cpu6812|cpu9s12x, 0 },
+  { "lsr",  OP_D_IDX,          2, 0x64,  6,  6,  CLR_N_CHG_ZVC, cpu6812|cpu9s12x, 0 },
+  { "lsr",  OP_D_IDX_2,        4, 0x64,  6,  6,  CLR_N_CHG_ZVC, cpu6812|cpu9s12x, 0 },
+
+  { "lsra", OP_NONE,         1, 0x44,  1,  1,  CLR_N_CHG_ZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "lsrb", OP_NONE,         1, 0x54,  1,  1,  CLR_N_CHG_ZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "lsrd", OP_NONE,           1, 0x04,  3,  3,  CLR_N_CHG_ZVC, cpu6811, 0 },
+  { "lsrd", OP_NONE,           1, 0x49,  1,  1,  CLR_N_CHG_ZVC, cpu6812|cpu9s12x, 0 },
+
+  { "lsrw",  OP_IND16 | OP_PAGE2,          3, 0x74,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "lsrw",  OP_IDX | OP_PAGE2,            2, 0x64,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "lsrw",  OP_IDX_1 | OP_PAGE2,          3, 0x64,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "lsrw",  OP_IDX_2 | OP_PAGE2,          4, 0x64,  5,  5,  CHG_NZVC, cpu9s12x, 0 },
+  { "lsrw",  OP_D_IDX | OP_PAGE2,          2, 0x64,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "lsrw",  OP_D_IDX_2 | OP_PAGE2,        4, 0x64,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "lsrx", OP_NONE | OP_PAGE2,           1, 0x44,  1,  1,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "lsry", OP_NONE | OP_PAGE2,           1, 0x54,  1,  1,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "maxa", OP_IDX | OP_PAGE2,     3, 0x18,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "maxa", OP_IDX_1 | OP_PAGE2,   4, 0x18,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "maxa", OP_IDX_2 | OP_PAGE2,   5, 0x18,  5,  5,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "maxa", OP_D_IDX | OP_PAGE2,   3, 0x18,  7,  7,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "maxa", OP_D_IDX_2 | OP_PAGE2, 5, 0x18,  7,  7,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "maxm", OP_IDX | OP_PAGE2,     3, 0x1c,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "maxm", OP_IDX_1 | OP_PAGE2,   4, 0x1c,  5,  5,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "maxm", OP_IDX_2 | OP_PAGE2,   5, 0x1c,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "maxm", OP_D_IDX | OP_PAGE2,   3, 0x1c,  7,  7,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "maxm", OP_D_IDX_2 | OP_PAGE2, 5, 0x1c,  7,  7,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "mem",  OP_NONE,                1, 0x01,  5,  5,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+
+  { "mina", OP_IDX | OP_PAGE2,     3, 0x19,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "mina", OP_IDX_1 | OP_PAGE2,   4, 0x19,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "mina", OP_IDX_2 | OP_PAGE2,   5, 0x19,  5,  5,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "mina", OP_D_IDX | OP_PAGE2,   3, 0x19,  7,  7,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "mina", OP_D_IDX_2 | OP_PAGE2, 5, 0x19,  7,  7,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "minm", OP_IDX | OP_PAGE2,     3, 0x1d,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "minm", OP_IDX_1 | OP_PAGE2,   4, 0x1d,  5,  5,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "minm", OP_IDX_2 | OP_PAGE2,   5, 0x1d,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "minm", OP_D_IDX | OP_PAGE2,   3, 0x1d,  7,  7,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "minm", OP_D_IDX_2 | OP_PAGE2, 5, 0x1d,  7,  7,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+/* FIXME S12X additional modes not implemented */
+  { "movb", OP_IMM8|OP_IND16_p2|OP_PAGE2,       5, 0x0b,  4,  4,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "movb", OP_IMM8|OP_IDX_p2|OP_PAGE2,         4, 0x08,  4,  4,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+//  { "movb", OP_IMM8|OP_IDX1_p2|OP_PAGE2,        5, 0x08,  4,  4,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IMM8|OP_IDX2_p2|OP_PAGE2,        4, 0x08,  4,  4,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IMM8|OP_D_IDX_p2|OP_PAGE2,       5, 0x08,  4,  4,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IMM8|OP_D_IDX2_p2|OP_PAGE2,      4, 0x08,  4,  4,  CHG_NONE, cpu9s12x, 0 },
+
+  { "movb", OP_IND16|OP_IND16_p2|OP_PAGE2,      6, 0x0c,  6,  6,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "movb", OP_IND16|OP_IDX_p2|OP_PAGE2,        5, 0x09,  5,  5,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+//  { "movb", OP_IND16|OP_IDX1_p2|OP_PAGE2,       6, 0x09,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IND16|OP_IDX2_p2|OP_PAGE2,       5, 0x09,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IND16|OP_D_IDX_p2|OP_PAGE2,    6, 0x09,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IND16|OP_D_IDX2_p2|OP_PAGE2,     5, 0x09,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+
+  { "movb", OP_IDX|OP_IND16_p2|OP_PAGE2,        5, 0x0d,  5,  5,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "movb", OP_IDX|OP_IDX_p2|OP_PAGE2,          4, 0x0a,  5,  5,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+//  { "movb", OP_IDX|OP_IDX1_p2|OP_PAGE2,         5, 0x0a,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IDX|OP_IDX2_p2|OP_PAGE2,         4, 0x0a,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IDX|OP_D_IDX_p2|OP_PAGE2,        5, 0x0d,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IDX|OP_D_IDX2_p2|OP_PAGE2,       4, 0x0a,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+
+//  { "movb", OP_IDX_1|OP_IND16_p2|OP_PAGE2,       5, 0x0d,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IDX_1|OP_IDX_p2|OP_PAGE2,         4, 0x0a,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IDX_1|OP_IDX1_p2|OP_PAGE2,        6, 0x0a,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IDX_1|OP_IDX2_p2|OP_PAGE2,        5, 0x0a,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IDX_1|OP_D_IDX_p2|OP_PAGE2,       6, 0x0a,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IDX_1|OP_D_IDX2_p2|OP_PAGE2,      5, 0x0a,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+
+//  { "movb", OP_IDX_2|OP_IND16_p2|OP_PAGE2,       5, 0x0d,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IDX_2|OP_IDX_p2|OP_PAGE2,         4, 0x0a,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IDX_2|OP_IDX1_p2|OP_PAGE2,        6, 0x0a,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IDX_2|OP_IDX2_p2|OP_PAGE2,        5, 0x0a,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IDX_2|OP_D_IDX_p2|OP_PAGE2,       6, 0x0a,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_IDX_2|OP_D_IDX2_p2|OP_PAGE2,      5, 0x0a,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+
+//  { "movb", OP_D_IDX|OP_IND16_p2|OP_PAGE2,       5, 0x0d,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_D_IDX|OP_IDX_p2|OP_PAGE2,         4, 0x0a,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_D_IDX|OP_IDX1_p2|OP_PAGE2,        6, 0x0a,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_D_IDX|OP_IDX2_p2|OP_PAGE2,        5, 0x0a,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_D_IDX|OP_D_IDX_p2|OP_PAGE2,       6, 0x0a,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_D_IDX|OP_D_IDX2_p2|OP_PAGE2,      5, 0x0a,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+
+//  { "movb", OP_D_IDX_2|OP_IND16_p2|OP_PAGE2,       5, 0x0d,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_D_IDX_2|OP_IDX_p2|OP_PAGE2,         4, 0x0a,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_D_IDX_2|OP_IDX1_p2|OP_PAGE2,        6, 0x0a,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_D_IDX_2|OP_IDX2_p2|OP_PAGE2,        5, 0x0a,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_D_IDX_2|OP_D_IDX_p2|OP_PAGE2,       6, 0x0a,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movb", OP_D_IDX_2|OP_D_IDX2_p2|OP_PAGE2,      5, 0x0a,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+
+/* FIXME S12X additional modes not implemented */
+  { "movw", OP_IMM16 | OP_IND16_p2 | OP_PAGE2,  6, 0x03,  5,  5,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "movw", OP_IMM16 | OP_IDX_p2 | OP_PAGE2,    5, 0x00,  4,  4,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+//  { "movw", OP_IMM16|OP_IDX1_p2|OP_PAGE2,        5, 0x00,  4,  4,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IMM16|OP_IDX2_p2|OP_PAGE2,        4, 0x00,  4,  4,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IMM16|OP_D_IDX_p2|OP_PAGE2,       5, 0x00,  4,  4,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IMM16|OP_D_IDX2_p2|OP_PAGE2,      4, 0x00,  4,  4,  CHG_NONE, cpu9s12x, 0 },
+
+  { "movw", OP_IND16 | OP_IND16_p2 | OP_PAGE2,  6, 0x04,  6,  6,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "movw", OP_IND16 | OP_IDX_p2 | OP_PAGE2,    5, 0x01,  5,  5,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+//  { "movw", OP_IND16|OP_IDX1_p2|OP_PAGE2,       6, 0x01,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IND16|OP_IDX2_p2|OP_PAGE2,       5, 0x01,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IND16|OP_D_IDX_p2|OP_PAGE2,      6, 0x01,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IND16|OP_D_IDX2_p2|OP_PAGE2,     5, 0x01,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+
+  { "movw", OP_IDX | OP_IND16_p2 | OP_PAGE2,    5, 0x05,  5,  5,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "movw", OP_IDX | OP_IDX_p2 | OP_PAGE2,      4, 0x02,  5,  5,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+//  { "movw", OP_IDX|OP_IDX1_p2|OP_PAGE2,         5, 0x02,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IDX|OP_IDX2_p2|OP_PAGE2,         4, 0x02,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IDX|OP_D_IDX_p2|OP_PAGE2,        5, 0x02,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IDX|OP_D_IDX2_p2|OP_PAGE2,       4, 0x02,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+
+//  { "movw", OP_IDX_1|OP_IND16_p2|OP_PAGE2,       5, 0x05,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IDX_1|OP_IDX_p2|OP_PAGE2,         4, 0x02,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IDX_1|OP_IDX1_p2|OP_PAGE2,        6, 0x02,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IDX_1|OP_IDX2_p2|OP_PAGE2,        5, 0x02,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IDX_1|OP_D_IDX_p2|OP_PAGE2,       6, 0x02,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IDX_1|OP_D_IDX2_p2|OP_PAGE2,      5, 0x02,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+
+//  { "movw", OP_IDX_2|OP_IND16_p2|OP_PAGE2,       5, 0x05,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IDX_2|OP_IDX_p2|OP_PAGE2,         4, 0x02,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IDX_2|OP_IDX1_p2|OP_PAGE2,        6, 0x02,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IDX_2|OP_IDX2_p2|OP_PAGE2,        5, 0x02,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IDX_2|OP_D_IDX_p2|OP_PAGE2,       6, 0x02,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_IDX_2|OP_D_IDX2_p2|OP_PAGE2,      5, 0x02,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+
+//  { "movw", OP_D_IDX|OP_IND16_p2|OP_PAGE2,       5, 0x05,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_D_IDX|OP_IDX_p2|OP_PAGE2,         4, 0x02,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_D_IDX|OP_IDX1_p2|OP_PAGE2,        6, 0x02,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_D_IDX|OP_IDX2_p2|OP_PAGE2,        5, 0x02,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_D_IDX|OP_D_IDX_p2|OP_PAGE2,       6, 0x02,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_D_IDX|OP_D_IDX2_p2|OP_PAGE2,      5, 0x02,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+
+//  { "movw", OP_D_IDX_2|OP_IND16_p2|OP_PAGE2,       5, 0x05,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_D_IDX_2|OP_IDX_p2|OP_PAGE2,         4, 0x02,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_D_IDX_2|OP_IDX1_p2|OP_PAGE2,        6, 0x02,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_D_IDX_2|OP_IDX2_p2|OP_PAGE2,        5, 0x02,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_D_IDX_2|OP_D_IDX_p2|OP_PAGE2,       6, 0x02,  6,  6,  CHG_NONE, cpu9s12x, 0 },
+//  { "movw", OP_D_IDX_2|OP_D_IDX2_p2|OP_PAGE2,      5, 0x02,  5,  5,  CHG_NONE, cpu9s12x, 0 },
+
+  { "mul",  OP_NONE,           1, 0x3d,  3, 10,  CHG_C, cpu6811, 0 },
+  { "mul",  OP_NONE,           1, 0x12,  3,  3,  CHG_C, cpu6812|cpu9s12x, 0 },
+
+  { "neg",  OP_IND16,          3, 0x70,  4,  4,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "neg",  OP_IX,             2, 0x60,  6,  6,  CHG_NZVC, cpu6811, 0 },
+  { "neg",  OP_IY | OP_PAGE2,  3, 0x60,  7,  7,  CHG_NZVC, cpu6811, 0 },
+  { "neg",  OP_IDX,            2, 0x60,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "neg",  OP_IDX_1,          3, 0x60,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "neg",  OP_IDX_2,          4, 0x60,  5,  5,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "neg",  OP_D_IDX,          2, 0x60,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "neg",  OP_D_IDX_2,        4, 0x60,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "nega", OP_NONE,           1, 0x40,  1,  1,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "negb", OP_NONE,           1, 0x50,  1,  1,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+
+  { "negw",  OP_IND16| OP_PAGE2,          3, 0x70,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "negw",  OP_IDX| OP_PAGE2,            2, 0x60,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "negw",  OP_IDX_1| OP_PAGE2,          3, 0x60,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "negw",  OP_IDX_2| OP_PAGE2,          4, 0x60,  5,  5,  CHG_NZVC, cpu9s12x, 0 },
+  { "negw",  OP_D_IDX| OP_PAGE2,          2, 0x60,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "negw",  OP_D_IDX_2| OP_PAGE2,        4, 0x60,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "negx", OP_NONE| OP_PAGE2,           1, 0x40,  1,  1,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "negy", OP_NONE| OP_PAGE2,           1, 0x50,  1,  1,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "nop",  OP_NONE,           1, 0x01,  2,  2,  CHG_NONE, cpu6811, 0 },
+  { "nop",  OP_NONE,           1, 0xa7,  1,  1,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+
+  { "oraa", OP_IMM8,         2, 0x8a,  1,  1,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "oraa", OP_DIRECT,       2, 0x9a,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "oraa", OP_IND16,        3, 0xba,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "oraa", OP_IX,             2, 0xaa,  4,  4,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "oraa", OP_IY | OP_PAGE2,  3, 0xaa,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "oraa", OP_IDX,            2, 0xaa,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "oraa", OP_IDX_1,          3, 0xaa,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "oraa", OP_IDX_2,          4, 0xaa,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "oraa", OP_D_IDX,          2, 0xaa,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "oraa", OP_D_IDX_2,        4, 0xaa,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "orab", OP_IMM8,         2, 0xca,  1,  1,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "orab", OP_DIRECT,       2, 0xda,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "orab", OP_IND16,        3, 0xfa,  3,  3,  CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "orab", OP_IX,             2, 0xea,  4,  4,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "orab", OP_IY | OP_PAGE2,  3, 0xea,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "orab", OP_IDX,            2, 0xea,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "orab", OP_IDX_1,          3, 0xea,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "orab", OP_IDX_2,          4, 0xea,  4,  4,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "orab", OP_D_IDX,          2, 0xea,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "orab", OP_D_IDX_2,        4, 0xea,  6,  6,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "orcc", OP_IMM8,           2, 0x14,  1,  1,  CHG_ALL, cpu6812|cpu9s12x, 0 },
+
+  { "orx", OP_IMM16| OP_PAGE2,  2, 0x8a,  1,  1,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "orx", OP_DIRECT| OP_PAGE2, 2, 0x9a,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "orx", OP_IND16| OP_PAGE2,  3, 0xba,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "orx", OP_IDX| OP_PAGE2,    2, 0xaa,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "orx", OP_IDX_1| OP_PAGE2,  3, 0xaa,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "orx", OP_IDX_2| OP_PAGE2,  4, 0xaa,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "orx", OP_D_IDX| OP_PAGE2,  2, 0xaa,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "orx", OP_D_IDX_2| OP_PAGE2,4, 0xaa,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "ory", OP_IMM16| OP_PAGE2,  2, 0xca,  1,  1,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "ory", OP_DIRECT| OP_PAGE2, 2, 0xda,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "ory", OP_IND16| OP_PAGE2,  3, 0xfa,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "ory", OP_IDX| OP_PAGE2,    2, 0xea,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "ory", OP_IDX_1| OP_PAGE2,  3, 0xea,  3,  3,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "ory", OP_IDX_2| OP_PAGE2,  4, 0xea,  4,  4,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "ory", OP_D_IDX| OP_PAGE2,  2, 0xea,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+  { "ory", OP_D_IDX_2| OP_PAGE2,4, 0xea,  6,  6,  CLR_V_CHG_NZ, cpu9s12x, 0 },
+
+  { "psha", OP_NONE,           1, 0x36,  2,  2,  CHG_NONE, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "pshb", OP_NONE,           1, 0x37,  2,  2,  CHG_NONE, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "pshc", OP_NONE,           1, 0x39,  2,  2,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "pshcw", OP_NONE| OP_PAGE2,1, 0x39,  2,  2,  CHG_NONE, cpu9s12x, 0 },
+  { "pshd", OP_NONE,           1, 0x3b,  2,  2,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "pshx", OP_NONE,           1, 0x3c,  4,  4,  CHG_NONE, cpu6811, 0 },
+  { "pshx", OP_NONE,           1, 0x34,  2,  2,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "pshy", OP_NONE | OP_PAGE2,2, 0x3c,  5,  5,  CHG_NONE, cpu6811, 0 },
+  { "pshy", OP_NONE,           1, 0x35,  2,  2,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+
+
+  { "pula", OP_NONE,           1, 0x32,  3,  3,  CHG_NONE, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "pulb", OP_NONE,           1, 0x33,  3,  3,  CHG_NONE, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "pulc", OP_NONE,           1, 0x38,  3,  3,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "pulcw", OP_NONE| OP_PAGE2,1, 0x38,  2,  2,  CHG_NONE, cpu9s12x, 0 },
+  { "puld", OP_NONE,           1, 0x3a,  3,  3,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "pulx", OP_NONE,           1, 0x38,  5,  5,  CHG_NONE, cpu6811, 0 },
+  { "pulx", OP_NONE,           1, 0x30,  3,  3,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "puly", OP_NONE | OP_PAGE2,2, 0x38,  6,  6,  CHG_NONE, cpu6811, 0 },
+  { "puly", OP_NONE,           1, 0x31,  3,  3,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+
+  { "rev",  OP_NONE | OP_PAGE2, 2, 0x3a,  _M,  _M,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+  { "revw", OP_NONE | OP_PAGE2, 2, 0x3b,  _M,  _M,  CHG_HNZVC, cpu6812|cpu9s12x, 0 },
+
+  { "rol",  OP_IND16,          3, 0x79,  6,  6,  CHG_NZVC, cpu6811, 0 },
+  { "rol",  OP_IX,             2, 0x69,  6,  6,  CHG_NZVC, cpu6811, 0 },
+  { "rol",  OP_IY | OP_PAGE2,  3, 0x69,  7,  7,  CHG_NZVC, cpu6811, 0 },
+  { "rol",  OP_IND16,          3, 0x75,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "rol",  OP_IDX,            2, 0x65,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "rol",  OP_IDX_1,          3, 0x65,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "rol",  OP_IDX_2,          4, 0x65,  5,  5,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "rol",  OP_D_IDX,          2, 0x65,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "rol",  OP_D_IDX_2,        4, 0x65,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "rola", OP_NONE,           1, 0x49,  2,  2,  CHG_NZVC, cpu6811, 0 },
+  { "rola", OP_NONE,           1, 0x45,  1,  1,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "rolb", OP_NONE,           1, 0x59,  2,  2,  CHG_NZVC, cpu6811, 0 },
+  { "rolb", OP_NONE,           1, 0x55,  1,  1,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "rolw",  OP_IND16 | OP_PAGE2,          3, 0x75,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "rolw",  OP_IDX | OP_PAGE2,            2, 0x65,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "rolw",  OP_IDX_1 | OP_PAGE2,          3, 0x65,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "rolw",  OP_IDX_2 | OP_PAGE2,          4, 0x65,  5,  5,  CHG_NZVC, cpu9s12x, 0 },
+  { "rolw",  OP_D_IDX | OP_PAGE2,          2, 0x65,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "rolw",  OP_D_IDX_2 | OP_PAGE2,        4, 0x65,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "rolx", OP_NONE | OP_PAGE2,           1, 0x45,  1,  1,  CHG_NZVC, cpu9s12x, 0 },
+  { "roly", OP_NONE | OP_PAGE2,           1, 0x55,  1,  1,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "ror",  OP_IND16,          3, 0x76,  4,  4,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "ror",  OP_IX,             2, 0x66,  6,  6,  CHG_NZVC, cpu6811, 0 },
+  { "ror",  OP_IY | OP_PAGE2,  3, 0x66,  7,  7,  CHG_NZVC, cpu6811, 0 },
+  { "ror",  OP_IDX,            2, 0x66,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "ror",  OP_IDX_1,          3, 0x66,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "ror",  OP_IDX_2,          4, 0x66,  5,  5,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "ror",  OP_D_IDX,          2, 0x66,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "ror",  OP_D_IDX_2,        4, 0x66,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "rora", OP_NONE,           1, 0x46,  1,  1,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "rorb", OP_NONE,           1, 0x56,  1,  1,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+
+  { "rorw",  OP_IND16 | OP_PAGE2,          3, 0x76,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "rorw",  OP_IDX | OP_PAGE2,            2, 0x66,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "rorw",  OP_IDX_1 | OP_PAGE2,          3, 0x66,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "rorw",  OP_IDX_2 | OP_PAGE2,          4, 0x66,  5,  5,  CHG_NZVC, cpu9s12x, 0 },
+  { "rorw",  OP_D_IDX | OP_PAGE2,          2, 0x66,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "rorw",  OP_D_IDX_2 | OP_PAGE2,        4, 0x66,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "rorx", OP_NONE | OP_PAGE2,           1, 0x46,  1,  1,  CHG_NZVC, cpu9s12x, 0 },
+  { "rorx", OP_NONE | OP_PAGE2,           1, 0x56,  1,  1,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "rtc",  OP_NONE,           1, 0x0a,  6,  6,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+  { "rti",  OP_NONE,           1, 0x3b, 12, 12,  CHG_ALL, cpu6811, 0 },
+  { "rti",  OP_NONE,           1, 0x0b,  8, 10,  CHG_ALL, cpu6812|cpu9s12x, 0 },
+  { "rts",  OP_NONE,           1, 0x39,  5,  5,  CHG_NONE, cpu6811, 0 },
+  { "rts",  OP_NONE,           1, 0x3d,  5,  5,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+
+  { "sba",  OP_NONE,             1, 0x10,  2,  2,  CHG_NZVC, cpu6811, 0 },
+  { "sba",  OP_NONE | OP_PAGE2, 2, 0x16,  2,  2,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "sbca", OP_IMM8,           2, 0x82,  1,  1,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "sbca", OP_DIRECT,         2, 0x92,  3,  3,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "sbca", OP_IND16,          3, 0xb2,  3,  3,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "sbca", OP_IX,             2, 0xa2,  4,  4,  CHG_NZVC, cpu6811, 0 },
+  { "sbca", OP_IY | OP_PAGE2,  3, 0xa2,  5,  5,  CHG_NZVC, cpu6811, 0 },
+  { "sbca", OP_IDX,            2, 0xa2,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "sbca", OP_IDX_1,          3, 0xa2,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "sbca", OP_IDX_2,          4, 0xa2,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "sbca", OP_D_IDX,          2, 0xa2,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "sbca", OP_D_IDX_2,        4, 0xa2,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "sbcb", OP_IMM8,           2, 0xc2,  1,  1,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "sbcb", OP_DIRECT,         2, 0xd2,  3,  3,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "sbcb", OP_IND16,          3, 0xf2,  3,  3,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "sbcb", OP_IX,             2, 0xe2,  4,  4,  CHG_NZVC, cpu6811, 0 },
+  { "sbcb", OP_IY | OP_PAGE2,  3, 0xe2,  5,  5,  CHG_NZVC, cpu6811, 0 },
+  { "sbcb", OP_IDX,            2, 0xe2,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "sbcb", OP_IDX_1,          3, 0xe2,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "sbcb", OP_IDX_2,          4, 0xe2,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "sbcb", OP_D_IDX,          2, 0xe2,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "sbcb", OP_D_IDX_2,        4, 0xe2,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "sbed", OP_IMM16 | OP_PAGE2,          3, 0x83,  2,  2,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbed", OP_DIRECT | OP_PAGE2,         2, 0x93,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbed", OP_IND16 | OP_PAGE2,          3, 0xb3,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbed", OP_IDX | OP_PAGE2,            2, 0xa3,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbed", OP_IDX_1 | OP_PAGE2,          3, 0xa3,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbed", OP_IDX_2 | OP_PAGE2,          4, 0xa3,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbed", OP_D_IDX | OP_PAGE2,          2, 0xa3,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbed", OP_D_IDX_2 | OP_PAGE2,        4, 0xa3,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "sbex", OP_IMM16 | OP_PAGE2,          3, 0x82,  2,  2,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbex", OP_DIRECT | OP_PAGE2,         2, 0x92,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbex", OP_IND16 | OP_PAGE2,          3, 0xb2,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbex", OP_IDX | OP_PAGE2,            2, 0xa2,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbex", OP_IDX_1 | OP_PAGE2,          3, 0xa2,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbex", OP_IDX_2 | OP_PAGE2,          4, 0xa2,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbex", OP_D_IDX | OP_PAGE2,          2, 0xa2,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbex", OP_D_IDX_2 | OP_PAGE2,        4, 0xa2,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "sbey", OP_IMM16 | OP_PAGE2,          3, 0xc2,  2,  2,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbey", OP_DIRECT | OP_PAGE2,         2, 0xd2,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbey", OP_IND16 | OP_PAGE2,          3, 0xf2,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbey", OP_IDX | OP_PAGE2,            2, 0xe2,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbey", OP_IDX_1 | OP_PAGE2,          3, 0xe2,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbey", OP_IDX_2 | OP_PAGE2,          4, 0xe2,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbey", OP_D_IDX | OP_PAGE2,          2, 0xe2,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "sbey", OP_D_IDX_2 | OP_PAGE2,        4, 0xe2,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "sec",  OP_NONE,           1, 0x0d,  2,  2,  SET_C, cpu6811, 0 },
+  { "sei",  OP_NONE,           1, 0x0f,  2,  2,  SET_I, cpu6811, 0 },
+  { "sev",  OP_NONE,           1, 0x0b,  2,  2,  SET_V, cpu6811, 0 },
 
+/* FIXME S12X has more sex */
   { "sex",  M6812_OP_SEX_MARKER
-          | OP_REG | OP_REG_2, 2, 0xb7,  1,  1,  CHG_NONE, cpu6812 },
+          | OP_REG | OP_REG_2, 2, 0xb7,  1,  1,  CHG_NONE, cpu6812|cpu9s12x, 0 },
 
-  { "staa", OP_IND16,          3, 0xb7,  4,  4,  CLR_V_CHG_NZ, cpu6811 },
-  { "staa", OP_DIRECT,         2, 0x97,  3,  3,  CLR_V_CHG_NZ, cpu6811 },
-  { "staa", OP_IX,             2, 0xa7,  4,  4,  CLR_V_CHG_NZ, cpu6811 },
-  { "staa", OP_IY | OP_PAGE2,  3, 0xa7,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "staa", OP_DIRECT,         2, 0x5a,  2,  2,  CLR_V_CHG_NZ, cpu6812 },
-  { "staa", OP_IND16,          3, 0x7a,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "staa", OP_IDX,            2, 0x6a,  2,  2,  CLR_V_CHG_NZ, cpu6812 },
-  { "staa", OP_IDX_1,          3, 0x6a,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "staa", OP_IDX_2,          4, 0x6a,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "staa", OP_D_IDX,          2, 0x6a,  5,  5,  CLR_V_CHG_NZ, cpu6812 },
-  { "staa", OP_D_IDX_2,        4, 0x6a,  5,  5,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "stab", OP_IND16,          3, 0xf7,  4,  4,  CLR_V_CHG_NZ, cpu6811 },
-  { "stab", OP_DIRECT,         2, 0xd7,  3,  3,  CLR_V_CHG_NZ, cpu6811 },
-  { "stab", OP_IX,             2, 0xe7,  4,  4,  CLR_V_CHG_NZ, cpu6811 },
-  { "stab", OP_IY | OP_PAGE2,  3, 0xe7,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "stab", OP_DIRECT,         2, 0x5b,  2,  2,  CLR_V_CHG_NZ, cpu6812 },
-  { "stab", OP_IND16,          3, 0x7b,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "stab", OP_IDX,            2, 0x6b,  2,  2,  CLR_V_CHG_NZ, cpu6812 },
-  { "stab", OP_IDX_1,          3, 0x6b,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "stab", OP_IDX_2,          4, 0x6b,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "stab", OP_D_IDX,          2, 0x6b,  5,  5,  CLR_V_CHG_NZ, cpu6812 },
-  { "stab", OP_D_IDX_2,        4, 0x6b,  5,  5,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "std",  OP_IND16,          3, 0xfd,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "std",  OP_DIRECT,         2, 0xdd,  4,  4,  CLR_V_CHG_NZ, cpu6811 },
-  { "std",  OP_IX,             2, 0xed,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "std",  OP_IY | OP_PAGE2,  3, 0xed,  6,  6,  CLR_V_CHG_NZ, cpu6811 },
-  { "std",  OP_DIRECT,         2, 0x5c,  2,  2,  CLR_V_CHG_NZ, cpu6812 },
-  { "std",  OP_IND16,          3, 0x7c,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "std",  OP_IDX,            2, 0x6c,  2,  2,  CLR_V_CHG_NZ, cpu6812 },
-  { "std",  OP_IDX_1,          3, 0x6c,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "std",  OP_IDX_2,          4, 0x6c,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "std",  OP_D_IDX,          2, 0x6c,  5,  5,  CLR_V_CHG_NZ, cpu6812 },
-  { "std",  OP_D_IDX_2,        4, 0x6c,  5,  5,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "stop", OP_NONE,           1, 0xcf,  2,  2,  CHG_NONE, cpu6811 },
-  { "stop", OP_NONE | OP_PAGE2,2, 0x3e,  2,  9,  CHG_NONE, cpu6812 },
-
-  { "sts",  OP_IND16,          3, 0xbf,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "sts",  OP_DIRECT,         2, 0x9f,  4,  4,  CLR_V_CHG_NZ, cpu6811 },
-  { "sts",  OP_IX,             2, 0xaf,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "sts",  OP_IY | OP_PAGE2,  3, 0xaf,  6,  6,  CLR_V_CHG_NZ, cpu6811 },
-  { "sts",  OP_DIRECT,         2, 0x5f,  2,  2,  CLR_V_CHG_NZ, cpu6812 },
-  { "sts",  OP_IND16,          3, 0x7f,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "sts",  OP_IDX,            2, 0x6f,  2,  2,  CLR_V_CHG_NZ, cpu6812 },
-  { "sts",  OP_IDX_1,          3, 0x6f,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "sts",  OP_IDX_2,          4, 0x6f,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "sts",  OP_D_IDX,          2, 0x6f,  5,  5,  CLR_V_CHG_NZ, cpu6812 },
-  { "sts",  OP_D_IDX_2,        4, 0x6f,  5,  5,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "stx",  OP_IND16,          3, 0xff,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "stx",  OP_DIRECT,         2, 0xdf,  4,  4,  CLR_V_CHG_NZ, cpu6811 },
-  { "stx",  OP_IX,             2, 0xef,  5,  5,  CLR_V_CHG_NZ, cpu6811 },
-  { "stx",  OP_IY | OP_PAGE4,  3, 0xef,  6,  6,  CLR_V_CHG_NZ, cpu6811 },
-  { "stx",  OP_DIRECT,         2, 0x5e,  2,  2,  CLR_V_CHG_NZ, cpu6812 },
-  { "stx",  OP_IND16,          3, 0x7e,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "stx",  OP_IDX,            2, 0x6e,  2,  2,  CLR_V_CHG_NZ, cpu6812 },
-  { "stx",  OP_IDX_1,          3, 0x6e,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "stx",  OP_IDX_2,          4, 0x6e,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "stx",  OP_D_IDX,          2, 0x6e,  5,  5,  CLR_V_CHG_NZ, cpu6812 },
-  { "stx",  OP_D_IDX_2,        4, 0x6e,  5,  5,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "sty",  OP_IND16 | OP_PAGE2,  4, 0xff, 6, 6, CLR_V_CHG_NZ, cpu6811 },
-  { "sty",  OP_DIRECT | OP_PAGE2, 3, 0xdf, 5, 5, CLR_V_CHG_NZ, cpu6811 },
-  { "sty",  OP_IY | OP_PAGE2,     3, 0xef, 6, 6, CLR_V_CHG_NZ, cpu6811 },
-  { "sty",  OP_IX | OP_PAGE3,     3, 0xef, 6, 6, CLR_V_CHG_NZ, cpu6811 },
-  { "sty",  OP_DIRECT,         2, 0x5d,  2,  2,  CLR_V_CHG_NZ, cpu6812 },
-  { "sty",  OP_IND16,          3, 0x7d,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "sty",  OP_IDX,            2, 0x6d,  2,  2,  CLR_V_CHG_NZ, cpu6812 },
-  { "sty",  OP_IDX_1,          3, 0x6d,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "sty",  OP_IDX_2,          4, 0x6d,  3,  3,  CLR_V_CHG_NZ, cpu6812 },
-  { "sty",  OP_D_IDX,          2, 0x6d,  5,  5,  CLR_V_CHG_NZ, cpu6812 },
-  { "sty",  OP_D_IDX_2,        4, 0x6d,  5,  5,  CLR_V_CHG_NZ, cpu6812 },
-
-  { "suba", OP_IMM8,           2, 0x80,  1,  1,  CHG_NZVC, cpu6811|cpu6812 },
-  { "suba", OP_DIRECT,         2, 0x90,  3,  3,  CHG_NZVC, cpu6811|cpu6812 },
-  { "suba", OP_IND16,          3, 0xb0,  3,  3,  CHG_NZVC, cpu6811|cpu6812 },
-  { "suba", OP_IX,             2, 0xa0,  4,  4,  CHG_NZVC, cpu6811 },
-  { "suba", OP_IY | OP_PAGE2,  3, 0xa0,  5,  5,  CHG_NZVC, cpu6811 },
-  { "suba", OP_IDX,            2, 0xa0,  3,  3,  CHG_NZVC, cpu6812 },
-  { "suba", OP_IDX_1,          3, 0xa0,  3,  3,  CHG_NZVC, cpu6812 },
-  { "suba", OP_IDX_2,          4, 0xa0,  4,  4,  CHG_NZVC, cpu6812 },
-  { "suba", OP_D_IDX,          2, 0xa0,  6,  6,  CHG_NZVC, cpu6812 },
-  { "suba", OP_D_IDX_2,        4, 0xa0,  6,  6,  CHG_NZVC, cpu6812 },
-
-  { "subb", OP_IMM8,           2, 0xc0,  1,  1,  CHG_NZVC, cpu6811|cpu6812 },
-  { "subb", OP_DIRECT,         2, 0xd0,  3,  3,  CHG_NZVC, cpu6811|cpu6812 },
-  { "subb", OP_IND16,          3, 0xf0,  3,  3,  CHG_NZVC, cpu6811|cpu6812 },
-  { "subb", OP_IX,             2, 0xe0,  4,  4,  CHG_NZVC, cpu6811 },
-  { "subb", OP_IY | OP_PAGE2,  3, 0xe0,  5,  5,  CHG_NZVC, cpu6811 },
-  { "subb", OP_IDX,            2, 0xe0,  3,  3,  CHG_NZVC, cpu6812 },
-  { "subb", OP_IDX_1,          3, 0xe0,  3,  3,  CHG_NZVC, cpu6812 },
-  { "subb", OP_IDX_2,          4, 0xe0,  4,  4,  CHG_NZVC, cpu6812 },
-  { "subb", OP_D_IDX,          2, 0xe0,  6,  6,  CHG_NZVC, cpu6812 },
-  { "subb", OP_D_IDX_2,        4, 0xe0,  6,  6,  CHG_NZVC, cpu6812 },
-
-  { "subd", OP_IMM16,          3, 0x83,  2,  2,  CHG_NZVC, cpu6811|cpu6812 },
-  { "subd", OP_DIRECT,         2, 0x93,  3,  3,  CHG_NZVC, cpu6811|cpu6812 },
-  { "subd", OP_IND16,          3, 0xb3,  3,  3,  CHG_NZVC, cpu6811|cpu6812 },
-  { "subd", OP_IX,             2, 0xa3,  6,  6,  CHG_NZVC, cpu6811 },
-  { "subd", OP_IY | OP_PAGE2,  3, 0xa3,  7,  7,  CHG_NZVC, cpu6811 },
-  { "subd", OP_IDX,            2, 0xa3,  3,  3,  CHG_NZVC, cpu6812 },
-  { "subd", OP_IDX_1,          3, 0xa3,  3,  3,  CHG_NZVC, cpu6812 },
-  { "subd", OP_IDX_2,          4, 0xa3,  4,  4,  CHG_NZVC, cpu6812 },
-  { "subd", OP_D_IDX,          2, 0xa3,  6,  6,  CHG_NZVC, cpu6812 },
-  { "subd", OP_D_IDX_2,        4, 0xa3,  6,  6,  CHG_NZVC, cpu6812 },
-
-  { "swi",  OP_NONE,           1, 0x3f,  9,  9,  CHG_NONE, cpu6811|cpu6812 },
-
-  { "tab",  OP_NONE,           1, 0x16,  2,  2,  CLR_V_CHG_NZ, cpu6811 },
-  { "tab",  OP_NONE | OP_PAGE2,2, 0x0e,  2,  2,  CLR_V_CHG_NZ, cpu6812 },
+  { "staa", OP_IND16,          3, 0xb7,  4,  4,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "staa", OP_DIRECT,         2, 0x97,  3,  3,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "staa", OP_IX,             2, 0xa7,  4,  4,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "staa", OP_IY | OP_PAGE2,  3, 0xa7,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "staa", OP_DIRECT,         2, 0x5a,  2,  2,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "staa", OP_IND16,          3, 0x7a,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "staa", OP_IDX,            2, 0x6a,  2,  2,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "staa", OP_IDX_1,          3, 0x6a,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "staa", OP_IDX_2,          4, 0x6a,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "staa", OP_D_IDX,          2, 0x6a,  5,  5,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "staa", OP_D_IDX_2,        4, 0x6a,  5,  5,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "stab", OP_IND16,          3, 0xf7,  4,  4,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "stab", OP_DIRECT,         2, 0xd7,  3,  3,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "stab", OP_IX,             2, 0xe7,  4,  4,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "stab", OP_IY | OP_PAGE2,  3, 0xe7,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "stab", OP_DIRECT,         2, 0x5b,  2,  2,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "stab", OP_IND16,          3, 0x7b,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "stab", OP_IDX,            2, 0x6b,  2,  2,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "stab", OP_IDX_1,          3, 0x6b,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "stab", OP_IDX_2,          4, 0x6b,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "stab", OP_D_IDX,          2, 0x6b,  5,  5,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "stab", OP_D_IDX_2,        4, 0x6b,  5,  5,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "std",  OP_IND16,          3, 0xfd,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "std",  OP_DIRECT,         2, 0xdd,  4,  4,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "std",  OP_IX,             2, 0xed,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "std",  OP_IY | OP_PAGE2,  3, 0xed,  6,  6,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "std",  OP_DIRECT,         2, 0x5c,  2,  2,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "std",  OP_IND16,          3, 0x7c,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "std",  OP_IDX,            2, 0x6c,  2,  2,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "std",  OP_IDX_1,          3, 0x6c,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "std",  OP_IDX_2,          4, 0x6c,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "std",  OP_D_IDX,          2, 0x6c,  5,  5,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "std",  OP_D_IDX_2,        4, 0x6c,  5,  5,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "stop", OP_NONE,           1, 0xcf,  2,  2,  CHG_NONE, cpu6811, 0 },
+  { "stop", OP_NONE | OP_PAGE2,2, 0x3e,  2,  9,  CHG_NONE, cpu6812|cpu9s12x, 0 },
+
+  { "sts",  OP_IND16,          3, 0xbf,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "sts",  OP_DIRECT,         2, 0x9f,  4,  4,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "sts",  OP_IX,             2, 0xaf,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "sts",  OP_IY | OP_PAGE2,  3, 0xaf,  6,  6,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "sts",  OP_DIRECT,         2, 0x5f,  2,  2,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "sts",  OP_IND16,          3, 0x7f,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "sts",  OP_IDX,            2, 0x6f,  2,  2,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "sts",  OP_IDX_1,          3, 0x6f,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "sts",  OP_IDX_2,          4, 0x6f,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "sts",  OP_D_IDX,          2, 0x6f,  5,  5,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "sts",  OP_D_IDX_2,        4, 0x6f,  5,  5,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "stx",  OP_IND16,          3, 0xff,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "stx",  OP_DIRECT,         2, 0xdf,  4,  4,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "stx",  OP_IX,             2, 0xef,  5,  5,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "stx",  OP_IY | OP_PAGE4,  3, 0xef,  6,  6,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "stx",  OP_DIRECT,         2, 0x5e,  2,  2,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "stx",  OP_IND16,          3, 0x7e,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "stx",  OP_IDX,            2, 0x6e,  2,  2,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "stx",  OP_IDX_1,          3, 0x6e,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "stx",  OP_IDX_2,          4, 0x6e,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "stx",  OP_D_IDX,          2, 0x6e,  5,  5,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "stx",  OP_D_IDX_2,        4, 0x6e,  5,  5,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "sty",  OP_IND16 | OP_PAGE2,  4, 0xff, 6, 6, CLR_V_CHG_NZ, cpu6811, 0 },
+  { "sty",  OP_DIRECT | OP_PAGE2, 3, 0xdf, 5, 5, CLR_V_CHG_NZ, cpu6811, 0 },
+  { "sty",  OP_IY | OP_PAGE2,     3, 0xef, 6, 6, CLR_V_CHG_NZ, cpu6811, 0 },
+  { "sty",  OP_IX | OP_PAGE3,     3, 0xef, 6, 6, CLR_V_CHG_NZ, cpu6811, 0 },
+  { "sty",  OP_DIRECT,         2, 0x5d,  2,  2,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "sty",  OP_IND16,          3, 0x7d,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "sty",  OP_IDX,            2, 0x6d,  2,  2,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "sty",  OP_IDX_1,          3, 0x6d,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "sty",  OP_IDX_2,          4, 0x6d,  3,  3,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "sty",  OP_D_IDX,          2, 0x6d,  5,  5,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "sty",  OP_D_IDX_2,        4, 0x6d,  5,  5,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "suba", OP_IMM8,           2, 0x80,  1,  1,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "suba", OP_DIRECT,         2, 0x90,  3,  3,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "suba", OP_IND16,          3, 0xb0,  3,  3,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "suba", OP_IX,             2, 0xa0,  4,  4,  CHG_NZVC, cpu6811, 0 },
+  { "suba", OP_IY | OP_PAGE2,  3, 0xa0,  5,  5,  CHG_NZVC, cpu6811, 0 },
+  { "suba", OP_IDX,            2, 0xa0,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "suba", OP_IDX_1,          3, 0xa0,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "suba", OP_IDX_2,          4, 0xa0,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "suba", OP_D_IDX,          2, 0xa0,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "suba", OP_D_IDX_2,        4, 0xa0,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "subb", OP_IMM8,           2, 0xc0,  1,  1,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "subb", OP_DIRECT,         2, 0xd0,  3,  3,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "subb", OP_IND16,          3, 0xf0,  3,  3,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "subb", OP_IX,             2, 0xe0,  4,  4,  CHG_NZVC, cpu6811, 0 },
+  { "subb", OP_IY | OP_PAGE2,  3, 0xe0,  5,  5,  CHG_NZVC, cpu6811, 0 },
+  { "subb", OP_IDX,            2, 0xe0,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "subb", OP_IDX_1,          3, 0xe0,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "subb", OP_IDX_2,          4, 0xe0,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "subb", OP_D_IDX,          2, 0xe0,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "subb", OP_D_IDX_2,        4, 0xe0,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "subd", OP_IMM16,          3, 0x83,  2,  2,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "subd", OP_DIRECT,         2, 0x93,  3,  3,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "subd", OP_IND16,          3, 0xb3,  3,  3,  CHG_NZVC, cpu6811|cpu6812|cpu9s12x, 0 },
+  { "subd", OP_IX,             2, 0xa3,  6,  6,  CHG_NZVC, cpu6811, 0 },
+  { "subd", OP_IY | OP_PAGE2,  3, 0xa3,  7,  7,  CHG_NZVC, cpu6811, 0 },
+  { "subd", OP_IDX,            2, 0xa3,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "subd", OP_IDX_1,          3, 0xa3,  3,  3,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "subd", OP_IDX_2,          4, 0xa3,  4,  4,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "subd", OP_D_IDX,          2, 0xa3,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+  { "subd", OP_D_IDX_2,        4, 0xa3,  6,  6,  CHG_NZVC, cpu6812|cpu9s12x, 0 },
+
+  { "subx", OP_IMM16 | OP_PAGE2,          3, 0x80,  2,  2,  CHG_NZVC, cpu9s12x, 0 },
+  { "subx", OP_DIRECT | OP_PAGE2,         2, 0x90,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "subx", OP_IND16 | OP_PAGE2,          3, 0xb0,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "subx", OP_IDX | OP_PAGE2,            2, 0xa0,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "subx", OP_IDX_1 | OP_PAGE2,          3, 0xa0,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "subx", OP_IDX_2 | OP_PAGE2,          4, 0xa0,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "subx", OP_D_IDX | OP_PAGE2,          2, 0xa0,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "subx", OP_D_IDX_2 | OP_PAGE2,        4, 0xa0,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "suby", OP_IMM16 | OP_PAGE2,          3, 0xc0,  2,  2,  CHG_NZVC, cpu9s12x, 0 },
+  { "suby", OP_DIRECT | OP_PAGE2,         2, 0xd0,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "suby", OP_IND16 | OP_PAGE2,          3, 0xf0,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "suby", OP_IDX | OP_PAGE2,            2, 0xe0,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "suby", OP_IDX_1 | OP_PAGE2,          3, 0xe0,  3,  3,  CHG_NZVC, cpu9s12x, 0 },
+  { "suby", OP_IDX_2 | OP_PAGE2,          4, 0xe0,  4,  4,  CHG_NZVC, cpu9s12x, 0 },
+  { "suby", OP_D_IDX | OP_PAGE2,          2, 0xe0,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+  { "suby", OP_D_IDX_2 | OP_PAGE2,        4, 0xe0,  6,  6,  CHG_NZVC, cpu9s12x, 0 },
+
+  { "swi",  OP_NONE,           1, 0x3f,  9,  9,  CHG_NONE, cpu6811|cpu6812|cpu9s12x, 0 },
+
+  { "tab",  OP_NONE,           1, 0x16,  2,  2,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "tab",  OP_NONE | OP_PAGE2,2, 0x0e,  2,  2,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
 
-  { "tap",  OP_NONE,           1, 0x06,  2,  2,  CHG_ALL, cpu6811 },
+  { "tap",  OP_NONE,           1, 0x06,  2,  2,  CHG_ALL, cpu6811, 0 },
 
-  { "tba",  OP_NONE,           1, 0x17,  2,  2,  CLR_V_CHG_NZ, cpu6811 },
-  { "tba",  OP_NONE | OP_PAGE2,2, 0x0f,  2,  2,  CLR_V_CHG_NZ, cpu6812 },
+  { "tba",  OP_NONE,           1, 0x17,  2,  2,  CLR_V_CHG_NZ, cpu6811, 0 },
+  { "tba",  OP_NONE | OP_PAGE2,2, 0x0f,  2,  2,  CLR_V_CHG_NZ, cpu6812|cpu9s12x, 0 },
 
-  { "test", OP_NONE,           1, 0x00,  5, _M,  CHG_NONE, cpu6811 },
+  { "test", OP_NONE,           1, 0x00,  5, _M,  CHG_NONE, cpu6811, 0 },
 
-  { "tpa",  OP_NONE,           1, 0x07,  2,  2,  CHG_NONE, cpu6811 },
+  { "tpa",  OP_NONE,           1, 0x07,  2,  2,  CHG_NONE, cpu6811, 0 },
 
   { "tbeq", OP_TBEQ_MARKER
-          | OP_REG | OP_JUMP_REL,  3, 0x04,  3,  3, CHG_NONE, cpu6812 },
+          | OP_REG | OP_JUMP_REL,  3, 0x04,  3,  3, CHG_NONE, cpu6812|cpu9s12x, 0 },
 
-  { "tbl",  OP_IDX | OP_PAGE2,  3, 0x3d,  8,  8, CHG_NZC, cpu6812 },
+  { "tbl",  OP_IDX | OP_PAGE2,  3, 0x3d,  8,  8, CHG_NZC, cpu6812|cpu9s12x, 0 },
 
   { "tbne", OP_TBNE_MARKER
-          | OP_REG | OP_JUMP_REL,  3, 0x04,  3,  3, CHG_NONE, cpu6812 },
+          | OP_REG | OP_JUMP_REL,  3, 0x04,  3,  3, CHG_NONE, cpu6812|cpu9s12x, 0 },
 
+/* FIXME S12X has more options */
   { "tfr",  OP_TFR_MARKER
-          | OP_REG_1 | OP_REG_2, 2, 0xb7, 1, 1,  CHG_NONE, cpu6812 },
-
-  { "trap", OP_IMM8 | OP_TRAP_ID, 2, 0x18,  11,  11,  SET_I, cpu6812 },
-
-  { "tst",  OP_IND16,          3, 0x7d,  6,  6,  CLR_VC_CHG_NZ, cpu6811 },
-  { "tst",  OP_IX,             2, 0x6d,  6,  6,  CLR_VC_CHG_NZ, cpu6811 },
-  { "tst",  OP_IY | OP_PAGE2,  3, 0x6d,  7,  7,  CLR_VC_CHG_NZ, cpu6811 },
-  { "tst",  OP_IND16,          3, 0xf7,  3,  3,  CLR_VC_CHG_NZ, cpu6812 },
-  { "tst",  OP_IDX,            2, 0xe7,  3,  3,  CLR_VC_CHG_NZ, cpu6812 },
-  { "tst",  OP_IDX_1,          3, 0xe7,  3,  3,  CLR_VC_CHG_NZ, cpu6812 },
-  { "tst",  OP_IDX_2,          4, 0xe7,  4,  4,  CLR_VC_CHG_NZ, cpu6812 },
-  { "tst",  OP_D_IDX,          2, 0xe7,  6,  6,  CLR_VC_CHG_NZ, cpu6812 },
-  { "tst",  OP_D_IDX_2,        4, 0xe7,  6,  6,  CLR_VC_CHG_NZ, cpu6812 },
-
-  { "tsta", OP_NONE,           1, 0x4d,  2,  2,  CLR_VC_CHG_NZ, cpu6811 },
-  { "tsta", OP_NONE,           1, 0x97,  1,  1,  CLR_VC_CHG_NZ, cpu6812 },
-  { "tstb", OP_NONE,           1, 0x5d,  2,  2,  CLR_VC_CHG_NZ, cpu6811 },
-  { "tstb", OP_NONE,           1, 0xd7,  1,  1,  CLR_VC_CHG_NZ, cpu6812 },
-
-  { "tsx",  OP_NONE,           1, 0x30,  3,  3,  CHG_NONE, cpu6811 },
-  { "tsy",  OP_NONE | OP_PAGE2,2, 0x30,  4,  4,  CHG_NONE, cpu6811 },
-  { "txs",  OP_NONE,           1, 0x35,  3,  3,  CHG_NONE, cpu6811 },
-  { "tys",  OP_NONE | OP_PAGE2,2, 0x35,  4,  4,  CHG_NONE, cpu6811 },
+          | OP_REG_1 | OP_REG_2, 2, 0xb7, 1, 1,  CHG_NONE, cpu6812|cpu9s12x, 0 },
 
-  { "wai",  OP_NONE,           1, 0x3e,  5,  _M, CHG_NONE, cpu6811|cpu6812 },
+  { "trap", OP_IMM8 | OP_TRAP_ID, 2, 0x18,  11,  11,  SET_I, cpu6812|cpu9s12x, 0 },
 
-  { "wav",  OP_NONE | OP_PAGE2, 2, 0x3c,  8,  _M, SET_Z_CHG_HNVC, cpu6812 },
-
-  { "xgdx", OP_NONE,           1, 0x8f,  3,  3,  CHG_NONE, cpu6811 },
-  { "xgdy", OP_NONE | OP_PAGE2,2, 0x8f,  4,  4,  CHG_NONE, cpu6811 }
+  { "tst",  OP_IND16,          3, 0x7d,  6,  6,  CLR_VC_CHG_NZ, cpu6811, 0 },
+  { "tst",  OP_IX,             2, 0x6d,  6,  6,  CLR_VC_CHG_NZ, cpu6811, 0 },
+  { "tst",  OP_IY | OP_PAGE2,  3, 0x6d,  7,  7,  CLR_VC_CHG_NZ, cpu6811, 0 },
+  { "tst",  OP_IND16,          3, 0xf7,  3,  3,  CLR_VC_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "tst",  OP_IDX,            2, 0xe7,  3,  3,  CLR_VC_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "tst",  OP_IDX_1,          3, 0xe7,  3,  3,  CLR_VC_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "tst",  OP_IDX_2,          4, 0xe7,  4,  4,  CLR_VC_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "tst",  OP_D_IDX,          2, 0xe7,  6,  6,  CLR_VC_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "tst",  OP_D_IDX_2,        4, 0xe7,  6,  6,  CLR_VC_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "tsta", OP_NONE,           1, 0x4d,  2,  2,  CLR_VC_CHG_NZ, cpu6811, 0 },
+  { "tsta", OP_NONE,           1, 0x97,  1,  1,  CLR_VC_CHG_NZ, cpu6812|cpu9s12x, 0 },
+  { "tstb", OP_NONE,           1, 0x5d,  2,  2,  CLR_VC_CHG_NZ, cpu6811, 0 },
+  { "tstb", OP_NONE,           1, 0xd7,  1,  1,  CLR_VC_CHG_NZ, cpu6812|cpu9s12x, 0 },
+
+  { "tstw",  OP_IND16| OP_PAGE2,          3, 0xf7,  3,  3,  CLR_VC_CHG_NZ, cpu9s12x, 0 },
+  { "tstw",  OP_IDX| OP_PAGE2,            2, 0xe7,  3,  3,  CLR_VC_CHG_NZ, cpu9s12x, 0 },
+  { "tstw",  OP_IDX_1| OP_PAGE2,          3, 0xe7,  3,  3,  CLR_VC_CHG_NZ, cpu9s12x, 0 },
+  { "tstw",  OP_IDX_2| OP_PAGE2,          4, 0xe7,  4,  4,  CLR_VC_CHG_NZ, cpu9s12x, 0 },
+  { "tstw",  OP_D_IDX| OP_PAGE2,          2, 0xe7,  6,  6,  CLR_VC_CHG_NZ, cpu9s12x, 0 },
+  { "tstw",  OP_D_IDX_2| OP_PAGE2,        4, 0xe7,  6,  6,  CLR_VC_CHG_NZ, cpu9s12x, 0 },
+
+  { "tstx", OP_NONE| OP_PAGE2,           1, 0x97,  1,  1,  CLR_VC_CHG_NZ, cpu9s12x, 0 },
+  { "tsty", OP_NONE| OP_PAGE2,           1, 0xd7,  1,  1,  CLR_VC_CHG_NZ, cpu9s12x, 0 },
+
+  { "tsx",  OP_NONE,           1, 0x30,  3,  3,  CHG_NONE, cpu6811, 0 },
+  { "tsy",  OP_NONE | OP_PAGE2,2, 0x30,  4,  4,  CHG_NONE, cpu6811, 0 },
+  { "txs",  OP_NONE,           1, 0x35,  3,  3,  CHG_NONE, cpu6811, 0 },
+  { "tys",  OP_NONE | OP_PAGE2,2, 0x35,  4,  4,  CHG_NONE, cpu6811, 0 },
+
+  { "wai",  OP_NONE,           1, 0x3e,  5,  _M, CHG_NONE, cpu6811|cpu6812|cpu9s12x, 0 },
+
+  { "wav",  OP_NONE | OP_PAGE2, 2, 0x3c,  8,  _M, SET_Z_CHG_HNVC, cpu6812|cpu9s12x, 0 },
+
+  { "xgdx", OP_NONE,           1, 0x8f,  3,  3,  CHG_NONE, cpu6811, 0 },
+  { "xgdy", OP_NONE | OP_PAGE2,2, 0x8f,  4,  4,  CHG_NONE, cpu6811, 0 },
+
+/* XGATE opcodes */
+//Return to Scheduler and Others
+  { "brk",   M68XG_OP_NONE,           2, 0x0000, 0, 0, 0, 0, 0, cpuxgate, 0xffff },
+  { "nop",   M68XG_OP_NONE,           2, 0x0100, 0, 0, 0, 0, 0, cpuxgate, 0xffff },
+  { "rts",   M68XG_OP_NONE,           2, 0x0200, 0, 0, 0, 0, 0, cpuxgate, 0xffff },
+  { "sif",   M68XG_OP_NONE,           2, 0x0300, 0, 0, 0, 0, 0, cpuxgate, 0xffff },
+// Semaphore Instructions
+  { "csem",  M68XG_OP_IMM3,           2, 0x00f0, 0, 0, 0, 0, 0, cpuxgate, 0xf8ff },
+  { "csem",  M68XG_OP_R,              2, 0x00f1, 0, 0, 0, 0, 0, cpuxgate, 0xf8ff },
+  { "ssem",  M68XG_OP_IMM3,           2, 0x00f2, 0, 0, 0, 0, 0, cpuxgate, 0xf8ff },
+  { "ssem",  M68XG_OP_R,              2, 0x00f3, 0, 0, 0, 0, 0, cpuxgate, 0xf8ff },
+//Single Register Instructions
+  { "sex",   M68XG_OP_R,              2, 0x00f4, 0, 0, 0, 0, 0, cpuxgate, 0xf8ff },
+  { "par",   M68XG_OP_R,              2, 0x00f5, 0, 0, 0, 0, 0, cpuxgate, 0xf8ff },
+  { "jal",   M68XG_OP_R,              2, 0x00f6, 0, 0, 0, 0, 0, cpuxgate, 0xf8ff },
+  { "sif",   M68XG_OP_R,              2, 0x00f7, 0, 0, 0, 0, 0, cpuxgate, 0xf8ff },
+//Special Move instructions
+  { "tfr",   M68XG_OP_R,              2, 0x00f8, 0, 0, 0, 0, 0, cpuxgate, 0xf8ff }, // RD,CCR
+  { "tfr",   M68XG_OP_R,              2, 0x00f9, 0, 0, 0, 0, 0, cpuxgate, 0xf8ff }, // CCR,RS
+  { "tfr",   M68XG_OP_R,              2, 0x00fa, 0, 0, 0, 0, 0, cpuxgate, 0xf8ff }, // RD,PC
+//Shift instructions Dyadic
+  { "bffo",  M68XG_OP_R_R,            2, 0x0810, 0, 0, 0, 0, 0, cpuxgate, 0xf81f },
+  { "asr",   M68XG_OP_R_R,            2, 0x0811, 0, 0, 0, 0, 0, cpuxgate, 0xf81f },
+  { "csl",   M68XG_OP_R_R,            2, 0x0812, 0, 0, 0, 0, 0, cpuxgate, 0xf81f },
+  { "csr",   M68XG_OP_R_R,            2, 0x0813, 0, 0, 0, 0, 0, cpuxgate, 0xf81f },
+  { "lsl",   M68XG_OP_R_R,            2, 0x0814, 0, 0, 0, 0, 0, cpuxgate, 0xf81f },
+  { "lsr",   M68XG_OP_R_R,            2, 0x0815, 0, 0, 0, 0, 0, cpuxgate, 0xf81f },
+  { "rol",   M68XG_OP_R_R,            2, 0x0816, 0, 0, 0, 0, 0, cpuxgate, 0xf81f },
+  { "ror",   M68XG_OP_R_R,            2, 0x0817, 0, 0, 0, 0, 0, cpuxgate, 0xf81f },
+//Compare dyadic (alias for sub r0,...)
+  { "cmp",   M68XG_OP_R_R,            2, 0x1800, 0, 0, 0, 0, 0, cpuxgate, 0x0000 },
+//Shift instructions immediate
+  { "asr",   M68XG_OP_R_IMM4,         2, 0x0809, 0, 0, 0, 0, 0, cpuxgate, 0xf81f },
+  { "csl",   M68XG_OP_R_IMM4,         2, 0x080a, 0, 0, 0, 0, 0, cpuxgate, 0xf81f },
+  { "csr",   M68XG_OP_R_IMM4,         2, 0x080b, 0, 0, 0, 0, 0, cpuxgate, 0xf81f },
+  { "lsl",   M68XG_OP_R_IMM4,         2, 0x080c, 0, 0, 0, 0, 0, cpuxgate, 0xf81f },
+  { "lsr",   M68XG_OP_R_IMM4,         2, 0x080d, 0, 0, 0, 0, 0, cpuxgate, 0xf81f },
+  { "rol",   M68XG_OP_R_IMM4,         2, 0x080e, 0, 0, 0, 0, 0, cpuxgate, 0xf81f },
+  { "ror",   M68XG_OP_R_IMM4,         2, 0x080f, 0, 0, 0, 0, 0, cpuxgate, 0xf81f },
+//Logical Triadic
+  { "and",   M68XG_OP_R_R_R,          2, 0x1000, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+  { "or",    M68XG_OP_R_R_R,          2, 0x1002, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+  { "xnor",  M68XG_OP_R_R_R,          2, 0x1003, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+//Arithmetic Triadic                                  For compare use SUB R0,Rs1,Rs2
+  { "sub",   M68XG_OP_R_R_R,          2, 0x1800, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+  { "sbc",   M68XG_OP_R_R_R,          2, 0x1801, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+  { "add",   M68XG_OP_R_R_R,          2, 0x1802, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+  { "adc",   M68XG_OP_R_R_R,          2, 0x1803, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+//Branches
+  { "bcc",   M68XG_OP_REL9,           2, 0x2000, 0, 0, 0, 0, 0, cpuxgate, 0xfe00 },
+  { "bcs",   M68XG_OP_REL9,           2, 0x2200, 0, 0, 0, 0, 0, cpuxgate, 0xfe00 },
+  { "bne",   M68XG_OP_REL9,           2, 0x2400, 0, 0, 0, 0, 0, cpuxgate, 0xfe00 },
+  { "beq",   M68XG_OP_REL9,           2, 0x2600, 0, 0, 0, 0, 0, cpuxgate, 0xfe00 },
+  { "bpl",   M68XG_OP_REL9,           2, 0x2800, 0, 0, 0, 0, 0, cpuxgate, 0xfe00 },
+  { "bmi",   M68XG_OP_REL9,           2, 0x2a00, 0, 0, 0, 0, 0, cpuxgate, 0xfe00 },
+  { "bvc",   M68XG_OP_REL9,           2, 0x2c00, 0, 0, 0, 0, 0, cpuxgate, 0xfe00 },
+  { "bvs",   M68XG_OP_REL9,           2, 0x2e00, 0, 0, 0, 0, 0, cpuxgate, 0xfe00 },
+  { "bhi",   M68XG_OP_REL9,           2, 0x3000, 0, 0, 0, 0, 0, cpuxgate, 0xfe00 },
+  { "bls",   M68XG_OP_REL9,           2, 0x3200, 0, 0, 0, 0, 0, cpuxgate, 0xfe00 },
+  { "bge",   M68XG_OP_REL9,           2, 0x3400, 0, 0, 0, 0, 0, cpuxgate, 0xfe00 },
+  { "blt",   M68XG_OP_REL9,           2, 0x3600, 0, 0, 0, 0, 0, cpuxgate, 0xfe00 },
+  { "bgt",   M68XG_OP_REL9,           2, 0x3800, 0, 0, 0, 0, 0, cpuxgate, 0xfe00 },
+  { "ble",   M68XG_OP_REL9,           2, 0x3a00, 0, 0, 0, 0, 0, cpuxgate, 0xfe00 },
+  { "bra",   M68XG_OP_REL10,          2, 0x3c00, 0, 0, 0, 0, 0, cpuxgate, 0xfc00 },
+// Load and Store Instructions
+  { "ldb",   M68XG_OP_R_R_OFFS5,      2, 0x4000, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+  { "ldw",   M68XG_OP_R_R_OFFS5,      2, 0x4800, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+  { "stb",   M68XG_OP_R_R_OFFS5,      2, 0x5000, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+  { "stw",   M68XG_OP_R_R_OFFS5,      2, 0x5800, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+
+  { "ldb",   M68XG_OP_RD_RB_RI,       2, 0x6000, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+  { "ldw",   M68XG_OP_RD_RB_RI,       2, 0x6800, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+  { "stb",   M68XG_OP_RD_RB_RI,       2, 0x7000, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+  { "stw",   M68XG_OP_RD_RB_RI,       2, 0x7800, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+
+  { "ldb",   M68XG_OP_RD_RB_RIp,      2, 0x6001, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+  { "ldw",   M68XG_OP_RD_RB_RIp,      2, 0x6801, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+  { "stb",   M68XG_OP_RD_RB_RIp,      2, 0x7001, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+  { "stw",   M68XG_OP_RD_RB_RIp,      2, 0x7801, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+
+  { "ldb",   M68XG_OP_RD_RB_mRI,      2, 0x6002, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+  { "ldw",   M68XG_OP_RD_RB_mRI,      2, 0x6802, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+  { "stb",   M68XG_OP_RD_RB_mRI,      2, 0x7002, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+  { "stw",   M68XG_OP_RD_RB_mRI,      2, 0x7802, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+//Bit Field Instructions
+  { "bfext", M68XG_OP_R_R_R,          2, 0x6003, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+  { "bfins", M68XG_OP_R_R_R,          2, 0x6803, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+  { "bfinsi",M68XG_OP_R_R_R,          2, 0x7003, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+  { "bfinsx",M68XG_OP_R_R_R,          2, 0x7803, 0, 0, 0, 0, 0, cpuxgate, 0xf803 },
+/* these immediate commands need better handling so we can send
+   the assembler a 16bit address and generate the two opcodes */
+//Logic Immediate Instructions
+  { "andl",  M68XG_OP_R_IMM8,         2, 0x8000, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+  { "andh",  M68XG_OP_R_IMM8,         2, 0x8800, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+  { "bitl",  M68XG_OP_R_IMM8,         2, 0x9000, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+  { "bith",  M68XG_OP_R_IMM8,         2, 0x9800, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+  { "orl",   M68XG_OP_R_IMM8,         2, 0xa000, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+  { "orh",   M68XG_OP_R_IMM8,         2, 0xa800, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+  { "xnorl", M68XG_OP_R_IMM8,         2, 0xb000, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+  { "xnorh", M68XG_OP_R_IMM8,         2, 0xb800, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+//Arithmetic Immediate Instructions
+  { "subl",  M68XG_OP_R_IMM8,         2, 0xc000, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+  { "subh",  M68XG_OP_R_IMM8,         2, 0xc800, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+  { "cmpl",  M68XG_OP_R_IMM8,         2, 0xd000, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+  { "cpch",  M68XG_OP_R_IMM8,         2, 0xd800, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+  { "addl",  M68XG_OP_R_IMM8,         2, 0xe000, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+  { "addh",  M68XG_OP_R_IMM8,         2, 0xe800, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+  { "ldl",   M68XG_OP_R_IMM8,         2, 0xf000, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+  { "ldh",   M68XG_OP_R_IMM8,         2, 0xf800, 0, 0, 0, 0, 0, cpuxgate, 0xf800 },
+ /* 16 bit versions.
+ * These are pseudo opcodes to allow 16 bit addresses
+ * to be passed.
+ * Mask ensures we'll never disassemble to these instructions
+*/
+//Logic Immediate Instructions
+  { "and",   M68XG_OP_R_IMM16,        2, 0x8000, 0, 0, 0, 0, 0, cpuxgate, 0x0000 },
+  { "bit",   M68XG_OP_R_IMM16,        2, 0x9000, 0, 0, 0, 0, 0, cpuxgate, 0x0000 },
+  { "or",    M68XG_OP_R_IMM16,        2, 0xa000, 0, 0, 0, 0, 0, cpuxgate, 0x0000 },
+  { "xnor",  M68XG_OP_R_IMM16,        2, 0xb000, 0, 0, 0, 0, 0, cpuxgate, 0x0000 },
+//Arithmetic Immediate Instructions
+  { "sub",   M68XG_OP_R_IMM16,        2, 0xc000, 0, 0, 0, 0, 0, cpuxgate, 0x0000 },
+  { "cmp",   M68XG_OP_R_IMM16,        2, 0xd000, 0, 0, 0, 0, 0, cpuxgate, 0x0000 },
+  { "add",   M68XG_OP_R_IMM16,        2, 0xe000, 0, 0, 0, 0, 0, cpuxgate, 0x0000 },
+  { "ld",    M68XG_OP_R_IMM16,        2, 0xf000, 0, 0, 0, 0, 0, cpuxgate, 0x0000 }
 };
 
 const int m68hc11_num_opcodes = TABLE_SIZE (m68hc11_opcodes);
@@ -1080,3 +1734,4 @@
   { "xgdy","exg d,y",    2, 0xb7, 0xc6 }
 };
 const int m68hc12_num_alias = TABLE_SIZE (m68hc12_alias);
+
