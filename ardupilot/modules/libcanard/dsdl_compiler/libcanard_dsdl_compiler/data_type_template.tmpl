/*
 * UAVCAN data structure definition for libcanard.
 *
 * Autogenerated, do not edit.
 *
 * Source file: ${t.source_file}
 */

#ifndef ${t.include_guard}
#define ${t.include_guard}

#include <stdint.h>
#include "canard.h"

#ifdef __cplusplus
extern "C"
{
#endif

% for inc in t.cpp_includes:
#include <${inc}>
% endfor


<!--(macro storage_class)-->
 %if t.header_only
static inline
 %else
extern
 %endif
<!--(end)-->

/******************************* Source text **********************************
% for line in t.source_text.strip().splitlines():
${line}
% endfor
******************************************************************************/

/********************* DSDL signature source definition ***********************
% for line in t.get_dsdl_signature_source_definition().splitlines():
${line}
% endfor
******************************************************************************/

%if t.default_dtid != None:
#define ${'%-50s' % (t.macro_name + '_ID')} ${t.default_dtid}
%endif
#define ${'%-50s' % (t.macro_name + '_NAME')} "${t.full_name}"
#define ${'%-50s' % (t.macro_name + '_SIGNATURE')} (${'0x%08X' % t.get_data_type_signature()}ULL)

<!--(macro generate_primary_body)--> #! type_name, service, max_bitlen, fields, constants, union, has_array

#define ${'%-50s' % (t.macro_name + service + '_MAX_SIZE')} ((${'%d' % max_bitlen} + 7)/8)

 %if max_bitlen

// Constants
    % for a in constants:
#define ${'%-60s %10s' % (t.macro_name + service + '_' + a.name, a.init_expression, )} // ${a.init_expression}
    % endfor

    % for a in fields:
        %if a.type_category == t.CATEGORY_ARRAY
            %if a.dynamic_array == True
#define ${'%-80s' % (t.macro_name + service + '_' + a.name.upper() + '_MAX_LENGTH')} ${a.type.max_size}
            %else
#define ${'%-80s' % (t.macro_name + service + '_' + a.name.upper() + '_LENGTH')} ${a.type.max_size}  
            %endif
        %endif
    % endfor

  %if union
typedef enum
{
    % for idx,last,a in enum_last_value(fields):
    ${type_name.upper()}_${a.name.upper()}${',' if not last else ''}
    % endfor
} ${type_name}_ENUM;
  %endif

typedef struct
{
    %if union:
    ${type_name}_ENUM union_tag;        // union_tag indicates what field the data structure is holding

    union
    {
    %endif
  <!--(macro expand_attr_types)--> #! group_name, attrs
    // ${group_name}
    % for a in attrs:
        %if a.type_category == t.CATEGORY_ARRAY
            %if a.dynamic_array == True
    struct
    {
                %if a.max_array_elements > 255
        ${'uint16_t    %-26s // %s' % (('len;'), 'Dynamic array length')}
                %else
        ${'uint8_t    %-26s // %s' % (('len;'), 'Dynamic array length')}
                %endif
        ${'%-10s %-26s // %s' % ((a.cpp_type + '*'), ('data;'), a.cpp_type_comment, )}
    } ${a.name};
            %else
    ${'%-10s %-30s // %s' % (a.cpp_type, (a.name + a.post_cpp_type + ';'), a.cpp_type_comment, )}
            %endif
        %elif a.type_category == t.CATEGORY_VOID:
    // ${a.cpp_type_comment}
        %else
    ${'%-10s %-30s // %s' % (a.cpp_type, (a.name + a.post_cpp_type + ';'), a.cpp_type_comment, )}
        %endif
    % endfor
  <!--(end)-->
  ${expand_attr_types(group_name='FieldTypes', attrs=fields)}
  %if union:
    };
  %endif
} ${type_name};

@!storage_class!@uint32_t ${type_name}_encode(${type_name}* source, void* msg_buf);
@!storage_class!@int32_t ${type_name}_decode(const CanardRxTransfer* transfer, uint16_t payload_len, ${type_name}* dest, uint8_t** dyn_arr_buf);

@!storage_class!@uint32_t ${type_name}_encode_internal(${type_name}* source, void* msg_buf, uint32_t offset, uint8_t root_item);
@!storage_class!@int32_t ${type_name}_decode_internal(const CanardRxTransfer* transfer, uint16_t payload_len, ${type_name}* dest, uint8_t** dyn_arr_buf, int32_t offset);
 %else
typedef struct
{
    uint8_t empty;
} ${type_name};
@!storage_class!@uint32_t ${type_name}_encode(${type_name}* source, void* msg_buf);
@!storage_class!@int32_t ${type_name}_decode(const CanardRxTransfer* transfer, uint16_t payload_len, ${type_name}* dest, uint8_t** dyn_arr_buf);
@!storage_class!@uint32_t ${type_name}_encode_internal(${type_name}* source, void* msg_buf, uint32_t offset, uint8_t root_item);
@!storage_class!@int32_t ${type_name}_decode_internal(const CanardRxTransfer* transfer, uint16_t payload_len, ${type_name}* dest, uint8_t** dyn_arr_buf, int32_t offset);

 %endif
<!--(end)-->

% if t.kind == t.KIND_SERVICE:
${generate_primary_body(type_name=t.name_space_type_name+'Request', service='_REQUEST', max_bitlen=t.get_max_bitlen_request(), \
                               fields=t.request_fields, constants=t.request_constants, \
                               union=t.request_union, has_array=t.request_has_array)}

${generate_primary_body(type_name=t.name_space_type_name+'Response', service='_RESPONSE', max_bitlen=t.get_max_bitlen_response(), \
                               fields=t.response_fields, constants=t.response_constants, \
                               union=t.response_union, has_array=t.response_has_array)}
% else:
${generate_primary_body(type_name=t.name_space_type_name, service='', max_bitlen=t.get_max_bitlen(), \
                        fields=t.fields, constants=t.constants, union=t.union, has_array=t.has_array)}
% endif
%if not t.header_only
#ifdef __cplusplus
} // extern "C"
#endif
#endif // ${t.include_guard}
%endif
